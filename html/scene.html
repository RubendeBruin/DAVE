<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>DAVE.scene API documentation</title>
<meta name="description" content="This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>DAVE.scene</code></h1>
</header>
<section id="section-intro">
<p>This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/.">http://mozilla.org/MPL/2.0/.</a></p>
<p>Ruben de Bruin - 2019</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.

  Ruben de Bruin - 2019
&#34;&#34;&#34;


from abc import ABC, abstractmethod

import pyo3d
import numpy as np
import DAVE.settings as vfc
from DAVE.tools import *
from os.path import isfile, split, dirname, exists
from os import listdir
from pathlib import Path
import datetime


# we are wrapping all methods of pyo3d such that:
# - it is more user-friendly
# - code-completion is more robust
# - we can do some additional checks. pyo3d is written for speed, not robustness.
# - pyo3d is not a hard dependency
#
# notes and choices:
# - properties are returned as tuple to make sure they are not editable.
#    --&gt; node.position[2] = 5 is not allowed


import functools


# Wrapper (decorator) for managed nodes
def node_setter_manageable(func):
    @functools.wraps(func)
    def wrapper_decorator(self, *args, **kwargs):
        self._verify_change_allowed()
        value = func(self, *args, **kwargs)
        return value

    return wrapper_decorator


# Wrapper (decorator) observed nodes
def node_setter_observable(func):
    @functools.wraps(func)
    def wrapper_decorator(self, *args, **kwargs):
        value = func(self, *args, **kwargs)
        # Do something after
        self._notify_observers()

        return value

    return wrapper_decorator


class ClaimManagement():
    &#34;&#34;&#34;Helper class for doing:

    with ClaimManagement(scene, manager):
        change nodes that belong to manager

    &#34;&#34;&#34;
    def __init__(self, scene, manager):
        assert isinstance(scene, Scene)
        assert isinstance(manager, Manager)
        self.scene = scene
        self.manager= manager


    def __enter__(self):
        self._old_manager = self.scene.current_manager
        self.scene.current_manager = self.manager

    def __exit__(self, *args, **kwargs):
        self.scene.current_manager = self._old_manager

class Node(ABC):
    &#34;&#34;&#34;ABSTRACT CLASS - Properties defined here are applicable to all derived classes
    Master class for all nodes&#34;&#34;&#34;

    def __init__(self, scene):
        self._scene: Scene = scene
        &#34;&#34;&#34;reference to the scene that the node lives is&#34;&#34;&#34;

        self._name: str = &#34;A manager without a name&#34;
        &#34;&#34;&#34;Unique name of the node&#34;&#34;&#34;

        self._manager: Node or None = None
        &#34;&#34;&#34;Reference to a node that controls this node&#34;&#34;&#34;

        self.observers = list()
        &#34;&#34;&#34;List of nodes observing this node.&#34;&#34;&#34;

        self._visible: bool = True
        &#34;&#34;&#34;Determines if the visual for of this node (if any) should be visible&#34;&#34;&#34;

    def __repr__(self):
        return f&#34;{self.name} &lt;{self.__class__.__name__}&gt;&#34;

    def __str__(self):
        return self.name

    @property
    def class_name(self):
        return self.__class__.__name__

    @abstractmethod
    def depends_on(self) -&gt; list:
        &#34;&#34;&#34;Returns a list of nodes that need to be available present for this node to exist&#34;&#34;&#34;
        raise ValueError(
            f&#34;Derived class should implement this method, but {type(self)} does not&#34;
        )

    def give_python_code(self):
        &#34;&#34;&#34;Returns the python code that can be executed to re-create this node&#34;&#34;&#34;
        return &#34;# No python code generated for element {}&#34;.format(self.name)

    @property
    def visible(self):
        if self.manager:
            return self.manager.visible
        return self._visible

    @visible.setter
    @node_setter_manageable
    @node_setter_observable
    def visible(self, value):
        self._visible = value

    @property
    def manager(self):
        return self._manager

    @manager.setter
    @node_setter_manageable
    @node_setter_observable
    def manager(self, value):

        self._manager = value
        pass

    def _verify_change_allowed(self):
        &#34;&#34;&#34;Changing the state of a node is only allowed if either:
        1. the node is not manages (node._manager is None)
        2. the manager of the node is identical to scene.current_manager
        &#34;&#34;&#34;
        if self._scene._godmode:
            return True

        if self._manager is not None:
            if self._manager != self._scene.current_manager:
                if self._scene.current_manager is None:
                    name = None
                else:
                    name = self._scene.current_manager.name
                raise Exception(
                    f&#34;Node {self.name} may not be changed because it is managed by {self._manager.name} and the current manager of the scene is {name}&#34;
                )

    @property
    def name(self):
        &#34;&#34;&#34;Name of the node (str), must be unique&#34;&#34;&#34;
        return self._name

    @name.setter
    @node_setter_manageable
    @node_setter_observable
    def name(self, name):

        self._name = name

    def _delete_vfc(self):
        &#34;&#34;&#34;Removes any internally created core objects&#34;&#34;&#34;
        pass

    def update(self):
        &#34;&#34;&#34;Performs internal updates relevant for physics. Called before solving statics or getting results such as
        forces or inertia&#34;&#34;&#34;
        pass

    def _notify_observers(self):
        for obs in self.observers:
            obs.on_observed_node_changed(self)

    def on_observed_node_changed(self, changed_node):
        &#34;&#34;&#34; &#34;&#34;&#34;
        pass


class CoreConnectedNode(Node):
    &#34;&#34;&#34;ABSTRACT CLASS - Properties defined here are applicable to all derived classes
    Master class for all nodes with a connected eqCore element&#34;&#34;&#34;

    def __init__(self, scene, vfNode):
        super().__init__(scene)
        self._vfNode = vfNode

    @property
    def name(self):
        &#34;&#34;&#34;Name of the node (str), must be unique&#34;&#34;&#34;
        return self._vfNode.name

    @name.setter
    @node_setter_manageable
    @node_setter_observable
    def name(self, name):

        if not name == self._vfNode.name:
            self._scene._verify_name_available(name)
            self._vfNode.name = name

    def _delete_vfc(self):
        self._scene._vfc.delete(self._vfNode.name)


class NodeWithParent(CoreConnectedNode):
    &#34;&#34;&#34;
    NodeWithParent

    Do not use this class directly.
    This is a base-class for all nodes that have a &#34;parent&#34; property.
    &#34;&#34;&#34;

    def __init__(self, scene, vfNode):
        super().__init__(scene, vfNode)
        self._parent = None
        self._None_parent_acceptable = False
        self._parent_for_code_export = True
        &#34;&#34;&#34;True : use parent, 
        None : use None, 
        Node : use that Node
        Used to prevent circular references, see groups section in documentation&#34;&#34;&#34;

    def depends_on(self):
        if self.parent_for_export is not None:
            return [self.parent_for_export]
        else:
            return []

    @property
    def parent_for_export(self):
        if self._parent_for_code_export == True:
            return self._parent
        else:
            return self._parent_for_code_export

    @property
    def parent(self):
        &#34;&#34;&#34;Determines the parent of the node. Should be an axis or None&#34;&#34;&#34;
        if self._vfNode.parent is None:
            return None
        else:
            return self._parent
            # return Axis(self._scene, self._vfNode.parent)

    @parent.setter
    @node_setter_manageable
    @node_setter_observable
    def parent(self, var):
        &#34;&#34;&#34;Assigns a new parent. Keeps the local position and rotations the same

        See also: change_parent_to
        &#34;&#34;&#34;

        if var is None:

            if not self._None_parent_acceptable:
                raise ValueError(
                    &#34;None is not an acceptable parent for {} of {}&#34;.format(
                        self.name, type(self)
                    )
                )

            self._parent = None
            self._vfNode.parent = None
        else:

            var = self._scene._node_from_node_or_str(var)

            if isinstance(var, Axis) or isinstance(var, GeometricContact):
                self._parent = var
                self._vfNode.parent = var._vfNode
            elif isinstance(var, Point):
                self._parent = var
                self._vfNode.parent = var._vfNode
            else:
                raise Exception(
                    &#34;Parent can only be set to an instance of Axis or Poi, not to a {}&#34;.format(
                        type(var)
                    )
                )

    def change_parent_to(self, new_parent):
        &#34;&#34;&#34;Assigns a new parent to the node but keeps the global position and rotation the same.

        See also: .parent (property)

        Args:
            new_parent: new parent node

        &#34;&#34;&#34;

        if isinstance(self, Point) and isinstance(new_parent, Point):
            raise TypeError(&#34;Points can not be placed on points&#34;)

        try:
            self.rotation
            has_rotation = True
        except:
            has_rotation = False

        try:
            self.position
            has_position = True
        except:
            has_position = False

        # it is possible that this function is called on an object without position/rotation
        # in that case just fall-back to a change of parent
        if not has_position and not has_rotation:
            self.parent = new_parent
            return

        # check new_parent
        if new_parent is not None:

            if not isinstance(new_parent, Axis):
                if not has_rotation:
                    if not isinstance(new_parent, Point):
                        raise TypeError(
                            &#34;Only Poi-type nodes (or derived types) can be used as parent. You tried to use a {} as parent&#34;.format(
                                type(new_parent)
                            )
                        )
                else:
                    raise TypeError(
                        &#34;Only None or Axis-type nodes (or derived types)  can be used as parent. You tried to use a {} as parent&#34;.format(
                            type(new_parent)
                        )
                    )

        glob_pos = self.global_position

        if has_rotation:
            glob_rot = self.global_rotation

        self.parent = new_parent

        if new_parent is None:
            self.position = glob_pos
            if has_rotation:
                self.rotation = glob_rot

        else:
            self.position = new_parent.to_loc_position(glob_pos)
            if has_rotation:
                self.rotation = new_parent.to_loc_direction(glob_rot)


class NodeWithParentAndFootprint(NodeWithParent):
    &#34;&#34;&#34;
    NodeWithParentAndFootprint

    Do not use this class directly.
    This is a base-class for all nodes that have a &#34;footprint&#34; property as well as a parent
    &#34;&#34;&#34;

    def __init__(self, scene, vfNode):
        super().__init__(scene, vfNode)

    @property
    def footprint(self):
        &#34;&#34;&#34;tuple of tuples ((x1,y1,z1), (x2,y2,z2), .... (xn,yn,zn)&#34;&#34;&#34;
        r = []
        for i in range(self._vfNode.nFootprintVertices):
            r.append(self._vfNode.footprintVertexGet(i))
        return tuple(r)

    @footprint.setter
    def footprint(self, value):
        &#34;&#34;&#34;Sets the footprint vertices. Supply as an iterable with each element containing three floats&#34;&#34;&#34;
        for t in value:
            assert3f(t, &#34;Each entry of value assigned to footprints &#34;)

        self._vfNode.footprintVertexClearAll()
        for t in value:
            self._vfNode.footprintVertexAdd(*t)

    def add_footprint_python_code(self):
        if self.footprint:
            return f&#34;\ns[&#39;{self.name}&#39;].footprint = {str(self.footprint)}&#34;
        else:
            return &#34;&#34;


# ==============================================================


class Visual(Node):
    &#34;&#34;&#34;
    Visual

    .. image:: ./images/visual.png

    A Visual node contains a 3d visual, typically obtained from a .obj file.
    A visual node can be placed on an axis-type node.

    It is used for visualization. It does not affect the forces, dynamics or statics.

    The visual can be given an offset, rotation and scale. These are applied in the following order

    1. rotate
    2. scale
    3. offset

    Hint: To scale before rotation place the visual on a dedicated axis and rotate that axis.

    &#34;&#34;&#34;

    def __init__(self, scene):

        super().__init__(scene)

        self.offset = [0, 0, 0]
        &#34;&#34;&#34;Offset (x,y,z) of the visual. Offset is applied after scaling&#34;&#34;&#34;
        self.rotation = [0, 0, 0]
        &#34;&#34;&#34;Rotation (rx,ry,rz) of the visual&#34;&#34;&#34;

        self.scale = [1, 1, 1]
        &#34;&#34;&#34;Scaling of the visual. Scaling is applied before offset.&#34;&#34;&#34;

        self.path = &#34;&#34;
        &#34;&#34;&#34;Filename of the visual&#34;&#34;&#34;

        self.parent = None
        &#34;&#34;&#34;Parent : Axis-type&#34;&#34;&#34;

    @property
    def file_path(self):
        return self._scene.get_resource_path(self.path)

    def depends_on(self):
        return [self.parent]

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        code += &#34;\ns.new_visual(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            parent=&#39;{}&#39;,&#34;.format(self.parent.name)
        code += &#34;\n            path=r&#39;{}&#39;,&#34;.format(self.path)
        code += &#34;\n            offset=({}, {}, {}), &#34;.format(*self.offset)
        code += &#34;\n            rotation=({}, {}, {}), &#34;.format(*self.rotation)
        code += &#34;\n            scale=({}, {}, {}) )&#34;.format(*self.scale)

        return code

    def change_parent_to(self, new_parent):

        if not (isinstance(new_parent, Axis) or new_parent is None):
            raise ValueError(
                &#34;Visuals can only be attached to an axis (or derived) or None&#34;
            )

        # get current position and orientation
        if self.parent is not None:
            cur_position = self.parent.to_glob_position(self.offset)
            cur_rotation = self.parent.to_glob_direction(self.rotation)
        else:
            cur_position = self.offset
            cur_rotation = self.rotation

        self.parent = new_parent

        if new_parent is None:
            self.offset = cur_position
            self.rotation = cur_rotation
        else:
            self.offset = new_parent.to_loc_position(cur_position)
            self.rotation = new_parent.to_loc_direction(cur_rotation)


class Axis(NodeWithParentAndFootprint):
    &#34;&#34;&#34;
    Axis

    Axes are the main building blocks of the geometry. They have a position and an rotation in space. Other nodes can be placed on them.
    Axes can be nested by parent/child relationships meaning that an axis can be placed on an other axis.
    The possible movements of an axis can be controlled in each degree of freedom using the &#34;fixed&#34; property.

    Axes are also the main building block of inertia.
    Dynamics are controlled using the inertia properties of an axis: inertia [mT], inertia_position[m,m,m] and inertia_radii [m,m,m]


    Notes:
         - circular references are not allowed: It is not allowed to place a on b and b on a

    &#34;&#34;&#34;

    def __init__(self, scene, vfAxis):
        super().__init__(scene, vfAxis)
        self._None_parent_acceptable = True

        self._inertia = 0
        self._inertia_position = (0, 0, 0)
        self._inertia_radii = (0, 0, 0)

        self._pointmasses = list()
        for i in range(6):
            p = scene._vfc.new_pointmass(
                self.name + vfc.VF_NAME_SPLIT + &#34;pointmass_{}&#34;.format(i)
            )
            p.parent = vfAxis
            self._pointmasses.append(p)
        self._update_inertia()

    def depends_on(self):
        if self.parent is None:
            return []
        else:
            return [self.parent]

    def _delete_vfc(self):
        for p in self._pointmasses:
            self._scene._vfc.delete(p.name)

        super()._delete_vfc()

    @property
    def inertia(self):
        &#34;&#34;&#34;The linear inertia of the axis in [mT] Aka: &#34;Mass&#34;
        - used only for dynamics&#34;&#34;&#34;
        return self._inertia

    @inertia.setter
    @node_setter_manageable
    @node_setter_observable
    def inertia(self, val):

        assert1f(val, &#34;Inertia&#34;)
        self._inertia = val
        self._update_inertia()

    @property
    def inertia_position(self):
        &#34;&#34;&#34;The position of the center of inertia. Aka: &#34;cog&#34; [m,m,m] (local axis)
        - used only for dynamics
        - defined in local axis system&#34;&#34;&#34;
        return tuple(self._inertia_position)

    @inertia_position.setter
    @node_setter_manageable
    @node_setter_observable
    def inertia_position(self, val):

        assert3f(val, &#34;Inertia position&#34;)
        self._inertia_position = tuple(val)
        self._update_inertia()

    @property
    def inertia_radii(self):
        &#34;&#34;&#34;The radii of gyration of the inertia [m,m,m] (local axis)

        Used to calculate the mass moments of inertia via

        Ixx = rxx^2 * inertia
        Iyy = rxx^2 * inertia
        Izz = rxx^2 * inertia

        Note that DAVE does not directly support cross terms in the interia matrix of an axis system. If you want to
        use cross terms then combine multiple axis system to reach the same result. This is because inertia matrices with
        diagonal terms can not be translated.
        &#34;&#34;&#34;
        return np.array(self._inertia_radii, dtype=float)

    @inertia_radii.setter
    @node_setter_manageable
    @node_setter_observable
    def inertia_radii(self, val):

        assert3f_positive(val, &#34;Inertia radii of gyration&#34;)
        self._inertia_radii = val
        self._update_inertia()

    def _update_inertia(self):
        # update mass
        for i in range(6):
            self._pointmasses[i].inertia = self._inertia / 6

        if self._inertia &lt;= 0:
            return

        # update radii and position
        pos = radii_to_positions(*self._inertia_radii)
        for i in range(6):
            p = (
                pos[i][0] + self._inertia_position[0],
                pos[i][1] + self._inertia_position[1],
                pos[i][2] + self._inertia_position[2],
            )
            self._pointmasses[i].position = p
            # print(&#39;{} at {} {} {}&#39;.format(self._inertia/6, *p))

    @property
    def fixed(self):
        &#34;&#34;&#34;Determines which of the six degrees of freedom are fixed, if any. (x,y,z,rx,ry,rz).
        True means that that degree of freedom will not change when solving statics.
        False means a that is may be changed in order to find equilibrium.

        These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)

        See Also: set_free, set_fixed
        &#34;&#34;&#34;
        return self._vfNode.fixed

    @fixed.setter
    @node_setter_manageable
    @node_setter_observable
    def fixed(self, var):

        if var == True:
            var = (True, True, True, True, True, True)
        if var == False:
            var = (False, False, False, False, False, False)

        self._vfNode.fixed = var

    def set_free(self):
        &#34;&#34;&#34;Sets .fixed to (False,False,False,False,False,False)&#34;&#34;&#34;
        self._vfNode.set_free()

    def set_fixed(self):
        &#34;&#34;&#34;Sets .fixed to (True,True,True,True,True,True)&#34;&#34;&#34;

        self._vfNode.set_fixed()

    @property
    def x(self):
        &#34;&#34;&#34;The x-component of the position vector (parent axis) [m]&#34;&#34;&#34;
        return self.position[0]

    @property
    def y(self):
        &#34;&#34;&#34;The y-component of the position vector (parent axis) [m]&#34;&#34;&#34;
        return self.position[1]

    @property
    def z(self):
        &#34;&#34;&#34;The z-component of the position vector (parent axis) [m]&#34;&#34;&#34;
        return self.position[2]

    @x.setter
    @node_setter_manageable
    @node_setter_observable
    def x(self, var):

        a = self.position
        self.position = (var, a[1], a[2])

    @y.setter
    @node_setter_manageable
    @node_setter_observable
    def y(self, var):

        a = self.position
        self.position = (a[0], var, a[2])

    @z.setter
    @node_setter_manageable
    @node_setter_observable
    def z(self, var):

        a = self.position
        self.position = (a[0], a[1], var)

    @property
    def position(self):
        &#34;&#34;&#34;Position of the axis (parent axis) [m,m,m]

        These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)&#34;&#34;&#34;
        return self._vfNode.position

    @position.setter
    @node_setter_manageable
    @node_setter_observable
    def position(self, var):

        assert3f(var, &#34;Position &#34;)
        self._vfNode.position = var
        self._scene._geometry_changed()

    @property
    def rx(self):
        &#34;&#34;&#34;The x-component of the rotation vector [degrees] (parent axis)&#34;&#34;&#34;
        return self.rotation[0]

    @property
    def ry(self):
        &#34;&#34;&#34;The y-component of the rotation vector [degrees] (parent axis)&#34;&#34;&#34;
        return self.rotation[1]

    @property
    def rz(self):
        &#34;&#34;&#34;The z-component of the rotation vector [degrees], (parent axis)&#34;&#34;&#34;
        return self.rotation[2]

    @rx.setter
    @node_setter_manageable
    @node_setter_observable
    def rx(self, var):

        a = self.rotation
        self.rotation = (var, a[1], a[2])

    @ry.setter
    @node_setter_manageable
    @node_setter_observable
    def ry(self, var):

        a = self.rotation
        self.rotation = (a[0], var, a[2])

    @rz.setter
    @node_setter_manageable
    @node_setter_observable
    def rz(self, var):

        a = self.rotation
        self.rotation = (a[0], a[1], var)

    @property
    def rotation(self):
        &#34;&#34;&#34;Rotation of the axis about its origin (rx,ry,rz).
        Defined as a rotation about an axis where the direction of the axis is (rx,ry,rz) and the angle of rotation is |(rx,ry,rz| degrees.
        These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)&#34;&#34;&#34;
        return np.rad2deg(self._vfNode.rotation)

    @rotation.setter
    @node_setter_manageable
    @node_setter_observable
    def rotation(self, var):

        # convert to degrees
        assert3f(var, &#34;Rotation &#34;)
        self._vfNode.rotation = np.deg2rad(var)
        self._scene._geometry_changed()

    # we need to over-ride the parent property to be able to call _geometry_changed afterwards
    @property
    def parent(self):
        &#34;&#34;&#34;Determines the parent of the axis. Should either be another axis or &#39;None&#39;

        Other axis may be refered to by reference or by name (str). So the following are identical

            p = s.new_axis(&#39;parent_axis&#39;)
            c = s.new_axis(&#39;child axis&#39;)

            c.parent = p
            c.parent = &#39;parent_axis&#39;

        To define that an axis does not have a parent use

            c.parent = None

        &#34;&#34;&#34;
        return super().parent

    @parent.setter
    @node_setter_manageable
    @node_setter_observable
    def parent(self, val):

        if val is not None:
            # Circular reference check: are we trying to make self depend on val while val depends on self?
            if self._scene.node_A_core_depends_on_B_core(val, self):
                if isinstance(val, Axis):  # it better be
                    val.change_parent_to(
                        None
                    )  # change the parent of other to None, this breaks the previous dependancy

        NodeWithParent.parent.fset(self, val)
        self._scene._geometry_changed()

    @property
    def gx(self):
        &#34;&#34;&#34;The x-component of the global position vector [m] (global axis )&#34;&#34;&#34;
        return self.global_position[0]

    @property
    def gy(self):
        &#34;&#34;&#34;The y-component of the global position vector [m] (global axis )&#34;&#34;&#34;
        return self.global_position[1]

    @property
    def gz(self):
        &#34;&#34;&#34;The z-component of the global position vector [m] (global axis )&#34;&#34;&#34;
        return self.global_position[2]

    @gx.setter
    @node_setter_manageable
    @node_setter_observable
    def gx(self, var):

        a = self.global_position
        self.global_position = (var, a[1], a[2])

    @gy.setter
    @node_setter_manageable
    @node_setter_observable
    def gy(self, var):

        a = self.global_position
        self.global_position = (a[0], var, a[2])

    @gz.setter
    @node_setter_manageable
    @node_setter_observable
    def gz(self, var):

        a = self.global_position
        self.global_position = (a[0], a[1], var)

    @property
    def global_position(self):
        &#34;&#34;&#34;The global position of the origin of the axis system  [m,m,m] (global axis)&#34;&#34;&#34;
        return self._vfNode.global_position

    @global_position.setter
    @node_setter_manageable
    @node_setter_observable
    def global_position(self, val):

        assert3f(val, &#34;Global Position&#34;)
        if self.parent:
            self.position = self.parent.to_loc_position(val)
        else:
            self.position = val

    @property
    def grx(self):
        &#34;&#34;&#34;The x-component of the global rotation vector [degrees] (global axis)&#34;&#34;&#34;
        return self.global_rotation[0]

    @property
    def gry(self):
        &#34;&#34;&#34;The y-component of the global rotation vector [degrees] (global axis)&#34;&#34;&#34;
        return self.global_rotation[1]

    @property
    def grz(self):
        &#34;&#34;&#34;The z-component of the global rotation vector [degrees] (global axis)&#34;&#34;&#34;
        return self.global_rotation[2]

    @grx.setter
    @node_setter_manageable
    @node_setter_observable
    def grx(self, var):

        a = self.global_rotation
        self.global_rotation = (var, a[1], a[2])

    @gry.setter
    @node_setter_manageable
    @node_setter_observable
    def gry(self, var):

        a = self.global_rotation
        self.global_rotation = (a[0], var, a[2])

    @grz.setter
    @node_setter_manageable
    @node_setter_observable
    def grz(self, var):

        a = self.global_rotation
        self.global_rotation = (a[0], a[1], var)

    @property
    def tilt_x(self):
        &#34;&#34;&#34;Tilt percentage. This is the z-component of the unit y vector [%].

        See Also: heel
        &#34;&#34;&#34;
        y = (0, 1, 0)
        uy = self.to_glob_direction(y)
        return float(100 * uy[2])

    @property
    def heel(self):
        &#34;&#34;&#34;Heel in degrees. SB down is positive [deg].
        This is the inverse sin of the unit y vector(This is the arcsin of the tiltx)

        See also: tilt_x
        &#34;&#34;&#34;
        return np.rad2deg(np.arcsin(self.tilt_x / 100))

    @property
    def tilt_y(self):
        &#34;&#34;&#34;Tilt percentage. This is the z-component of the unit -x vector [%].
        So a positive rotation about the y axis results in a positive tilt_y.

        See Also: trim
        &#34;&#34;&#34;
        x = (-1, 0, 0)
        ux = self.to_glob_direction(x)
        return float(100 * ux[2])

    @property
    def trim(self):
        &#34;&#34;&#34;Trim in degrees. Bow-down is positive [deg].

        This is the inverse sin of the unit -x vector(This is the arcsin of the tilt_y)

        See also: tilt_y
        &#34;&#34;&#34;
        return np.rad2deg(np.arcsin(self.tilt_y / 100))

    @property
    def heading(self):
        &#34;&#34;&#34;Direction (0..360) [deg] of the local x-axis relative to the global x axis. Measured about the global z axis

        heading = atan(u_y,u_x)

        typically:
            heading 0  --&gt; local axis align with global axis
            heading 90 --&gt; local x-axis in direction of global y axis


        See also: heading_compass
        &#34;&#34;&#34;
        x = (1, 0, 0)
        ux = self.to_glob_direction(x)
        heading = np.rad2deg(np.arctan2(ux[1], ux[0]))
        return np.mod(heading, 360)

    @property
    def heading_compass(self):
        &#34;&#34;&#34;The heading (0..360)[deg] assuming that the global y-axis is North and global x-axis is East and rotation accoring compass definition&#34;&#34;&#34;
        return np.mod(90 - self.heading, 360)

    @property
    def global_rotation(self):
        &#34;&#34;&#34;Rotation [deg,deg,deg] (global axis)&#34;&#34;&#34;
        return tuple(np.rad2deg(self._vfNode.global_rotation))

    @global_rotation.setter
    @node_setter_manageable
    @node_setter_observable
    def global_rotation(self, val):

        assert3f(val, &#34;Global Rotation&#34;)
        if self.parent:
            self.rotation = self.parent.to_loc_rotation(val)
        else:
            self.rotation = val

    @property
    def global_transform(self):
        &#34;&#34;&#34;Read-only: The global transform of the axis system [matrix]&#34;&#34;&#34;
        return self._vfNode.global_transform

    @property
    def connection_force(self):
        &#34;&#34;&#34;The forces and moments that this axis applies on its parent at the origin of this axis system. [kN, kN, kN, kNm, kNm, kNm] (Parent axis)

        If this axis would be connected to a point on its parent, and that point would be located at the location of the origin of this axis system
        then the connection force equals the force and moment applied on that point.

        Example:
            parent axis with name A
            this axis with name B
            this axis is located on A at position (10,0,0)
            there is a Point at the center of this axis system.
            A force with Fz = -10 acts on the Point.

            The connection_force is (-10,0,0,0,0,0)

            This is the force and moment as applied on A at point (10,0,0)


        &#34;&#34;&#34;
        return self._vfNode.connection_force

    @property
    def connection_force_x(self):
        &#34;&#34;&#34;The x-component of the connection-force vector [kN] (Parent axis)&#34;&#34;&#34;
        return self.connection_force[0]

    @property
    def connection_force_y(self):
        &#34;&#34;&#34;The y-component of the connection-force vector [kN] (Parent axis)&#34;&#34;&#34;
        return self.connection_force[1]

    @property
    def connection_force_z(self):
        &#34;&#34;&#34;The z-component of the connection-force vector [kN] (Parent axis)&#34;&#34;&#34;
        return self.connection_force[2]

    @property
    def connection_moment_x(self):
        &#34;&#34;&#34;The mx-component of the connection-force vector [kNm] (Parent axis)&#34;&#34;&#34;
        return self.connection_force[3]

    @property
    def connection_moment_y(self):
        &#34;&#34;&#34;The my-component of the connection-force vector [kNm] (Parent axis)&#34;&#34;&#34;
        return self.connection_force[4]

    @property
    def connection_moment_z(self):
        &#34;&#34;&#34;The mx-component of the connection-force vector [kNm] (Parent axis)&#34;&#34;&#34;
        return self.connection_force[5]

    @property
    def applied_force(self):
        &#34;&#34;&#34;The force and moment that is applied on origin of this axis [kN, kN, kN, kNm, kNm, kNm] (Global axis)&#34;&#34;&#34;
        return self._vfNode.applied_force

    @property
    def ux(self):
        &#34;&#34;&#34;The unit x axis [m,m,m] (Global axis)&#34;&#34;&#34;
        return self.to_glob_direction((1, 0, 0))

    @property
    def uy(self):
        &#34;&#34;&#34;The unit y axis [m,m,m] (Global axis)&#34;&#34;&#34;
        return self.to_glob_direction((0, 1, 0))

    @property
    def uz(self):
        &#34;&#34;&#34;The unit z axis [m,m,m] (Global axis)&#34;&#34;&#34;
        return self.to_glob_direction((0, 0, 1))

    @property
    def equilibrium_error(self):
        &#34;&#34;&#34;The unresolved force and moment that on this axis. Should be zero when in equilibrium  (applied-force minus connection force, Parent axis)&#34;&#34;&#34;
        return self._vfNode.equilibrium_error

    def to_loc_position(self, value):
        &#34;&#34;&#34;Returns the local position of a point in the global axis system.
        This considers the position and the rotation of the axis system.
        See Also: to_loc_direction
        &#34;&#34;&#34;
        return self._vfNode.global_to_local_point(value)

    def to_glob_position(self, value):
        &#34;&#34;&#34;Returns the global position of a point in the local axis system.
        This considers the position and the rotation of the axis system.
        See Also: to_glob_direction
        &#34;&#34;&#34;
        return self._vfNode.local_to_global_point(value)

    def to_loc_direction(self, value):
        &#34;&#34;&#34;Returns the local direction of a point in the global axis system.
        This considers only the rotation of the axis system.
        See Also: to_loc_position
        &#34;&#34;&#34;
        return self._vfNode.global_to_local_vector(value)

    def to_glob_direction(self, value):
        &#34;&#34;&#34;Returns the global direction of a point in the local axis system.
        This considers only the rotation of the axis system.
        See Also: to_glob_position&#34;&#34;&#34;
        return self._vfNode.local_to_global_vector(value)

    def to_loc_rotation(self, value):
        &#34;&#34;&#34;Returns the local rotation. Used for rotating rotations.
        See Also: to_loc_position, to_loc_direction
        &#34;&#34;&#34;
        return np.rad2deg(self._vfNode.global_to_local_rotation(np.deg2rad(value)))

    def to_glob_rotation(self, value):
        &#34;&#34;&#34;Returns the global rotation. Used for rotating rotations.
        See Also: to_loc_position, to_loc_direction
        &#34;&#34;&#34;
        return np.rad2deg(self._vfNode.local_to_global_rotation(np.deg2rad(value)))

    def give_load_shear_moment_diagram(
        self, axis_system=None
    ) -&gt; &#34;LoadShearMomentDiagram&#34;:
        &#34;&#34;&#34;Returns a LoadShearMoment diagram

        Args:
            axis_system : optional : coordinate system [axis node] to be used for calculation of the diagram.
            Defaults to the local axis system
        &#34;&#34;&#34;

        if axis_system is None:
            axis_system = self

        assert isinstance(axis_system, Axis), ValueError(
            f&#34;axis_system shall be an instance of Axis, but it is of type {type(axis_system)}&#34;
        )

        # calculate in the right global direction
        glob_dir = axis_system.to_glob_direction((1, 0, 0))
        self._scene._vfc.calculateBendingMoments(*glob_dir)

        lsm = self._vfNode.getBendingMomentDiagram(axis_system._vfNode)

        return LoadShearMomentDiagram(lsm)

    def change_parent_to(self, new_parent):
        &#34;&#34;&#34;Assigns a new parent to the node but keeps the global position and rotation the same.

        See also: .parent (property)

        Args:
            new_parent: new parent node

        &#34;&#34;&#34;

        # check new_parent
        if new_parent is not None:
            if not (
                isinstance(new_parent, Axis) or isinstance(new_parent, GeometricContact)
            ):
                raise TypeError(
                    &#34;Only None or Axis-type nodes (or derived types) can be used as parent. You tried to use a {} as parent&#34;.format(
                        type(new_parent)
                    )
                )

        glob_pos = self.global_position
        glob_rot = self.global_rotation
        self.parent = new_parent
        self.global_position = glob_pos
        self.global_rotation = glob_rot

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\ns.new_axis(name=&#39;{}&#39;,&#34;.format(self.name)
        if self.parent_for_export:
            code += &#34;\n           parent=&#39;{}&#39;,&#34;.format(self.parent_for_export.name)

        # position

        if self.fixed[0]:
            code += &#34;\n           position=({},&#34;.format(self.position[0])
        else:
            code += &#34;\n           position=(solved({}),&#34;.format(self.position[0])
        if self.fixed[1]:
            code += &#34;\n                     {},&#34;.format(self.position[1])
        else:
            code += &#34;\n                     solved({}),&#34;.format(self.position[1])
        if self.fixed[2]:
            code += &#34;\n                     {}),&#34;.format(self.position[2])
        else:
            code += &#34;\n                     solved({})),&#34;.format(self.position[2])

        # rotation

        if self.fixed[3]:
            code += &#34;\n           rotation=({},&#34;.format(self.rotation[0])
        else:
            code += &#34;\n           rotation=(solved({}),&#34;.format(self.rotation[0])
        if self.fixed[4]:
            code += &#34;\n                     {},&#34;.format(self.rotation[1])
        else:
            code += &#34;\n                     solved({}),&#34;.format(self.rotation[1])
        if self.fixed[5]:
            code += &#34;\n                     {}),&#34;.format(self.rotation[2])
        else:
            code += &#34;\n                     solved({})),&#34;.format(self.rotation[2])

        # inertia and radii of gyration
        if self.inertia &gt; 0:
            code += &#34;\n                     inertia = {},&#34;.format(self.inertia)

        if np.any(self.inertia_radii &gt; 0):
            code += &#34;\n                     inertia_radii = ({}, {}, {}),&#34;.format(
                *self.inertia_radii
            )

        # fixeties
        code += &#34;\n           fixed =({}, {}, {}, {}, {}, {}) )&#34;.format(*self.fixed)

        code += self.add_footprint_python_code()

        return code


class Point(NodeWithParentAndFootprint):
    &#34;&#34;&#34;A location on an axis&#34;&#34;&#34;

    # init parent and name are fully derived from NodeWithParent
    # _vfNode is a poi
    def __init__(self, scene, vfPoi):
        super().__init__(scene, vfPoi)
        self._None_parent_acceptable = True

    def on_observed_node_changed(self, changed_node):
        print(changed_node.name + &#34; has changed&#34;)

    @property
    def x(self):
        &#34;&#34;&#34;x component of local position [m] (parent axis)&#34;&#34;&#34;
        return self.position[0]

    @property
    def y(self):
        &#34;&#34;&#34;y component of local position [m] (parent axis)&#34;&#34;&#34;
        return self.position[1]

    @property
    def z(self):
        &#34;&#34;&#34;z component of local position [m] (parent axis)&#34;&#34;&#34;
        return self.position[2]

    @x.setter
    @node_setter_manageable
    @node_setter_observable
    def x(self, var):

        a = self.position
        self.position = (var, a[1], a[2])

    @y.setter
    @node_setter_manageable
    @node_setter_observable
    def y(self, var):

        a = self.position
        self.position = (a[0], var, a[2])

    @z.setter
    @node_setter_manageable
    @node_setter_observable
    @node_setter_manageable
    def z(self, var):

        &#34;&#34;&#34;z component of local position&#34;&#34;&#34;
        a = self.position
        self.position = (a[0], a[1], var)

    @property
    def position(self):
        &#34;&#34;&#34;Local position [m,m,m] (parent axis)&#34;&#34;&#34;
        return self._vfNode.position

    @position.setter
    @node_setter_manageable
    @node_setter_observable
    def position(self, new_position):

        assert3f(new_position)
        self._vfNode.position = new_position

    @property
    def applied_force_and_moment_global(self):
        &#34;&#34;&#34;Applied force and moment on this point [kN, kN, kN, kNm, kNm, kNm] (Global axis)&#34;&#34;&#34;
        return self._vfNode.applied_force

    @property
    def gx(self):
        &#34;&#34;&#34;x component of position [m] (global axis)&#34;&#34;&#34;
        return self.global_position[0]

    @property
    def gy(self):
        &#34;&#34;&#34;y component of position [m] (global axis)&#34;&#34;&#34;
        return self.global_position[1]

    @property
    def gz(self):
        &#34;&#34;&#34;z component of position [m] (global axis)&#34;&#34;&#34;
        return self.global_position[2]

    @gx.setter
    @node_setter_manageable
    @node_setter_observable
    def gx(self, var):

        a = self.global_position
        self.global_position = (var, a[1], a[2])

    @gy.setter
    @node_setter_manageable
    @node_setter_observable
    def gy(self, var):

        a = self.global_position
        self.global_position = (a[0], var, a[2])

    @gz.setter
    @node_setter_manageable
    @node_setter_observable
    def gz(self, var):

        a = self.global_position
        self.global_position = (a[0], a[1], var)

    @property
    def global_position(self):
        &#34;&#34;&#34;Global position [m,m,m] (global axis)&#34;&#34;&#34;
        return self._vfNode.global_position

    @global_position.setter
    @node_setter_manageable
    @node_setter_observable
    def global_position(self, val):

        assert3f(val, &#34;Global Position&#34;)
        if self.parent:
            self.position = self.parent.to_loc_position(val)
        else:
            self.position = val

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\ns.new_point(name=&#39;{}&#39;,&#34;.format(self.name)
        if self.parent_for_export:
            code += &#34;\n          parent=&#39;{}&#39;,&#34;.format(self.parent_for_export.name)

        # position

        code += &#34;\n          position=({},&#34;.format(self.position[0])
        code += &#34;\n                    {},&#34;.format(self.position[1])
        code += &#34;\n                    {}))&#34;.format(self.position[2])

        code += self.add_footprint_python_code()

        return code


class RigidBody(Axis):
    &#34;&#34;&#34;A Rigid body, internally composed of an axis, a point (cog) and a force (gravity)&#34;&#34;&#34;

    def __init__(self, scene, axis, poi, force):
        super().__init__(scene, axis)

        # The axis is the Node
        # poi and force are added separately

        self._vfPoi = poi
        self._vfForce = force

    # override the following properties
    # - name : sets the names of poi and force as well

    def _delete_vfc(self):
        super()._delete_vfc()
        self._scene._vfc.delete(self._vfPoi.name)
        self._scene._vfc.delete(self._vfForce.name)

    @property  # can not define a setter without a getter..?
    def name(self):
        return super().name

    @name.setter
    @node_setter_manageable
    @node_setter_observable
    def name(self, newname):
        &#34;&#34;&#34;Name of the node (str), must be unique&#34;&#34;&#34;

        # super().name = newname
        super(RigidBody, self.__class__).name.fset(self, newname)
        self._vfPoi.name = newname + vfc.VF_NAME_SPLIT + &#34;cog&#34;
        self._vfForce.name = newname + vfc.VF_NAME_SPLIT + &#34;gravity&#34;

    @property
    def footprint(self):
        return super().footprint

    @footprint.setter
    def footprint(self, value):
        &#34;&#34;&#34;Sets the footprint vertices. Supply as an iterable with each element containing three floats&#34;&#34;&#34;
        super(RigidBody, type(self)).footprint.fset(
            self, value
        )  # https://bugs.python.org/issue14965

        # assign the footprint to the CoG as well,
        # but subtract the cog position as
        self._sync_selfweight_footprint()

    def _sync_selfweight_footprint(self):
        &#34;&#34;&#34;The footprint of the CoG is defined relative to the CoG, so its needs to be updated
        whenever the CoG or the footprint changes&#34;&#34;&#34;

        fp = self.footprint

        self._vfPoi.footprintVertexClearAll()
        for t in fp:
            pos = np.array(t, dtype=float)
            relpos = pos - self.cog
            self._vfPoi.footprintVertexAdd(*relpos)

    @property
    def cogx(self):
        &#34;&#34;&#34;x-component of cog position [m] (local axis)&#34;&#34;&#34;
        return self.cog[0]

    @property
    def cogy(self):
        &#34;&#34;&#34;y-component of cog position [m] (local axis)&#34;&#34;&#34;
        return self.cog[1]

    @property
    def cogz(self):
        &#34;&#34;&#34;z-component of cog position [m] (local axis)&#34;&#34;&#34;
        return self.cog[2]

    @property
    def cog(self):
        &#34;&#34;&#34;Center of Gravity position [m,m,m] (local axis)&#34;&#34;&#34;
        return self._vfPoi.position

    @cogx.setter
    @node_setter_manageable
    @node_setter_observable
    def cogx(self, var):

        a = self.cog
        self.cog = (var, a[1], a[2])

    @cogy.setter
    @node_setter_manageable
    @node_setter_observable
    def cogy(self, var):

        a = self.cog
        self.cog = (a[0], var, a[2])

    @cogz.setter
    @node_setter_manageable
    @node_setter_observable
    def cogz(self, var):

        a = self.cog
        self.cog = (a[0], a[1], var)

    @cog.setter
    @node_setter_manageable
    @node_setter_observable
    def cog(self, newcog):

        assert3f(newcog)
        self._vfPoi.position = newcog
        self.inertia_position = self.cog
        self._sync_selfweight_footprint()

    @property
    def mass(self):
        &#34;&#34;&#34;Static mass of the body [mT]

        See Also: inertia
        &#34;&#34;&#34;
        return self._vfForce.force[2] / -vfc.G

    @mass.setter
    @node_setter_manageable
    @node_setter_observable
    def mass(self, newmass):

        assert1f(newmass)
        self.inertia = newmass
        self._vfForce.force = (0, 0, -vfc.G * newmass)

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\ns.new_rigidbody(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n                mass={},&#34;.format(self.mass)
        code += &#34;\n                cog=({},&#34;.format(self.cog[0])
        code += &#34;\n                     {},&#34;.format(self.cog[1])
        code += &#34;\n                     {}),&#34;.format(self.cog[2])

        if self.parent_for_export:
            code += &#34;\n                parent=&#39;{}&#39;,&#34;.format(self.parent_for_export.name)

        # position

        if self.fixed[0]:
            code += &#34;\n                position=({},&#34;.format(self.position[0])
        else:
            code += &#34;\n                position=(solved({}),&#34;.format(self.position[0])
        if self.fixed[1]:
            code += &#34;\n                          {},&#34;.format(self.position[1])
        else:
            code += &#34;\n                          solved({}),&#34;.format(self.position[1])
        if self.fixed[2]:
            code += &#34;\n                          {}),&#34;.format(self.position[2])
        else:
            code += &#34;\n                          solved({})),&#34;.format(self.position[2])

        # rotation

        if self.fixed[3]:
            code += &#34;\n                rotation=({},&#34;.format(self.rotation[0])
        else:
            code += &#34;\n                rotation=(solved({}),&#34;.format(self.rotation[0])
        if self.fixed[4]:
            code += &#34;\n                          {},&#34;.format(self.rotation[1])
        else:
            code += &#34;\n                          solved({}),&#34;.format(self.rotation[1])
        if self.fixed[5]:
            code += &#34;\n                          {}),&#34;.format(self.rotation[2])
        else:
            code += &#34;\n                          solved({})),&#34;.format(self.rotation[2])

        if np.any(self.inertia_radii &gt; 0):
            code += &#34;\n                     inertia_radii = ({}, {}, {}),&#34;.format(
                *self.inertia_radii
            )

        code += &#34;\n                fixed =({}, {}, {}, {}, {}, {}) )&#34;.format(
            *self.fixed
        )

        code += self.add_footprint_python_code()

        return code


class Cable(CoreConnectedNode):
    &#34;&#34;&#34;A Cable represents a linear elastic wire running from a Poi or sheave to another Poi of sheave.

    A cable has a un-stretched length [length] and a stiffness [EA] and may have a diameter [m]. The tension in the cable is calculated.

    Intermediate pois or sheaves may be added.

    - Pois are considered as sheaves with a zero diameter.
    - Sheaves are considered sheaves with the given geometry. If defined then the diameter of the cable is considered when calculating the geometry. The cable runs over the sheave in the positive direction (right hand rule) as defined by the axis of the sheave.

    For cables running over a sheave the friction in sideways direction is considered to be infinite. The geometry is calculated such that the
    cable section between sheaves is perpendicular to the vector from the axis of the sheave to the point where the cable leaves the sheave.

    This assumption results in undefined behaviour when the axis of the sheave is parallel to the cable direction.

    Notes:
        If pois or sheaves on a cable come too close together (&lt;1mm) then they will be pushed away from eachother.
        This prevents the unwanted situation where multiple pois end up at the same location. In that case it can not be determined which amount of force should be applied to each of the pois.


    &#34;&#34;&#34;

    def __init__(self, scene, node):
        super().__init__(scene, node)
        self._pois = list()

    def depends_on(self):
        return [*self._pois]

    @property
    def tension(self):
        &#34;&#34;&#34;Tension in the cable [kN]&#34;&#34;&#34;
        return self._vfNode.tension

    @property
    def stretch(self):
        &#34;&#34;&#34;Stretch of the cable [m]

        Tension [kN] = EA [kN] * stretch [m] / length [m]
        &#34;&#34;&#34;
        return self._vfNode.stretch

    @property
    def length(self):
        &#34;&#34;&#34;Length of the cable when in rest [m]

        Tension [kN] = EA [kN] * stretch [m] / length [m]
        &#34;&#34;&#34;
        return self._vfNode.Length

    @length.setter
    @node_setter_manageable
    @node_setter_observable
    def length(self, val):

        if val &lt; 1e-9:
            raise Exception(
                &#34;Length shall be more than 0 (otherwise stiffness EA/L becomes infinite)&#34;
            )
        self._vfNode.Length = val

    @property
    def EA(self):
        &#34;&#34;&#34;Stiffness of the cable [kN]

        Tension [kN] = EA [kN] * stretch [m] / length [m]
        &#34;&#34;&#34;
        return self._vfNode.EA

    @EA.setter
    @node_setter_manageable
    @node_setter_observable
    def EA(self, ea):

        self._vfNode.EA = ea

    @property
    def diameter(self):
        &#34;&#34;&#34;Diameter of the cable. Used when a cable runs over a circle. [m]&#34;&#34;&#34;
        return self._vfNode.diameter

    @diameter.setter
    @node_setter_manageable
    @node_setter_observable
    def diameter(self, diameter):

        self._vfNode.diameter = diameter

    @property
    def connections(self):
        &#34;&#34;&#34;List or Tuple of nodes that this cable is connected to. Nodes may be passed by name (string) or by reference.

        Example:
            p1 = s.new_point(&#39;point 1&#39;)
            p2 = s.new_point(&#39;point 2&#39;, position = (0,0,10)
            p3 = s.new_point(&#39;point 3&#39;, position = (10,0,10)
            c1 = s.new_circle(&#39;circle 1&#39;,parent = p3, axis = (0,1,0), radius = 1)
            c = s.new_cable(&#34;cable_1&#34;, endA=&#34;Point&#34;, endB = &#34;Circle&#34;, length = 1.2, EA = 10000)

            c.connections = (&#39;point 1&#39;, &#39;point 2&#39;, &#39;point 3&#39;)
            # or
            c.connections = (p1, p2,p3)
            # or
            c.connections = [p1, &#39;point 2&#39;, p3]  # all the same

        Notes:
            1. Circles can not be used as endpoins. If one of the endpoints is a Circle then the Point that that circle
            is located on is used instead.
            2. Points should not be repeated directly.

        The following will fail:
        c.connections = (&#39;point 1&#39;, &#39;point 3&#39;, &#39;circle 1&#39;)

        because the last point is a circle. So circle 1 will be replaced with the point that the circle is on: point 3.

        so this becomes
        (&#39;point 1&#39;,&#39;point 3&#39;,&#39;point 3&#39;)

        this is invalid because point 3 is repeated.

        &#34;&#34;&#34;
        return tuple(self._pois)

    @connections.setter
    @node_setter_manageable
    @node_setter_observable
    def connections(self, value):

        if len(value) &lt; 2:
            raise ValueError(&#34;At least two connections required&#34;)

        nodes = []
        for p in value:
            n = self._scene._node_from_node_or_str(p)

            if not (isinstance(n, Point) or isinstance(n, Circle)):
                raise ValueError(
                    f&#34;Only Sheaves and Pois can be used as connection, but {n.name} is a {type(n)}&#34;
                )
            nodes.append(n)

        # check for repeated nodes
        n = len(nodes)
        for i in range(n - 1):
            node1 = nodes[i]
            node2 = nodes[i + 1]

            # # if first or last node is a sheave, the this will be replaced by the poi of the sheave
            # if i == 0 and isinstance(node1, Circle):
            #     node1 = node1.parent
            # if i == n - 2 and isinstance(node2, Circle):
            #     node2 = node2.parent

            if node1 == node2:
                raise ValueError(
                    f&#34;It is not allowed to have the same node repeated - you have {node1.name} and {node2.name}&#34;
                )

        self._pois.clear()
        self._pois.extend(nodes)
        self._update_pois()

    def get_points_for_visual(self):
        &#34;&#34;&#34;A list of 3D locations which can be used for visualization&#34;&#34;&#34;
        return self._vfNode.global_points

    def _add_connection_to_core(self, connection):
        if isinstance(connection, Point):
            self._vfNode.add_connection_poi(connection._vfNode)
        if isinstance(connection, Circle):
            self._vfNode.add_connection_sheave(connection._vfNode)

    def _update_pois(self):
        self._vfNode.clear_connections()
        for point in self._pois:
            self._add_connection_to_core(point)

    def _give_poi_names(self):
        &#34;&#34;&#34;Returns a list with the names of all the pois&#34;&#34;&#34;
        r = list()
        for p in self._pois:
            r.append(p.name)
        return r

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        poi_names = self._give_poi_names()
        n_sheaves = len(poi_names) - 2

        code += &#34;\ns.new_cable(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            endA=&#39;{}&#39;,&#34;.format(poi_names[0])
        code += &#34;\n            endB=&#39;{}&#39;,&#34;.format(poi_names[-1])
        code += &#34;\n            length={},&#34;.format(self.length)

        if self.diameter != 0:
            code += &#34;\n            diameter={},&#34;.format(self.diameter)

        if len(poi_names) &lt;= 2:
            code += &#34;\n            EA={})&#34;.format(self.EA)
        else:
            code += &#34;\n            EA={},&#34;.format(self.EA)

            if n_sheaves == 1:
                code += &#34;\n            sheaves = [&#39;{}&#39;])&#34;.format(poi_names[1])
            else:
                code += &#34;\n            sheaves = [&#39;{}&#39;,&#34;.format(poi_names[1])
                for i in range(n_sheaves - 2):
                    code += &#34;\n                       &#39;{}&#39;,&#34;.format(poi_names[2 + i])
                code += &#34;\n                       &#39;{}&#39;]),&#34;.format(poi_names[-2])

        return code


class Force(NodeWithParent):
    &#34;&#34;&#34;A Force models a force and moment on a poi.

    Both are expressed in the global axis system.

    &#34;&#34;&#34;

    @property
    def force(self):
        &#34;&#34;&#34;The x,y and z components of the force [kN,kN,kN] (global axis)

        Example s[&#39;wind&#39;].force = (12,34,56)
        &#34;&#34;&#34;
        return self._vfNode.force

    @force.setter
    @node_setter_manageable
    @node_setter_observable
    def force(self, val):

        assert3f(val)
        self._vfNode.force = val

    @property
    def fx(self):
        &#34;&#34;&#34;The global x-component of the force [kN] (global axis)&#34;&#34;&#34;
        return self.force[0]

    @fx.setter
    @node_setter_manageable
    @node_setter_observable
    def fx(self, var):

        a = self.force
        self.force = (var, a[1], a[2])

    @property
    def fy(self):
        &#34;&#34;&#34;The global y-component of the force [kN]  (global axis)&#34;&#34;&#34;
        return self.force[1]

    @fy.setter
    @node_setter_manageable
    @node_setter_observable
    def fy(self, var):

        a = self.force
        self.force = (a[0], var, a[2])

    @property
    def fz(self):
        &#34;&#34;&#34;The global z-component of the force [kN]  (global axis)&#34;&#34;&#34;

        return self.force[2]

    @fz.setter
    @node_setter_manageable
    @node_setter_observable
    def fz(self, var):

        a = self.force
        self.force = (a[0], a[1], var)

    @property
    def moment(self):
        &#34;&#34;&#34;The x,y and z components of the moment (kNm,kNm,kNm) in the global axis system.

        Example s[&#39;wind&#39;].moment = (12,34,56)
        &#34;&#34;&#34;
        return self._vfNode.moment

    @moment.setter
    @node_setter_manageable
    @node_setter_observable
    def moment(self, val):

        assert3f(val)
        self._vfNode.moment = val

    @property
    def mx(self):
        &#34;&#34;&#34;The global x-component of the moment [kNm]  (global axis)&#34;&#34;&#34;
        return self.moment[0]

    @mx.setter
    @node_setter_manageable
    @node_setter_observable
    def mx(self, var):

        a = self.moment
        self.moment = (var, a[1], a[2])

    @property
    def my(self):
        &#34;&#34;&#34;The global y-component of the moment [kNm]  (global axis)&#34;&#34;&#34;
        return self.moment[1]

    @my.setter
    @node_setter_manageable
    @node_setter_observable
    def my(self, var):

        a = self.moment
        self.moment = (a[0], var, a[2])

    @property
    def mz(self):
        &#34;&#34;&#34;The global z-component of the moment [kNm]  (global axis)&#34;&#34;&#34;
        return self.moment[2]

    @mz.setter
    @node_setter_manageable
    @node_setter_observable
    def mz(self, var):

        a = self.moment
        self.moment = (a[0], a[1], var)

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        # new_force(self, name, parent=None, force=None, moment=None):

        code += &#34;\ns.new_force(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            parent=&#39;{}&#39;,&#34;.format(self.parent_for_export.name)
        code += &#34;\n            force=({}, {}, {}),&#34;.format(*self.force)
        code += &#34;\n            moment=({}, {}, {}) )&#34;.format(*self.moment)
        return code


class ContactMesh(NodeWithParent):
    &#34;&#34;&#34;A ContactMesh is a tri-mesh with an axis parent&#34;&#34;&#34;

    def __init__(self, scene, vfContactMesh):
        super().__init__(scene, vfContactMesh)
        self._None_parent_acceptable = True
        self._trimesh = TriMeshSource(
            self._scene, self._vfNode.trimesh
        )  # the tri-mesh is wrapped in a custom object

    @property
    def trimesh(self):
        &#34;&#34;&#34;The TriMeshSource object which can be used to change the mesh

        Example:
            s[&#39;Contactmesh&#39;].trimesh.load_file(&#39;cube.obj&#39;, scale = (1.0,1.0,1.0), rotation = (0.0,0.0,0.0), offset = (0.0,0.0,0.0))
        &#34;&#34;&#34;
        return self._trimesh

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\nmesh = s.new_contactmesh(name=&#39;{}&#39;&#34;.format(self.name)
        if self.parent_for_export:
            code += &#34;, parent=&#39;{}&#39;)&#34;.format(self.parent_for_export.name)
        else:
            code += &#34;)&#34;
        code += &#34;\nmesh.trimesh.load_file(r&#39;{}&#39;, scale = ({},{},{}), rotation = ({},{},{}), offset = ({},{},{}))&#34;.format(
            self.trimesh._path,
            *self.trimesh._scale,
            *self.trimesh._rotation,
            *self.trimesh._offset,
        )

        return code


class ContactBall(NodeWithParent):
    &#34;&#34;&#34;A ContactBall is a linear elastic ball which can contact with ContactMeshes.

    It is modelled as a sphere around a Poi. Radius and stiffness can be controlled using radius and k.

    The force is applied on the Poi and it not registered separately.
    &#34;&#34;&#34;

    def __init__(self, scene, node):
        super().__init__(scene, node)
        self._meshes = list()

    @property
    def can_contact(self) -&gt; bool:
        &#34;&#34;&#34;True if the ball ball is perpendicular to at least one of the faces of one of the meshes. So when contact is possible. To check if there is contact use &#34;force&#34;
        See Also: Force
        &#34;&#34;&#34;
        return self._vfNode.has_contact

    @property
    def contact_force(self) -&gt; tuple:
        &#34;&#34;&#34;Returns the force on the ball [kN, kN, kN] (global axis)

        The force is applied at the center of the ball

        See Also: contact_force_magnitude
        &#34;&#34;&#34;
        return self._vfNode.force

    @property
    def contact_force_magnitude(self) -&gt; float:
        &#34;&#34;&#34;Returns the absolute force on the ball, if any [kN]

        The force is applied on the center of the ball

        See Also: contact_force
        &#34;&#34;&#34;
        return np.linalg.norm(self._vfNode.force)

    @property
    def compression(self) -&gt; float:
        &#34;&#34;&#34;Returns the absolute compression of the ball, if any [m]&#34;&#34;&#34;
        return self._vfNode.force

    @property
    def contactpoint(self):
        &#34;&#34;&#34;The nearest point on the nearest mesh. Only defined&#34;&#34;&#34;
        return self._vfNode.contact_point

    def update(self):
        &#34;&#34;&#34;Updates the contact-points and applies forces on mesh and point&#34;&#34;&#34;
        self._vfNode.update()

    @property
    def meshes(self) -&gt; tuple:
        &#34;&#34;&#34;List of contact-mesh nodes.
        When getting this will yield a list of node references.
        When setting node references and node-names may be used.

        eg: ball.meshes = [mesh1, &#39;mesh2&#39;]
        &#34;&#34;&#34;
        return tuple(self._meshes)

    @meshes.setter
    @node_setter_manageable
    @node_setter_observable
    def meshes(self, value):

        meshes = []

        for m in value:
            cm = self._scene._node_from_node_or_str(m)

            if not isinstance(cm, ContactMesh):
                raise ValueError(
                    f&#34;Only ContactMesh nodes can be used as mesh, but {cm.name} is a {type(cm)}&#34;
                )
            if cm in meshes:
                raise ValueError(f&#34;Can not add {cm.name} twice&#34;)

            meshes.append(cm)

        # copy to meshes
        self._meshes.clear()
        self._vfNode.clear_contactmeshes()
        for mesh in meshes:
            self._meshes.append(mesh)
            self._vfNode.add_contactmesh(mesh._vfNode)

    @property
    def meshes_names(self) -&gt; list:
        &#34;&#34;&#34;List with the names of the meshes&#34;&#34;&#34;
        return [m.name for m in self._meshes]

    @property
    def radius(self):
        &#34;&#34;&#34;Radius of the contact-ball [m]&#34;&#34;&#34;
        return self._vfNode.radius

    @radius.setter
    @node_setter_manageable
    @node_setter_observable
    def radius(self, value):

        assert1f_positive_or_zero(value, &#34;radius&#34;)
        self._vfNode.radius = value
        pass

    @property
    def k(self):
        &#34;&#34;&#34;Compression stiffness of the ball in force per meter of compression [kN/m]&#34;&#34;&#34;
        return self._vfNode.k

    @k.setter
    @node_setter_manageable
    @node_setter_observable
    def k(self, value):

        assert1f_positive_or_zero(value, &#34;k&#34;)
        self._vfNode.k = value
        pass

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        code += &#34;\ns.new_contactball(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n                  parent=&#39;{}&#39;,&#34;.format(self.parent_for_export.name)
        code += &#34;\n                  radius={},&#34;.format(self.radius)
        code += &#34;\n                  k={},&#34;.format(self.k)
        code += &#34;\n                  meshes = [ &#34;

        for m in self._meshes:
            code += &#39;&#34;&#39; + m.name + &#39;&#34;,&#39;
        code = code[:-1] + &#34;])&#34;

        return code

    # =======================================================================


class SPMT(NodeWithParent):
    &#34;&#34;&#34;An SPMT is a Self-propelled modular transporter

    These are platform vehicles

    ============  =======
    0 0 0 0 0 0   0 0 0 0

    A number of axles share a common suspension system.

    The SPMT node models such a system of axles.

    The SPMT is attached to an axis system.
    The upper locations of the axles are given as an array of 3d vectors.

    Rays are extended from these points in local -Z direction (down) until they hit a contact-shape.

    If no contact shape is found (or not within the maximum distance per axles) then the maximum defined extension for that axle is used.

    A shared pressure is obtained from the combination of all individual extensions.

    Finally an equal force is applied on all the axle connection points. This force acts in local Z direction.

    &#34;&#34;&#34;

    def __init__(self, scene, node):
        super().__init__(scene, node)
        self._meshes = list()

    # read-only

    @property
    def axle_force(self) -&gt; tuple:
        &#34;&#34;&#34;Returns the force on each of the axles [kN, kN, kN] (global axis)&#34;&#34;&#34;
        return self._vfNode.force

    @property
    def compression(self) -&gt; float:
        &#34;&#34;&#34;Returns the total compression of all the axles together [m]&#34;&#34;&#34;
        return self._vfNode.compression

    def get_actual_global_points(self):
        &#34;&#34;&#34;Returns a list of points: axle1, bottom wheels 1, axle2, bottom wheels 2, etc&#34;&#34;&#34;
        gp = self._vfNode.actual_global_points

        pts = []
        n2 = int(len(gp) / 2)
        for i in range(n2):
            pts.append(gp[2 * i + 1])
            pts.append(gp[2 * i])

            if i &lt; n2 - 1:
                pts.append(gp[2 * i + 2])

        return pts

    # controllable

    # name is derived
    # parent is derived

    @property
    def k(self):
        &#34;&#34;&#34;Compression stiffness of the ball in force per meter of compression [kN/m]&#34;&#34;&#34;
        return self._vfNode.k

    @k.setter
    @node_setter_manageable
    @node_setter_observable
    def k(self, value):

        assert1f_positive_or_zero(value, &#34;k&#34;)
        self._vfNode.k = value
        pass

    @property
    def nominal_length(self):
        &#34;&#34;&#34;Average Axle extension (defined point to bottom of wheel) for zero force [m]&#34;&#34;&#34;
        return self._vfNode.nominal_length

    @nominal_length.setter
    @node_setter_manageable
    @node_setter_observable
    def nominal_length(self, value):

        assert1f_positive_or_zero(value, &#34;nominal_length&#34;)
        self._vfNode.nominal_length = value
        pass

    @property
    def max_length(self):
        &#34;&#34;&#34;Maximum axle extension per axle (defined point to bottom of wheel) [m]&#34;&#34;&#34;
        return self._vfNode.max_length

    @max_length.setter
    @node_setter_manageable
    @node_setter_observable
    def max_length(self, value):

        assert1f_positive_or_zero(value, &#34;max_length&#34;)
        self._vfNode.max_length = value
        pass

    # === control meshes ====

    @property
    def meshes(self) -&gt; tuple:
        &#34;&#34;&#34;List of contact-mesh nodes.
        When getting this will yield a list of node references.
        When setting node references and node-names may be used.

        eg: ball.meshes = [mesh1, &#39;mesh2&#39;]
        &#34;&#34;&#34;
        return tuple(self._meshes)

    @meshes.setter
    @node_setter_manageable
    @node_setter_observable
    def meshes(self, value):

        meshes = []

        for m in value:
            cm = self._scene._node_from_node_or_str(m)

            if not isinstance(cm, ContactMesh):
                raise ValueError(
                    f&#34;Only ContactMesh nodes can be used as mesh, but {cm.name} is a {type(cm)}&#34;
                )
            if cm in meshes:
                raise ValueError(f&#34;Can not add {cm.name} twice&#34;)

            meshes.append(cm)

        # copy to meshes
        self._meshes.clear()
        self._vfNode.clear_contact_meshes()
        for mesh in meshes:
            self._meshes.append(mesh)
            self._vfNode.add_contact_mesh(mesh._vfNode)

    @property
    def meshes_names(self) -&gt; list:
        &#34;&#34;&#34;List with the names of the meshes&#34;&#34;&#34;
        return [m.name for m in self._meshes]

    # === control axles ====

    def make_grid(self, nx=3, ny=1, dx=1.4, dy=1.45):
        offx = nx * dx / 2
        offy = ny * dy / 2
        self._vfNode.clear_axles()

        for ix in range(nx):
            for iy in range(ny):
                self._vfNode.add_axle(ix * dx - offx, iy * dy - offy, 0)

    @property
    def axles(self):
        &#34;&#34;&#34;Axles is a list axle positions. Each entry is a (x,y,z) entry which determines the location of the axle on
        SPMT. This is relative to the parent of the SPMT.

        Example:
            [(-10,0,0),(-5,0,0),(0,0,0)] for three axles
        &#34;&#34;&#34;
        return self._vfNode.get_axles()

    @axles.setter
    @node_setter_manageable
    @node_setter_observable
    def axles(self, value):
        self._vfNode.clear_axles()
        for v in value:
            assert3f(v, &#34;Each entry should contain three floating point numbers&#34;)
            self._vfNode.add_axle(*v)

    # actions

    def update(self):
        &#34;&#34;&#34;Updates the contact-points and applies forces on mesh and point&#34;&#34;&#34;
        self._vfNode.update()

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        code += &#34;\ns.new_spmt(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n                  parent=&#39;{}&#39;,&#34;.format(self.parent_for_export.name)
        code += &#34;\n                  maximal_length={},&#34;.format(self.max_length)
        code += &#34;\n                  nominal_length={},&#34;.format(self.nominal_length)
        code += &#34;\n                  k={},&#34;.format(self.k)
        code += &#34;\n                  meshes = [ &#34;

        for m in self._meshes:
            code += &#39;&#34;&#39; + m.name + &#39;&#34;,&#39;
        code = code[:-1] + &#34;],&#34;

        code += &#34;\n                  axles = [ &#34;

        for p in self.axles:
            code += f&#34;({p[0]}, {p[1]}, {p[2]}),&#34;

        code = code[:-1] + &#34;])&#34;

        return code


class Circle(NodeWithParent):
    &#34;&#34;&#34;A Circle models a circle shape based on a diameter and an axis direction&#34;&#34;&#34;

    @property
    def axis(self) -&gt; tuple:
        &#34;&#34;&#34;Direction of the sheave axis (x,y,z) in parent axis system.

        Note:
            The direction of the axis is also used to determine the positive direction over the circumference of the
            circle. This is then used when cables run over the circle or the circle is used for geometric contacts. So
            if a cable runs over the circle in the wrong direction then a solution is to change the axis direction to
            its opposite:  circle.axis =- circle.axis. (another solution in that case is to define the connections of
            the cable in the reverse order)
        &#34;&#34;&#34;
        return self._vfNode.axis_direction

    @axis.setter
    @node_setter_manageable
    @node_setter_observable
    def axis(self, val):

        assert3f(val)
        if np.linalg.norm(val) == 0:
            raise ValueError(&#34;Axis can not be 0,0,0&#34;)
        self._vfNode.axis_direction = val

    @property
    def radius(self):
        &#34;&#34;&#34;Radius of the circle [m]&#34;&#34;&#34;
        return self._vfNode.radius

    @radius.setter
    @node_setter_manageable
    @node_setter_observable
    def radius(self, val):

        assert1f(val)
        self._vfNode.radius = val

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\ns.new_circle(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            parent=&#39;{}&#39;,&#34;.format(self.parent_for_export.name)
        code += &#34;\n            axis=({}, {}, {}),&#34;.format(*self.axis)
        code += &#34;\n            radius={} )&#34;.format(self.radius)
        return code

    @property
    def global_position(self):
        &#34;&#34;&#34;Returns the global position of the center of the sheave.

        Note: this is the same as the global position of the parent point.
        &#34;&#34;&#34;
        return self.parent.global_position


class HydSpring(NodeWithParent):
    &#34;&#34;&#34;A HydSpring models a linearized hydrostatic spring.

    The cob (center of buoyancy) is defined in the parent axis system.
    All other properties are defined relative to the cob.

    &#34;&#34;&#34;

    @property
    def cob(self):
        &#34;&#34;&#34;Center of buoyancy in parent axis system (m,m,m)&#34;&#34;&#34;
        return self._vfNode.position

    @cob.setter
    @node_setter_manageable
    @node_setter_observable
    def cob(self, val):

        assert3f(val)
        self._vfNode.position = val

    @property
    def BMT(self):
        &#34;&#34;&#34;Vertical distance between cob and metacenter for roll [m]&#34;&#34;&#34;
        return self._vfNode.BMT

    @BMT.setter
    @node_setter_manageable
    @node_setter_observable
    def BMT(self, val):

        self._vfNode.BMT = val

    @property
    def BML(self):
        &#34;&#34;&#34;Vertical distance between cob and metacenter for pitch [m]&#34;&#34;&#34;
        return self._vfNode.BML

    @BML.setter
    @node_setter_manageable
    @node_setter_observable
    def BML(self, val):

        self._vfNode.BML = val

    @property
    def COFX(self):
        &#34;&#34;&#34;Horizontal x-position Center of Floatation (center of waterplane area), relative to cob [m]&#34;&#34;&#34;
        return self._vfNode.COFX

    @COFX.setter
    @node_setter_manageable
    @node_setter_observable
    def COFX(self, val):

        self._vfNode.COFX = val

    @property
    def COFY(self):
        &#34;&#34;&#34;Horizontal y-position Center of Floatation (center of waterplane area), relative to cob [m]&#34;&#34;&#34;
        return self._vfNode.COFY

    @COFY.setter
    @node_setter_manageable
    @node_setter_observable
    def COFY(self, val):

        self._vfNode.COFY = val

    @property
    def kHeave(self):
        &#34;&#34;&#34;Heave stiffness [kN/m]&#34;&#34;&#34;
        return self._vfNode.kHeave

    @kHeave.setter
    @node_setter_manageable
    @node_setter_observable
    def kHeave(self, val):

        self._vfNode.kHeave = val

    @property
    def waterline(self):
        &#34;&#34;&#34;Waterline-elevation relative to cob for un-stretched heave-spring. Positive if cob is below the waterline (which is where is normally is) [m]&#34;&#34;&#34;
        return self._vfNode.waterline

    @waterline.setter
    @node_setter_manageable
    @node_setter_observable
    def waterline(self, val):

        self._vfNode.waterline = val

    @property
    def displacement_kN(self):
        &#34;&#34;&#34;Displacement when waterline is at waterline-elevation [kN]&#34;&#34;&#34;
        return self._vfNode.displacement_kN

    @displacement_kN.setter
    @node_setter_manageable
    @node_setter_observable
    def displacement_kN(self, val):

        self._vfNode.displacement_kN = val

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        # new_force(self, name, parent=None, force=None, moment=None):

        code += &#34;\ns.new_hydspring(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            parent=&#39;{}&#39;,&#34;.format(self.parent_for_export.name)
        code += &#34;\n            cob=({}, {}, {}),&#34;.format(*self.cob)
        code += &#34;\n            BMT={},&#34;.format(self.BMT)
        code += &#34;\n            BML={},&#34;.format(self.BML)
        code += &#34;\n            COFX={},&#34;.format(self.COFX)
        code += &#34;\n            COFY={},&#34;.format(self.COFY)
        code += &#34;\n            kHeave={},&#34;.format(self.kHeave)
        code += &#34;\n            waterline={},&#34;.format(self.waterline)
        code += &#34;\n            displacement_kN={} )&#34;.format(self.displacement_kN)

        return code


class LC6d(CoreConnectedNode):
    &#34;&#34;&#34;A LC6d models a Linear Connector with 6 dofs.

    It connects two Axis elements with six linear springs.

    The first axis system is called &#34;main&#34;, the second is called &#34;secondary&#34;. The difference is that
    the &#34;main&#34; axis system is used for the definition of the stiffness values.

    The translational-springs are easy. The rotational springs may not be as intuitive. They are defined as:

      - rotation_x = arc-tan ( uy[0] / uy[1] )
      - rotation_y = arc-tan ( -ux[0] / ux[2] )
      - rotation_z = arc-tan ( ux[0] / ux [1] )

    which works fine for small rotations and rotations about only a single axis.

    Tip:
    It is better to use use the &#34;fixed&#34; property of axis systems to create joints.

    &#34;&#34;&#34;

    def __init__(self, scene, node):
        super().__init__(scene, node)
        self._main = None
        self._secondary = None

    def depends_on(self):
        return [self._main, self._secondary]

    @property
    def stiffness(self):
        &#34;&#34;&#34;Stiffness of the connector: kx, ky, kz, krx, kry, krz in [kN/m and kNm/rad] (axis system of the main axis)&#34;&#34;&#34;
        return self._vfNode.stiffness

    @stiffness.setter
    @node_setter_manageable
    @node_setter_observable
    def stiffness(self, val):

        self._vfNode.stiffness = val

    @property
    def main(self):
        &#34;&#34;&#34;Main axis system. This axis system dictates the axis system that the stiffness is expressed in&#34;&#34;&#34;
        return self._main

    @main.setter
    @node_setter_manageable
    @node_setter_observable
    def main(self, val):

        val = self._scene._node_from_node_or_str(val)
        if not isinstance(val, Axis):
            raise TypeError(&#34;Provided nodeA should be a Axis&#34;)

        self._main = val
        self._vfNode.master = val._vfNode

    @property
    def secondary(self):
        &#34;&#34;&#34;Secondary (connected) axis system&#34;&#34;&#34;
        return self._secondary

    @secondary.setter
    @node_setter_manageable
    @node_setter_observable
    def secondary(self, val):

        val = self._scene._node_from_node_or_str(val)
        if not isinstance(val, Axis):
            raise TypeError(&#34;Provided nodeA should be a Axis&#34;)

        self._secondary = val
        self._vfNode.slave = val._vfNode

    @property
    def fgx(self):
        &#34;&#34;&#34;Force on main in global coordinate frame [kN]&#34;&#34;&#34;
        return self._vfNode.global_force[0]

    @property
    def fgy(self):
        &#34;&#34;&#34;Force on main in global coordinate frame [kN]&#34;&#34;&#34;
        return self._vfNode.global_force[1]

    @property
    def fgz(self):
        &#34;&#34;&#34;Force on main in global coordinate frame [kN]&#34;&#34;&#34;
        return self._vfNode.global_force[2]

    @property
    def force_global(self):
        &#34;&#34;&#34;Force on main in global coordinate frame [kN]&#34;&#34;&#34;
        return self._vfNode.global_force

    @property
    def mgx(self):
        &#34;&#34;&#34;Moment on main in global coordinate frame [kNm]&#34;&#34;&#34;
        return self._vfNode.global_moment[0]

    @property
    def mgy(self):
        &#34;&#34;&#34;Moment on main in global coordinate frame [kNm]&#34;&#34;&#34;
        return self._vfNode.global_moment[1]

    @property
    def mgz(self):
        &#34;&#34;&#34;Moment on main in global coordinate frame [kNm]&#34;&#34;&#34;
        return self._vfNode.global_moment[2]

    @property
    def moment_global(self):
        &#34;&#34;&#34;Moment on main in global coordinate frame [kNm]&#34;&#34;&#34;
        return self._vfNode.global_moment

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        code += &#34;\ns.new_linear_connector_6d(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            main=&#39;{}&#39;,&#34;.format(self.main.name)
        code += &#34;\n            secondary=&#39;{}&#39;,&#34;.format(self.secondary.name)
        code += &#34;\n            stiffness=({}, {}, {}, &#34;.format(*self.stiffness[:3])
        code += &#34;\n                       {}, {}, {}) )&#34;.format(*self.stiffness[3:])

        return code


class Connector2d(CoreConnectedNode):
    &#34;&#34;&#34;A Connector2d linear connector with acts both on linear displacement and angular displacement.

    * the linear stiffness is defined by k_linear and is defined over the actual shortest direction between nodeA and nodeB.
    * the angular stiffness is defined by k_angular and is defined over the actual smallest angle between the two systems.
    &#34;&#34;&#34;

    def __init__(self, scene, node):
        super().__init__(scene, node)
        self._nodeA = None
        self._nodeB = None

    def depends_on(self):
        return [self._nodeA, self._nodeB]

    @property
    def angle(self):
        &#34;&#34;&#34;Actual angle between nodeA and nodeB [deg] (read-only)&#34;&#34;&#34;
        return np.rad2deg(self._vfNode.angle)

    @property
    def force(self):
        &#34;&#34;&#34;Actual force between nodeA and nodeB [kN] (read-only)&#34;&#34;&#34;
        return self._vfNode.force

    @property
    def moment(self):
        &#34;&#34;&#34;Actual moment between nodeA and nodeB [kNm] (read-only)&#34;&#34;&#34;
        return self._vfNode.moment

    @property
    def axis(self):
        &#34;&#34;&#34;Actual rotation axis between nodeA and nodeB (read-only)&#34;&#34;&#34;
        return self._vfNode.axis

    @property
    def ax(self):
        &#34;&#34;&#34;X component of actual rotation axis between nodeA and nodeB (read-only)&#34;&#34;&#34;
        return self._vfNode.axis[0]

    @property
    def ay(self):
        &#34;&#34;&#34;Y component of actual rotation axis between nodeA and nodeB (read-only)&#34;&#34;&#34;
        return self._vfNode.axis[1]

    @property
    def az(self):
        &#34;&#34;&#34;Z component of actual rotation axis between nodeA and nodeB (read-only)&#34;&#34;&#34;
        return self._vfNode.axis[2]

    @property
    def k_linear(self):
        &#34;&#34;&#34;Linear stiffness [kN/m]&#34;&#34;&#34;
        return self._vfNode.k_linear

    @k_linear.setter
    @node_setter_manageable
    @node_setter_observable
    def k_linear(self, value):

        self._vfNode.k_linear = value

    @property
    def k_angular(self):
        &#34;&#34;&#34;Angular stiffness [kNm/rad]&#34;&#34;&#34;
        return self._vfNode.k_angular

    @k_angular.setter
    @node_setter_manageable
    @node_setter_observable
    def k_angular(self, value):

        self._vfNode.k_angular = value

    @property
    def nodeA(self) -&gt; Axis:
        &#34;&#34;&#34;Connected axis system A&#34;&#34;&#34;
        return self._nodeA

    @nodeA.setter
    @node_setter_manageable
    @node_setter_observable
    def nodeA(self, val):

        val = self._scene._node_from_node_or_str(val)
        if not isinstance(val, Axis):
            raise TypeError(&#34;Provided nodeA should be a Axis&#34;)

        self._nodeA = val
        self._vfNode.master = val._vfNode

    @property
    def nodeB(self) -&gt; Axis:
        &#34;&#34;&#34;Connected axis system B&#34;&#34;&#34;
        return self._nodeB

    @nodeB.setter
    @node_setter_manageable
    @node_setter_observable
    def nodeB(self, val):

        val = self._scene._node_from_node_or_str(val)
        if not isinstance(val, Axis):
            raise TypeError(&#34;Provided nodeA should be a Axis&#34;)

        self._nodeB = val
        self._vfNode.slave = val._vfNode

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        code += &#34;\ns.new_connector2d(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            nodeA=&#39;{}&#39;,&#34;.format(self.nodeA.name)
        code += &#34;\n            nodeB=&#39;{}&#39;,&#34;.format(self.nodeB.name)
        code += &#34;\n            k_linear ={},&#34;.format(self.k_linear)
        code += &#34;\n            k_angular ={})&#34;.format(self.k_angular)

        return code


class Beam(CoreConnectedNode):
    &#34;&#34;&#34;A LinearBeam models a FEM-like linear beam element.

    A LinearBeam node connects two Axis elements

    By definition the beam runs in the X-direction of the nodeA axis system. So it may be needed to create a
    dedicated Axis element for the beam to control the orientation.

    The beam is defined using the following properties:

    *  EIy  - bending stiffness about y-axis
    *  EIz  - bending stiffness about z-axis
    *  GIp  - torsional stiffness about x-axis
    *  EA   - axis stiffness in x-direction
    *  L    - the un-stretched length of the beam
    *  mass - mass of the beam in [mT]

    The beam element is in rest if the nodeB axis system

    1. has the same global orientation as the nodeA system
    2. is at global position equal to the global position of local point (L,0,0) of the nodeA axis. (aka: the end of the beam)

    The scene.new_linearbeam automatically creates a dedicated axis system for each end of the beam. The orientation of this axis-system
    is determined as follows:

    First the direction from nodeA to nodeB is determined: D
    The axis of rotation is the cross-product of the unit x-axis and D    AXIS = ux x D
    The angle of rotation is the angle between the nodeA x-axis and D
    The rotation about the rotated X-axis is undefined.

    &#34;&#34;&#34;

    def __init__(self, scene, node):
        super().__init__(scene, node)
        self._nodeA = None
        self._nodeB = None

    def depends_on(self):
        return [self._nodeA, self._nodeB]

    @property
    def n_segments(self):
        return self._vfNode.nSegments

    @n_segments.setter
    @node_setter_manageable
    @node_setter_observable
    def n_segments(self, value):
        if value &lt; 1:
            raise ValueError(&#34;Number of segments in beam should be 1 or more&#34;)
        self._vfNode.nSegments = int(value)

    @property
    def EIy(self):
        &#34;&#34;&#34;E * Iyy : bending stiffness in the XZ plane [kN m2]

        E is the modulus of elasticity; for steel 190-210 GPa (10^6 kN/m2)
        Iyy is the cross section moment of inertia [m4]
        &#34;&#34;&#34;
        return self._vfNode.EIy

    @EIy.setter
    @node_setter_manageable
    @node_setter_observable
    def EIy(self, value):

        self._vfNode.EIy = value

    @property
    def EIz(self):
        &#34;&#34;&#34;E * Izz : bending stiffness in the XY plane [kN m2]

        E is the modulus of elasticity; for steel 190-210 GPa (10^6 kN/m2)
        Iyy is the cross section moment of inertia [m4]
        &#34;&#34;&#34;
        return self._vfNode.EIz

    @EIz.setter
    @node_setter_manageable
    @node_setter_observable
    def EIz(self, value):

        self._vfNode.EIz = value

    @property
    def GIp(self):
        &#34;&#34;&#34;G * Ipp : torsional stiffness about the X (length) axis [kN m2]

        G is the shear-modulus of elasticity; for steel 75-80 GPa (10^6 kN/m2)
        Ip is the cross section polar moment of inertia [m4]
        &#34;&#34;&#34;
        return self._vfNode.GIp

    @GIp.setter
    @node_setter_manageable
    @node_setter_observable
    def GIp(self, value):

        self._vfNode.GIp = value

    @property
    def EA(self):
        &#34;&#34;&#34;E * A : stiffness in the length direction [kN]

        E is the modulus of elasticity; for steel 190-210 GPa (10^6 kN/m2)
        A is the cross-section area in [m2]
        &#34;&#34;&#34;
        return self._vfNode.EA

    @EA.setter
    @node_setter_manageable
    @node_setter_observable
    def EA(self, value):

        self._vfNode.EA = value

    @property
    def tension_only(self):
        &#34;&#34;&#34;axial stiffness (EA) only applicable to tension [True/False]&#34;&#34;&#34;
        return self._vfNode.tensionOnly

    @tension_only.setter
    @node_setter_manageable
    @node_setter_observable
    def tension_only(self, value):
        assert isinstance(value, bool), ValueError(
            &#34;Value for tension_only shall be True or False&#34;
        )
        self._vfNode.tensionOnly = value

    @property
    def mass(self):
        &#34;&#34;&#34;Mass of the beam in [mT]&#34;&#34;&#34;
        return self._vfNode.Mass

    @mass.setter
    @node_setter_manageable
    @node_setter_observable
    def mass(self, value):

        assert1f(value, &#34;Mass shall be a number&#34;)
        self._vfNode.Mass = value
        pass

    @property
    def L(self):
        &#34;&#34;&#34;Length of the beam in unloaded condition [m]&#34;&#34;&#34;
        return self._vfNode.L

    @L.setter
    @node_setter_manageable
    @node_setter_observable
    def L(self, value):

        self._vfNode.L = value

    @property
    def nodeA(self):
        &#34;&#34;&#34;The axis system that the A-end of the beam is connected to. The beam leaves this axis system along the X-axis&#34;&#34;&#34;
        return self._nodeA

    @nodeA.setter
    @node_setter_manageable
    @node_setter_observable
    def nodeA(self, val):

        val = self._scene._node_from_node_or_str(val)

        if not isinstance(val, Axis):
            raise TypeError(&#34;Provided nodeA should be a Axis&#34;)

        self._nodeA = val
        self._vfNode.master = val._vfNode

    @property
    def nodeB(self):
        &#34;&#34;&#34;The axis system that the B-end of the beam is connected to. The beam arrives at this axis system along the X-axis&#34;&#34;&#34;
        return self._nodeB

    @nodeB.setter
    @node_setter_manageable
    @node_setter_observable
    def nodeB(self, val):

        val = self._scene._node_from_node_or_str(val)
        if not isinstance(val, Axis):
            raise TypeError(&#34;Provided nodeA should be a Axis&#34;)

        self._nodeB = val
        self._vfNode.slave = val._vfNode

    # read-only
    @property
    def moment_A(self):
        &#34;&#34;&#34;Moment on beam at node A (kNm, kNm, kNm) , axis system of node A&#34;&#34;&#34;
        return self._vfNode.moment_on_master

    @property
    def moment_B(self):
        &#34;&#34;&#34;Moment on beam at node B (kNm, kNm, kNm) , axis system of node B&#34;&#34;&#34;
        return self._vfNode.moment_on_slave

    @property
    def tension(self):
        &#34;&#34;&#34;Tension in the beam [kN], negative for compression

        tension is calculated at the midpoints of the beam segments.
        &#34;&#34;&#34;
        return self._vfNode.tension

    @property
    def torsion(self):
        &#34;&#34;&#34;Torsion moment [kNm]. Positive if end B has a positive rotation about the x-axis of end A

        torsion is calculated at the midpoints of the beam segments.
        &#34;&#34;&#34;
        return self._vfNode.torsion

    @property
    def X_nodes(self):
        &#34;&#34;&#34;Returns the x-positions of the end nodes and internal nodes along the length of the beam [m]&#34;&#34;&#34;
        return self._vfNode.x

    @property
    def X_midpoints(self):
        &#34;&#34;&#34;X-positions of the beam centers measured along the length of the beam [m]&#34;&#34;&#34;
        return tuple(
            0.5 * (np.array(self._vfNode.x[:-1]) + np.array(self._vfNode.x[1:]))
        )

    @property
    def global_positions(self):
        &#34;&#34;&#34;Global-positions of the end nodes and internal nodes [m,m,m]&#34;&#34;&#34;
        return np.array(self._vfNode.global_position, dtype=float)

    @property
    def global_orientations(self):
        &#34;&#34;&#34;Global-orientations of the end nodes and internal nodes [deg,deg,deg]&#34;&#34;&#34;
        return np.rad2deg(self._vfNode.global_orientation)

    @property
    def bending(self):
        &#34;&#34;&#34;Bending forces of the end nodes and internal nodes [0, kNm, kNm]&#34;&#34;&#34;
        return np.array(self._vfNode.bending)

    def give_python_code(self):
        code = &#34;# code for beam {}&#34;.format(self.name)
        code += &#34;\ns.new_beam(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            nodeA=&#39;{}&#39;,&#34;.format(self.nodeA.name)
        code += &#34;\n            nodeB=&#39;{}&#39;,&#34;.format(self.nodeB.name)
        code += &#34;\n            n_segments={},&#34;.format(self.n_segments)
        code += &#34;\n            tension_only={},&#34;.format(self.tension_only)
        code += &#34;\n            EIy ={},&#34;.format(self.EIy)
        code += &#34;\n            EIz ={},&#34;.format(self.EIz)
        code += &#34;\n            GIp ={},&#34;.format(self.GIp)
        code += &#34;\n            EA ={},&#34;.format(self.EA)
        code += &#34;\n            mass ={},&#34;.format(self.mass)
        code += &#34;\n            L ={}) # L can possibly be omitted&#34;.format(self.L)

        return code


class TriMeshSource(Node):
    &#34;&#34;&#34;
    TriMesh

    A TriMesh node contains triangular mesh which can be used for buoyancy or contact

    &#34;&#34;&#34;

    def __init__(self, scene, source):

        super().__init__(scene)

        # Note: Visual does not have a corresponding vfCore Node in the scene but does have a vfCore
        self._TriMesh = source
        self._new_mesh = True  # cheat for visuals

        self._path = &#34;&#34;  # stores the data that was used to load the obj
        self._offset = (0, 0, 0)
        self._scale = (1, 1, 1)
        self._rotation = (0, 0, 0)

        self._invert_normals = False

    def depends_on(self) -&gt; list:
        return []

    def AddVertex(self, x, y, z):
        &#34;&#34;&#34;Adds a vertex (point)&#34;&#34;&#34;
        self._TriMesh.AddVertex(x, y, z)

    def AddFace(self, i, j, k):
        &#34;&#34;&#34;Adds a triangular face between vertex numbers i,j and k&#34;&#34;&#34;
        self._TriMesh.AddFace(i, j, k)

    def get_extends(self):
        &#34;&#34;&#34;Returns the extends of the mesh in global coordinates

        Returns: (minimum_x, maximum_x, minimum_y, maximum_y, minimum_z, maximum_z)

        &#34;&#34;&#34;

        t = self._TriMesh

        if t.nFaces == 0:
            return (0, 0, 0, 0, 0, 0)

        v = t.GetVertex(0)
        xn = v[0]
        xp = v[0]
        yn = v[1]
        yp = v[1]
        zn = v[2]
        zp = v[2]

        for i in range(t.nVertices):
            v = t.GetVertex(i)
            x = v[0]
            y = v[1]
            z = v[2]

            if x &lt; xn:
                xn = x
            if x &gt; xp:
                xp = x
            if y &lt; yn:
                yn = y
            if y &gt; yp:
                yp = y
            if z &lt; zn:
                zn = z
            if z &gt; zp:
                zp = z

        return (xn, xp, yn, yp, zn, zp)

    def _fromVTKpolydata(
        self, polydata, offset=None, rotation=None, scale=None, invert_normals=False
    ):

        import vtk

        tri = vtk.vtkTriangleFilter()

        tri.SetInputConnection(polydata)

        scaleFilter = vtk.vtkTransformPolyDataFilter()
        rotationFilter = vtk.vtkTransformPolyDataFilter()

        s = vtk.vtkTransform()
        s.Identity()
        r = vtk.vtkTransform()
        r.Identity()

        rotationFilter.SetInputConnection(tri.GetOutputPort())
        scaleFilter.SetInputConnection(rotationFilter.GetOutputPort())

        if scale is not None:
            s.Scale(*scale)

        if rotation is not None:
            q = rotation
            angle = (q[0] ** 2 + q[1] ** 2 + q[2] ** 2) ** (0.5)
            if angle &gt; 0:
                r.RotateWXYZ(angle, q[0] / angle, q[1] / angle, q[2] / angle)

        if offset is None:
            offset = [0, 0, 0]

        scaleFilter.SetTransform(s)
        rotationFilter.SetTransform(r)

        scaleFilter.Update()
        data = scaleFilter.GetOutput()
        self._TriMesh.Clear()

        for i in range(data.GetNumberOfPoints()):
            point = data.GetPoint(i)
            self._TriMesh.AddVertex(
                point[0] + offset[0], point[1] + offset[1], point[2] + offset[2]
            )

        for i in range(data.GetNumberOfCells()):
            cell = data.GetCell(i)

            if isinstance(cell, vtk.vtkLine):
                print(&#34;Cell nr {} is a line, not adding to mesh&#34;.format(i))
                continue

            if isinstance(cell, vtk.vtkVertex):
                print(&#34;Cell nr {} is a vertex, not adding to mesh&#34;.format(i))
                continue

            id0 = cell.GetPointId(0)
            id1 = cell.GetPointId(1)
            id2 = cell.GetPointId(2)

            if invert_normals:
                self._TriMesh.AddFace(id2, id1, id0)
            else:
                self._TriMesh.AddFace(id0, id1, id2)

        # check if anything was loaded
        if self._TriMesh.nFaces == 0:
            raise Exception(
                &#34;No faces in poly-data - no geometry added (hint: empty obj file?)&#34;
            )
        self._new_mesh = True
        self._scene.update()

    def check_shape(self):
        &#34;&#34;&#34;Performs some checks on the shape in the trimesh
        - Boundary edges (edge with only one face attached)
        - Non-manifold edges (edit with more than two faces attached)
        - Volume should be positive
        &#34;&#34;&#34;

        tm = self._TriMesh

        if tm.nFaces == 0:
            return [&#34;No mesh&#34;]

        # Make a list of all boundaries using their vertex IDs
        boundaries = np.zeros((3 * tm.nFaces, 2))
        for i in range(tm.nFaces):
            face = tm.GetFace(i)
            boundaries[3 * i] = [face[0], face[1]]
            boundaries[3 * i + 1] = [face[1], face[2]]
            boundaries[3 * i + 2] = [face[2], face[0]]

        # For an edge is doesn&#39;t matter in which direction it runs
        boundaries.sort(axis=1)

        rows_occurance_count = np.unique(boundaries, axis=0, return_counts=True)[
            1
        ]  # count of rows

        n_boundary = np.count_nonzero(rows_occurance_count == 1)
        n_nonmanifold = np.count_nonzero(rows_occurance_count &gt; 2)

        messages = []

        if n_boundary &gt; 0:
            messages.append(f&#34;Mesh contains {n_boundary} boundary edges&#34;)
        if n_nonmanifold &gt; 0:
            messages.append(f&#34;Mesh contains {n_nonmanifold} non-manifold edges&#34;)

        # Do not check for volume if we have nonmanifold geometry or boundary edges
        try:
            volume = tm.Volume()
        except:
            volume = 1  # no available in every pyo3d yet

        if volume &lt; 0:
            messages.append(
                f&#34;Total mesh volume is negative ({volume:.2f} m3 of enclosed volume).&#34;
            )
            messages.append(&#34;Hint: Use invert-normals&#34;)

        return messages

    def load_vtk_polydataSource(self, polydata):
        &#34;&#34;&#34;Fills the triangle data from a vtk polydata such as a cubeSource.

        The vtk TriangleFilter is used to triangulate the source

        Examples:
            cube = vtk.vtkCubeSource()
            cube.SetXLength(122)
            cube.SetYLength(38)
            cube.SetZLength(10)
            trimesh.load_vtk_polydataSource(cube)
        &#34;&#34;&#34;

        self._fromVTKpolydata(polydata.GetOutputPort())

    def load_obj(
        self, filename, offset=None, rotation=None, scale=None, invert_normals=False
    ):
        self.load_file(filename, offset, rotation, scale, invert_normals)

    def load_file(
        self, url, offset=None, rotation=None, scale=None, invert_normals=False
    ):
        &#34;&#34;&#34;Loads an .obj or .stl file and and triangulates it.

        Order of modifications:

        1. rotate
        2. scale
        3. offset

        Args:
            url: (str or path or resource): file to load
            offset: : offset
            rotation:  : rotation
            scale:  scale

        &#34;&#34;&#34;

        self._path = str(url)

        filename = str(self._scene.get_resource_path(url))

        import vtk

        ext = filename.lower()[-3:]
        if ext == &#34;obj&#34;:
            obj = vtk.vtkOBJReader()
            obj.SetFileName(filename)
        elif ext == &#34;stl&#34;:
            obj = vtk.vtkSTLReader()
            obj.SetFileName(filename)
        else:
            raise ValueError(
                f&#34;File should be an .obj or .stl file but has extension {ext}&#34;
            )

        # Add cleaning
        cln = vtk.vtkCleanPolyData()
        cln.SetInputConnection(obj.GetOutputPort())

        self._fromVTKpolydata(
            cln.GetOutputPort(),
            offset=offset,
            rotation=rotation,
            scale=scale,
            invert_normals=invert_normals,
        )

        self._scale = scale
        self._offset = offset
        self._rotation = rotation

        if self._scale is None:
            self._scale = (1.0, 1.0, 1.0)
        if self._offset is None:
            self._offset = (0.0, 0.0, 0.0)
        if self._rotation is None:
            self._rotation = (0.0, 0.0, 0.0)
        self._invert_normals = invert_normals

    def _load_from_privates(self):
        &#34;&#34;&#34;(Re)Loads the mesh using the values currently stored in _scale, _offset, _rotation and _invert_normals&#34;&#34;&#34;
        self.load_file(url = self._path,
                       scale=self._scale,
                       offset=self._offset,
                       rotation=self._rotation,
                       invert_normals=self._invert_normals)


    def give_python_code(self):
        code = &#34;# No code generated for TriMeshSource&#34;
        return code

    # def change_parent_to(self, new_parent):
    #
    #     if not (isinstance(new_parent, Axis) or new_parent is None):
    #         raise ValueError(&#39;Visuals can only be attached to an axis (or derived) or None&#39;)
    #
    #     # get current position and orientation
    #     if self.parent is not None:
    #         cur_position = self.parent.to_glob_position(self.offset)
    #         cur_rotation = self.parent.to_glob_direction(self.rotation)
    #     else:
    #         cur_position = self.offset
    #         cur_rotation = self.rotation
    #
    #     self.parent = new_parent
    #
    #     if new_parent is None:
    #         self.offset = cur_position
    #         self.rotation = cur_rotation
    #     else:
    #         self.offset = new_parent.to_loc_position(cur_position)
    #         self.rotation = new_parent.to_loc_direction(cur_rotation)


class Buoyancy(NodeWithParent):
    &#34;&#34;&#34;Buoyancy provides a buoyancy force based on a buoyancy mesh. The mesh is triangulated and chopped at the instantaneous flat water surface. Buoyancy is applied as an upwards force that the center of buoyancy.
    The calculation of buoyancy is as accurate as the provided geometry.

    There as no restrictions to the size or aspect ratio of the panels. It is excellent to model as box using 6 faces. Using smaller panels has a negative effect on performance.

    The normals of the panels should point towards to water.
    &#34;&#34;&#34;

    # init parent and name are fully derived from NodeWithParent
    # _vfNode is a buoyancy
    def __init__(self, scene, vfBuoyancy):
        super().__init__(scene, vfBuoyancy)
        self._None_parent_acceptable = False
        self._trimesh = TriMeshSource(
            self._scene, self._vfNode.trimesh
        )  # the tri-mesh is wrapped in a custom object

    def update(self):
        self._vfNode.reloadTrimesh()

    @property
    def trimesh(self) -&gt; TriMeshSource:
        return self._trimesh

    @property
    def cob(self):
        &#34;&#34;&#34;GLOBAL position of the center of buoyancy [m,m,m] (global axis)&#34;&#34;&#34;
        return self._vfNode.cob

    @property
    def cob_local(self):
        &#34;&#34;&#34;Position of the center of buoyancy [m,m,m] (local axis)&#34;&#34;&#34;

        return self.parent.to_loc_position(self.cob)

    @property
    def displacement(self):
        &#34;&#34;&#34;Displaced volume of fluid [m^3]&#34;&#34;&#34;
        return self._vfNode.displacement

    @property
    def density(self):
        &#34;&#34;&#34;Density of surrounding fluid [mT/m3].
        Typical values: Seawater = 1.025, fresh water = 1.00
        &#34;&#34;&#34;
        return self._vfNode.density

    @density.setter
    @node_setter_manageable
    @node_setter_observable
    def density(self, value):
        assert1f_positive_or_zero(value, &#34;density&#34;)
        self._vfNode.density = value

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\nmesh = s.new_buoyancy(name=&#39;{}&#39;,&#34;.format(self.name)

        if self.density != 1.025:
            code += f&#34;\n          density={self.density},&#34;

        code += &#34;\n          parent=&#39;{}&#39;)&#34;.format(self.parent_for_export.name)

        if self.trimesh._invert_normals:
            code += &#34;\nmesh.trimesh.load_file(r&#39;{}&#39;, scale = ({},{},{}), rotation = ({},{},{}), offset = ({},{},{}), invert_normals=True)&#34;.format(
                self.trimesh._path,
                *self.trimesh._scale,
                *self.trimesh._rotation,
                *self.trimesh._offset,
            )
        else:
            code += &#34;\nmesh.trimesh.load_file(r&#39;{}&#39;, scale = ({},{},{}), rotation = ({},{},{}), offset = ({},{},{}))&#34;.format(
                self.trimesh._path,
                *self.trimesh._scale,
                *self.trimesh._rotation,
                *self.trimesh._offset,
            )

        return code


class Tank(NodeWithParent):
    &#34;&#34;&#34;Tank provides a fillable tank based on a mesh. The mesh is triangulated and chopped at the instantaneous flat fluid surface. Gravity is applied as an downwards force that the center of fluid.
    The calculation of fluid volume and center is as accurate as the provided geometry.

    There as no restrictions to the size or aspect ratio of the panels. It is excellent to model as box using 6 faces. Using smaller panels has a negative effect on performance.

    The normals of the panels should point *away* from the fluid. This means that the same basic shapes can be used for both buoyancy and tanks.
    &#34;&#34;&#34;

    # init parent and name are fully derived from NodeWithParent
    # _vfNode is a tank
    def __init__(self, scene, vfTank):
        super().__init__(scene, vfTank)
        self._None_parent_acceptable = False
        self._trimesh = TriMeshSource(
            self._scene, self._vfNode.trimesh
        )  # the tri-mesh is wrapped in a custom object

        self._inertia = scene._vfc.new_pointmass(
            self.name + vfc.VF_NAME_SPLIT + &#34;inertia&#34;
        )

    def update(self):
        self._vfNode.reloadTrimesh()

        # update inertia
        self._inertia.parent = self.parent._vfNode
        self._inertia.position = self.cog_local
        self._inertia.inertia = self.volume * self.density


    def _delete_vfc(self):
        self._scene._vfc.delete(self._inertia.name)
        super()._delete_vfc()

    @property
    def trimesh(self) -&gt; TriMeshSource:
        return self._trimesh

    @property
    def free_flooding(self):
        return self._vfNode.free_flooding

    @free_flooding.setter
    def free_flooding(self, value):
        assert isinstance(value, bool), ValueError(
            f&#34;free_flooding shall be a bool, you passed a {type(value)}&#34;
        )
        self._vfNode.free_flooding = value

    @property
    def permeability(self):
        &#34;&#34;&#34;Permeability is the fraction of the enclosed volume that can be filled with fluid [-]&#34;&#34;&#34;
        return self._vfNode.permeability

    @permeability.setter
    def permeability(self, value):
        assert1f_positive_or_zero(value)
        self._vfNode.permeability = value

    @property
    def cog(self):
        &#34;&#34;&#34;Returns the GLOBAL position of the center of volume / gravity&#34;&#34;&#34;
        return self._vfNode.cog

    @property
    def cog_local(self):
        &#34;&#34;&#34;Returns the local position of the center of gravity&#34;&#34;&#34;
        return self.parent.to_loc_position(self.cog)

    @property
    def cog_when_full(self):
        &#34;&#34;&#34;Returns the LOCAL position of the center of volume / gravity of the tank when it is filled&#34;&#34;&#34;
        return self._vfNode.cog_when_full

    @property
    def fill_pct(self):
        &#34;&#34;&#34;Amount of volume in tank as percentage of capacity [%]&#34;&#34;&#34;
        if self.capacity == 0:
            return 0
        return 100 * self.volume / self.capacity

    @fill_pct.setter
    @node_setter_manageable
    @node_setter_observable
    def fill_pct(self, value):

        if value &lt; 0 and value &gt; -0.01:
            value = 0

        assert1f_positive_or_zero(value)

        if value &gt; 100.1:
            raise ValueError(
                f&#34;Fill percentage should be between 0 and 100 [%], {value} is not valid&#34;
            )
        if value &gt; 100:
            value = 100
        self.volume = value * self.capacity / 100

    @property
    def level_global(self):
        &#34;&#34;&#34;The fluid plane elevation in the global axis system. Setting this adjusts the volume&#34;&#34;&#34;
        return self._vfNode.fluid_level_global

    @level_global.setter
    @node_setter_manageable
    @node_setter_observable
    def level_global(self, value):
        assert1f(value)
        self._vfNode.fluid_level_global = value

    @property
    def volume(self):
        &#34;&#34;&#34;The volume of fluid in the tank in m3. Setting this adjusts the fluid level&#34;&#34;&#34;
        return self._vfNode.volume

    @volume.setter
    @node_setter_manageable
    @node_setter_observable
    def volume(self, value):
        assert1f_positive_or_zero(value, &#34;Volume&#34;)
        self._vfNode.volume = value

    @property
    def density(self):
        &#34;&#34;&#34;Density of the fluid in the tank in mT/m3&#34;&#34;&#34;
        return self._vfNode.density

    @density.setter
    @node_setter_manageable
    @node_setter_observable
    def density(self, value):
        assert1f(value)
        self._vfNode.density = value

    @property
    def capacity(self):
        &#34;&#34;&#34;Returns the capacity of the tank in m3. This is calculated from the defined geometry.&#34;&#34;&#34;
        return self._vfNode.capacity

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\nmesh = s.new_tank(name=&#39;{}&#39;,&#34;.format(self.name)

        if self.density != 1.025:
            code += f&#34;\n          density={self.density},&#34;

        if self.free_flooding:
            code += f&#34;\n          free_flooding=True,&#34;

        code += &#34;\n          parent=&#39;{}&#39;)&#34;.format(self.parent_for_export.name)

        if self.trimesh._invert_normals:
            code += &#34;\nmesh.trimesh.load_file(r&#39;{}&#39;, scale = ({},{},{}), rotation = ({},{},{}), offset = ({},{},{}), invert_normals=True)&#34;.format(
                self.trimesh._path,
                *self.trimesh._scale,
                *self.trimesh._rotation,
                *self.trimesh._offset,
            )
        else:
            code += &#34;\nmesh.trimesh.load_file(r&#39;{}&#39;, scale = ({},{},{}), rotation = ({},{},{}), offset = ({},{},{}))&#34;.format(
                self.trimesh._path,
                *self.trimesh._scale,
                *self.trimesh._rotation,
                *self.trimesh._offset,
            )
        code += f&#34;\ns[&#39;{self.name}&#39;].volume = {self.volume}   # first load mesh, then set volume&#34;

        return code


class BallastSystem(Node):
    &#34;&#34;&#34;A BallastSystem is a group of Tank objects.

    The tank objects are created separately and only their references are assigned to this ballast-system object.

    &#34;&#34;&#34;

    def __init__(self, scene, parent):
        super().__init__(scene)

        self.tanks = []
        &#34;&#34;&#34;List of Tank objects&#34;&#34;&#34;

        self.frozen = []
        &#34;&#34;&#34;List of names of frozen tanks - The contents of a frozen tank should not be changed&#34;&#34;&#34;

        self.parent = parent

    def new_tank(
        self, name, position, capacity_kN, rho=1.025, frozen=False, actual_fill=0
    ):
        &#34;&#34;&#34;Adds a new cubic shaped tank with the given volume as derived from capacity and rho

        Warning: provided for backwards compatibility only.
        &#34;&#34;&#34;

        from warnings import warn

        warn(
            &#34;BallastSystem.new_tank is outdated and may be removed in a future version.&#34;
        )

        tnk = self._scene.new_tank(name, parent=self.parent, density=rho)
        volume = capacity_kN / (9.81 * rho)
        side = volume ** (1 / 3)
        tnk.trimesh.load_file(
            &#34;res: cube.obj&#34;,
            scale=(side, side, side),
            rotation=(0.0, 0.0, 0.0),
            offset=position,
        )
        if actual_fill &gt; 0:
            tnk.fill_pct = actual_fill

        if frozen:
            tnk.frozen = frozen

        self.tanks.append(tnk)

        return tnk

    # for gui
    def change_parent_to(self, new_parent):
        if not (isinstance(new_parent, Axis) or new_parent is None):
            raise ValueError(
                &#34;Visuals can only be attached to an axis (or derived) or None&#34;
            )
        self.parent = new_parent

    # for node
    def depends_on(self):
        return [self.parent, *self.tanks]

    def is_frozen(self, name):
        &#34;&#34;&#34;Returns True if the tank with this name if frozen&#34;&#34;&#34;
        return name in self.frozen

    def reorder_tanks(self, names):
        &#34;&#34;&#34;Places tanks with given names at the top of the list. Other tanks are appended afterwards in original order.

        For a complete re-order give all tank names.

        Example:
            let tanks be &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;

            then re_order_tanks([&#39;e&#39;,&#39;b&#39;]) will result in [&#39;e&#39;,&#39;b&#39;,&#39;a&#39;,&#39;c&#39;,&#39;d&#39;]
        &#34;&#34;&#34;
        for name in names:
            if name not in self.tank_names():
                raise ValueError(&#34;No tank with name {}&#34;.format(name))

        old_tanks = self.tanks.copy()
        self.tanks.clear()
        to_be_deleted = list()

        for name in names:
            for tank in old_tanks:
                if tank.name == name:
                    self.tanks.append(tank)
                    to_be_deleted.append(tank)

        for tank in to_be_deleted:
            old_tanks.remove(tank)

        for tank in old_tanks:
            self.tanks.append(tank)

    def order_tanks_by_elevation(self):
        &#34;&#34;&#34;Re-orders the existing tanks such that the lowest tanks are higher in the list&#34;&#34;&#34;

        zs = [tank.cog_when_full[2] for tank in self.tanks]
        inds = np.argsort(zs)
        self.tanks = [self.tanks[i] for i in inds]

    def order_tanks_by_distance_from_point(self, point, reverse=False):
        &#34;&#34;&#34;Re-orders the existing tanks such that the tanks *furthest* from the point are first on the list

        Args:
            point : (x,y,z)  - reference point to determine the distance to
            reverse: (False) - order in reverse order: tanks nearest to the points first on list


        &#34;&#34;&#34;
        pos = [tank.cog_when_full for tank in self.tanks]
        pos = np.array(pos, dtype=float)
        pos -= np.array(point)

        dist = np.apply_along_axis(np.linalg.norm, 1, pos)

        if reverse:
            inds = np.argsort(dist)
        else:
            inds = np.argsort(-dist)

        self.tanks = [self.tanks[i] for i in inds]

    def order_tanks_to_maximize_inertia_moment(self):
        &#34;&#34;&#34;Re-order tanks such that tanks furthest from center of system are first on the list&#34;&#34;&#34;
        self._order_tanks_to_inertia_moment()

    def order_tanks_to_minimize_inertia_moment(self):
        &#34;&#34;&#34;Re-order tanks such that tanks nearest to center of system are first on the list&#34;&#34;&#34;
        self._order_tanks_to_inertia_moment(maximize=False)

    def _order_tanks_to_inertia_moment(self, maximize=True):
        &#34;&#34;&#34;Re-order tanks such that tanks furthest away from center of system are first on the list&#34;&#34;&#34;
        pos = [tank.cog_when_full for tank in self.tanks]
        m = [tank.capacity for tank in self.tanks]
        pos = np.array(pos, dtype=float)
        mxmymz = np.vstack((m, m, m)).transpose() * pos
        total = np.sum(m)
        point = sum(mxmymz) / total

        if maximize:
            self.order_tanks_by_distance_from_point(point)
        else:
            self.order_tanks_by_distance_from_point(point, reverse=True)

    def tank_names(self):
        return [tank.name for tank in self.tanks]

    def fill_tank(self, name, fill):

        assert1f(fill, &#34;tank fill&#34;)

        for tank in self.tanks:
            if tank.name == name:
                tank.pct = fill
                return
        raise ValueError(&#34;No tank with name {}&#34;.format(name))

    def xyzw(self):
        &#34;&#34;&#34;Gets the current ballast cog in GLOBAL axis system weight from the tanks

        Returns:
            (x,y,z), weight [mT]
        &#34;&#34;&#34;
        &#34;&#34;&#34;Calculates the weight and inertia properties of the tanks&#34;&#34;&#34;

        mxmymz = np.array((0.0, 0.0, 0.0))
        wt = 0

        for tank in self.tanks:
            w = tank.volume * tank.density
            p = np.array(tank.cog, dtype=float)
            mxmymz += p * w

            wt += w

        if wt == 0:
            xyz = np.array((0.0, 0.0, 0.0))
        else:
            xyz = mxmymz / wt

        return xyz, wt

    def empty_all_usable_tanks(self):
        &#34;&#34;&#34;Empties all non-frozen tanks.
        Returns a list with tank number and fill percentage of all affected tanks. This can be used to restore the
        ballast situation as it was before emptying.

        See also: restore tank fillings
        &#34;&#34;&#34;
        restore = []

        for i, t in enumerate(self.tanks):
            if not self.is_frozen(t.name):
                restore.append((i, t.fill_pct))
                t.fill_pct = 0

        return restore

    def restore_tank_fillings(self, restore):
        &#34;&#34;&#34;Restores the tank fillings as per restore.

        Restore is typically obtained from the &#34;empty_all_usable_tanks&#34; function.

        See Also: empty_all_usable_tanks
        &#34;&#34;&#34;

        for r in restore:
            i, pct = r
            self.tanks[i].fill_pct = pct

    def tank(self, name):

        for t in self.tanks:
            if t.name == name:
                return t
        raise ValueError(&#34;No tank with name {}&#34;.format(name))

    def __getitem__(self, item):
        return self.tank(item)

    @property
    def cogx(self):
        &#34;&#34;&#34;X position of combined CoG of all tank contents in the ballast-system. (global coordinate) [m]&#34;&#34;&#34;
        return self.cog[0]

    @property
    def cogy(self):
        &#34;&#34;&#34;Y position of combined CoG of all tank contents in the ballast-system. (global coordinate) [m]&#34;&#34;&#34;
        return self.cog[1]

    @property
    def cogz(self):
        &#34;&#34;&#34;Z position of combined CoG of all tank contents in the ballast-system. (global coordinate) [m]&#34;&#34;&#34;
        return self.cog[2]

    @property
    def cog(self):
        &#34;&#34;&#34;Combined CoG of all tank contents in the ballast-system. (global coordinate) [m,m,m]&#34;&#34;&#34;
        cog, wt = self.xyzw()
        return (cog[0], cog[1], cog[2])

    @property
    def weight(self):
        &#34;&#34;&#34;Total weight of all tank fillings in the ballast system [kN]&#34;&#34;&#34;
        cog, wt = self.xyzw()
        return wt * 9.81

    def give_python_code(self):
        code = &#34;\n# code for {} and its tanks&#34;.format(self.name)

        code += &#34;\nbs = s.new_ballastsystem(&#39;{}&#39;, parent = &#39;{}&#39;)&#34;.format(
            self.name, self.parent.name
        )

        for tank in self.tanks:
            code += &#34;\nbs.tanks.append(s[&#39;{}&#39;])&#34;.format(tank.name)

        return code


class WaveInteraction1(Node):
    &#34;&#34;&#34;
    WaveInteraction

    Wave-interaction-1 couples a first-order hydrodynamic database to an axis.

    This adds:
    - wave-forces
    - damping
    - added mass

    The data is provided by a Hyddb1 object which is defined in the MaFreDo package. The contents are not embedded
    but are to be provided separately in a file. This node contains only the file-name.

    &#34;&#34;&#34;

    def __init__(self, scene):

        super().__init__(scene)

        self.offset = [0, 0, 0]
        &#34;&#34;&#34;Position (x,y,z) of the hydrodynamic origin in its parents axis system&#34;&#34;&#34;

        self.parent = None
        &#34;&#34;&#34;Parent : Axis-type&#34;&#34;&#34;

        self.path = None
        &#34;&#34;&#34;Filename of a file that can be read by a Hyddb1 object&#34;&#34;&#34;

    @property
    def file_path(self):
        return self._scene.get_resource_path(self.path)

    def depends_on(self):
        return [self.parent]

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        code += &#34;\ns.new_waveinteraction(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            parent=&#39;{}&#39;,&#34;.format(self.parent.name)
        code += &#34;\n            path=r&#39;{}&#39;,&#34;.format(self.path)
        code += &#34;\n            offset=({}, {}, {}) )&#34;.format(*self.offset)

        return code

    def change_parent_to(self, new_parent):

        if not (isinstance(new_parent, Axis)):
            raise ValueError(
                &#34;Hydrodynamic databases can only be attached to an axis (or derived)&#34;
            )

        # get current position and orientation
        if self.parent is not None:
            cur_position = self.parent.to_glob_position(self.offset)
        else:
            cur_position = self.offset

        self.parent = new_parent
        self.offset = new_parent.to_loc_position(cur_position)


# ============== Managed nodes


class Manager(Node, ABC):


    # @abstractmethod                   not used anywhere outside the manager classes, so no requirement
    # def managed_nodes(self):
    #     &#34;&#34;&#34;Returns a list of managed nodes&#34;&#34;&#34;
    #     raise Exception(&#34;derived class shall override this method&#34;)

    @abstractmethod
    def delete(self):
        &#34;&#34;&#34;Carefully remove the manager, reinstate situation as before. Do not delete the manager itself but do
        delete all the nodes it created.&#34;&#34;&#34;
        raise Exception(&#34;derived class shall override this method&#34;)

    @abstractmethod
    def creates(self, node: Node):
        &#34;&#34;&#34;Returns True if node is created by this manager&#34;&#34;&#34;

        raise Exception(&#34;derived class shall override this method&#34;)
        # hint: return node in self.managed_nodes() # would be a good option, just not good enough as default



class GeometricContact(Manager):
    &#34;&#34;&#34;
    GeometricContact

    A GeometricContact can be used to construct geometric connections between circular members:
        -       steel bars and holes, such as a shackle pin in a padeye (pin-hole)
        -       steel bars and steel bars, such as a shackle-shackle connection


    Situation before creation of geometric contact:

    Axis1
        Point1
            Circle1
    Axis2
        Point2
            Circle2

    Create a geometric contact with Circle1 and parent and Circle2 as child

    Axis1
        Point1              : observed, referenced as parent_circle_parent
            Circle1         : observed, referenced as parent_circle

        _axis_on_parent                 : managed
            _pin_hole_connection        : managed
                _connection_axial_rotation : managed
                    _axis_on_child      : managed
                        Axis2           : managed    , referenced as child_circle_parent_parent
                            Point2      : observed   , referenced as child_circle_parent
                                Circle2 : observed   , referenced as child_circle







    &#34;&#34;&#34;

    def __init__(self, scene, child_circle, parent_circle, name, inside=True):
        &#34;&#34;&#34;
        circle1 becomes the nodeB
        circle2 becomes the nodeA

        (attach circle 1 to circle 2)
        Args:
            scene:
            vfAxis:
            parent_circle:
            child_circle:
        &#34;&#34;&#34;

        if parent_circle.parent.parent is None:
            raise ValueError(
                &#34;The slaved pin is not located on an axis. Can not create the connection because there is no axis to nodeB&#34;
            )

        super().__init__(scene)
        self.name = name

        name_prefix = self.name + vfc.MANAGED_NODE_IDENTIFIER

        self._parent_circle = parent_circle
        self._parent_circle_parent = parent_circle.parent  # point

        self._child_circle = child_circle
        self._child_circle_parent = child_circle.parent  # point
        self._child_circle_parent_parent = child_circle.parent.parent  # axis

        self._flipped = False
        self._inside_connection = inside

        self._axis_on_parent = self._scene.new_axis(
            scene.available_name_like(name_prefix + &#34;_axis_on_parent&#34;)
        )
        &#34;&#34;&#34;Axis on the nodeA axis at the location of the center of hole or pin&#34;&#34;&#34;

        self._pin_hole_connection = self._scene.new_axis(
            scene.available_name_like(name_prefix + &#34;_pin_hole_connection&#34;)
        )
        &#34;&#34;&#34;axis between the center of the hole and the center of the pin. Free to rotate about the center of the hole as well as the pin&#34;&#34;&#34;

        self._axis_on_child = self._scene.new_axis(
            scene.available_name_like(name_prefix + &#34;_axis_on_child&#34;)
        )
        &#34;&#34;&#34;axis to which the slaved body is connected. Either the center of the hole or the center of the pin &#34;&#34;&#34;

        self._connection_axial_rotation = self._scene.new_axis(
            scene.available_name_like(name_prefix + &#34;_connection_axial_rotation&#34;)
        )

        # prohibit changes to nodes that were used in the creation of this connection
        for node in self.managed_nodes():
            node.manager = self

        # observe circles and their points
        self._parent_circle.observers.append(self)
        self._parent_circle_parent.observers.append(self)

        self._child_circle.observers.append(self)
        self._child_circle_parent.observers.append(self)

        self._child_circle_parent_parent._parent_for_code_export = None

        self._update_connection()

    def on_observed_node_changed(self, changed_node):
        self._update_connection()

    @staticmethod
    def _assert_parent_child_possible(parent, child):
        if parent.parent.parent == child.parent.parent:
            raise ValueError(
                f&#34;A GeometricContact can not be created between two circles on the same axis or body. Both circles are located on {parent.parent.parent}&#34;
            )

    @property
    def child(self):
        &#34;&#34;&#34;The Circle that is connected to the GeometricContact [Node]

        See Also: parent
        &#34;&#34;&#34;
        return self._child_circle

    @child.setter
    def child(self, value):
        new_child = self._scene._node_from_node_or_str(value)
        if not isinstance(new_child, Circle):
            raise ValueError(
                f&#34;Child of a geometric contact should be a Circle, but {new_child.name} is a {type(new_child)}&#34;
            )

        if new_child.parent.parent is None:
            raise ValueError(
                f&#34;Child circle {new_child.name} is not located on an axis or body and can thus not be used as child&#34;
            )

        self._assert_parent_child_possible(self.parent, new_child)

        store = self._scene.current_manager
        self._scene.current_manager = self

        # release old child
        self._child_circle.observers.remove(self)
        self._child_circle_parent.observers.remove(self)

        # release the slaved axis system
        self._child_circle_parent_parent._parent_for_code_export = True
        self._child_circle_parent_parent.manager = None

        # set new parent
        self._child_circle = new_child
        self._child_circle_parent = new_child.parent
        self._child_circle_parent_parent = new_child.parent.parent

        # and observe
        self._child_circle.observers.append(self)
        self._child_circle_parent.observers.append(self)

        # and manage
        self._child_circle_parent_parent._parent_for_code_export = None
        self._child_circle_parent_parent.manager = self

        self._scene.current_manager = store

        self._update_connection()

    @property
    def parent(self):
        &#34;&#34;&#34;The Circle that the GeometricConnection is connected to [Node]

        See Also: child
        &#34;&#34;&#34;
        return self._parent_circle

    @parent.setter
    @node_setter_manageable
    @node_setter_observable
    def parent(self, var):
        if var is None:
            raise ValueError(
                &#34;Parent of a geometric contact should be a Circle, not None&#34;
            )

        new_parent = self._scene._node_from_node_or_str(var)
        if not isinstance(new_parent, Circle):
            raise ValueError(
                f&#34;Parent of a geometric contact should be a Circle, but {new_parent.name} is a {type(new_parent)}&#34;
            )

        self._assert_parent_child_possible(new_parent, self.child)

        # release old parent
        self._parent_circle.observers.remove(self)
        self._parent_circle_parent.observers.remove(self)

        # set new parent
        self._parent_circle = new_parent
        self._parent_circle_parent = new_parent.parent

        # and observe
        self._parent_circle.observers.append(self)
        self._parent_circle_parent.observers.append(self)

        self._update_connection()

    def change_parent_to(self, new_parent):
        self.parent = new_parent

    def delete(self):

        # release management
        for node in self.managed_nodes():
            node._manager = None

        self._child_circle_parent_parent.change_parent_to(None)

        self._scene.delete(self._axis_on_child)
        self._scene.delete(self._pin_hole_connection)
        self._scene.delete(self._axis_on_parent)

        # release observers
        self._parent_circle.observers.remove(self)
        self._parent_circle_parent.observers.remove(self)

        self._child_circle.observers.remove(self)
        self._child_circle_parent.observers.remove(self)

    def _update_connection(self):

        remember = self._scene.current_manager
        self._scene.current_manager = self  # claim management

        # get current properties

        c_swivel = self.swivel
        c_swivel_fixed = self.swivel_fixed
        c_rotation_on_parent = self.rotation_on_parent
        c_fixed_to_parent = self.fixed_to_parent
        c_child_rotation = self.child_rotation
        c_child_fixed = self.child_fixed

        pin1 = self._child_circle  # nodeB
        pin2 = self._parent_circle  # nodeA

        if pin1.parent.parent is None:
            raise ValueError(
                &#34;The slaved pin is not located on an axis. Can not create the connection because there is no axis to nodeB&#34;
            )

        # --------- prepare hole

        if pin2.parent.parent is not None:
            self._axis_on_parent.parent = pin2.parent.parent
        self._axis_on_parent.position = pin2.parent.position
        self._axis_on_parent.fixed = (True, True, True, True, True, True)

        self._axis_on_parent.rotation = rotation_from_y_axis_direction(pin2.axis)

        # Position connection axis at the center of the nodeA axis (pin2)
        # and allow it to rotate about the pin
        self._pin_hole_connection.position = (0, 0, 0)
        self._pin_hole_connection.parent = self._axis_on_parent
        self._pin_hole_connection.fixed = (True, True, True, True, False, True)

        self._connection_axial_rotation.parent = self._pin_hole_connection
        self._connection_axial_rotation.position = (0, 0, 0)

        # Position the connection pin (self) on the target pin and
        # place the parent of the parent of the pin (the axis) on the connection axis
        # and fix it
        slaved_axis = pin1.parent.parent

        slaved_axis.parent = self._axis_on_child
        slaved_axis.position = -np.array(pin1.parent.position)
        slaved_axis.rotation = rotation_from_y_axis_direction(-1 * np.array(pin1.axis))

        slaved_axis.fixed = True

        self._axis_on_child.parent = self._connection_axial_rotation
        self._axis_on_child.rotation = (0, 0, 0)
        self._axis_on_child.fixed = (True, True, True, True, False, True)

        if self._inside_connection:

            # Place the pin in the hole
            self._connection_axial_rotation.rotation = (0, 0, 0)
            self._axis_on_child.position = (pin2.radius - pin1.radius, 0, 0)

        else:

            # pin-pin connection
            self._axis_on_child.position = (pin1.radius + pin2.radius, 0, 0)
            self._connection_axial_rotation.rotation = (90, 0, 0)

        # restore settings
        self.swivel = c_swivel
        self.swivel_fixed = c_swivel_fixed
        self.rotation_on_parent = c_rotation_on_parent
        self.fixed_to_parent = c_fixed_to_parent
        self.child_rotation = c_child_rotation
        self.child_fixed = c_child_fixed

        self._scene.current_manager = remember

    def set_pin_pin_connection(self):
        &#34;&#34;&#34;Sets the connection to be of type pin-pin&#34;&#34;&#34;

        self._inside_connection = False
        if self.swivel == 0:
            self.swivel = 90
        elif self.swivel == 180:
            self.swivel = 270

        self._update_connection()

    def set_pin_in_hole_connection(self):
        &#34;&#34;&#34;Sets the connection to be of type pin-in-hole

        The axes of the two sheaves are aligned by rotating the slaved body
        The axes of the two sheaves are placed at a distance hole_dia - pin_dia apart, perpendicular to the axis direction
        An axes is created at the centers of the two sheaves
        These axes are connected with a shore axis which is allowed to rotate relative to the nodeA axis
        the nodeB axis is fixed to this rotating axis
        &#34;&#34;&#34;
        self._inside_connection = True

        if self.swivel == 90:
            self.swivel = 0
        elif self.swivel == 270:
            self.swivel = 180

        self._update_connection()

    def managed_nodes(self):
        &#34;&#34;&#34;Returns a list of managed nodes&#34;&#34;&#34;

        return [
            self._child_circle_parent_parent,
            self._axis_on_parent,
            self._axis_on_child,
            self._pin_hole_connection,
            self._connection_axial_rotation,
        ]

    def depends_on(self):
        return [self._parent_circle, self._child_circle]

    def creates(self, node: Node):
        return node in [
            self._axis_on_parent,
            self._axis_on_child,
            self._pin_hole_connection,
            self._connection_axial_rotation,
        ]

    def flip(self):
        &#34;&#34;&#34;Changes the swivel angle by 180 degrees&#34;&#34;&#34;
        self.swivel = np.mod(self.swivel + 180, 360)

    def change_side(self):
        self.rotation_on_parent = np.mod(self.rotation_on_parent + 180, 360)
        self.child_rotation = np.mod(self.child_rotation + 180, 360)

    @property
    def swivel(self):
        &#34;&#34;&#34;Swivel angle between parent and child objects [degrees]&#34;&#34;&#34;
        return self._connection_axial_rotation.rotation[0]

    @swivel.setter
    @node_setter_manageable
    @node_setter_observable
    def swivel(self, value):
        remember = self._scene.current_manager  # claim management
        self._scene.current_manager = self
        self._connection_axial_rotation.rx = value
        self._scene.current_manager = remember  # restore old manager

    @property
    def swivel_fixed(self):
        &#34;&#34;&#34;Allow parent and child to swivel relative to eachother [boolean]&#34;&#34;&#34;
        return self._connection_axial_rotation.fixed[3]

    @swivel_fixed.setter
    @node_setter_manageable
    @node_setter_observable
    def swivel_fixed(self, value):
        remember = self._scene.current_manager  # claim management
        self._scene.current_manager = self
        self._connection_axial_rotation.fixed = [True, True, True, value, True, True]
        self._scene.current_manager = remember  # restore old manager

    @property
    def rotation_on_parent(self):
        &#34;&#34;&#34;Angle between the line connecting the centers of the circles and the axis system of the parent node [degrees]&#34;&#34;&#34;
        return self._pin_hole_connection.ry

    @rotation_on_parent.setter
    @node_setter_manageable
    @node_setter_observable
    def rotation_on_parent(self, value):
        remember = self._scene.current_manager  # claim management
        self._scene.current_manager = self
        self._pin_hole_connection.ry = value
        self._scene.current_manager = remember  # restore old manager

    @property
    def fixed_to_parent(self):
        &#34;&#34;&#34;Allow rotation around parent [boolean]

        see also: rotation_on_parent&#34;&#34;&#34;
        return self._pin_hole_connection.fixed[4]

    @fixed_to_parent.setter
    @node_setter_manageable
    @node_setter_observable
    def fixed_to_parent(self, value):
        remember = self._scene.current_manager  # claim management
        self._scene.current_manager = self
        self._pin_hole_connection.fixed = [True, True, True, True, value, True]
        self._scene.current_manager = remember  # restore old manager

    @property
    def child_rotation(self):
        &#34;&#34;&#34;Angle between the line connecting the centers of the circles and the axis system of the child node [degrees]&#34;&#34;&#34;
        return self._axis_on_child.ry

    @child_rotation.setter
    @node_setter_manageable
    @node_setter_observable
    def child_rotation(self, value):
        remember = self._scene.current_manager  # claim management
        self._scene.current_manager = self
        self._axis_on_child.ry = value
        self._scene.current_manager = remember  # restore old manager

    @property
    def child_fixed(self):
        &#34;&#34;&#34;Allow rotation of child relative to connection, see also: child_rotation [boolean]&#34;&#34;&#34;
        return self._axis_on_child.fixed[4]

    @child_fixed.setter
    @node_setter_manageable
    @node_setter_observable
    def child_fixed(self, value):
        remember = self._scene.current_manager  # claim management
        self._scene.current_manager = self
        self._axis_on_child.fixed = [True, True, True, True, value, True]
        self._scene.current_manager = remember  # restore old manager

    @property
    def inside(self):
        &#34;&#34;&#34;Type of connection: True means child circle is inside parent circle, False means the child circle is outside but the circumferences contact [boolean]&#34;&#34;&#34;
        return self._inside_connection

    @inside.setter
    @node_setter_manageable
    @node_setter_observable
    def inside(self, value):
        if value == self._inside_connection:
            return

        if value:
            self.set_pin_in_hole_connection()
        else:
            self.set_pin_pin_connection()

    def give_python_code(self):

        old_manger = self._scene.current_manager
        self._scene.current_manager = self

        code = []

        # code.append(&#39;#  create the connection&#39;)
        code.append(f&#34;s.new_geometriccontact(name = &#39;{self.name}&#39;,&#34;)
        code.append(f&#34;                       child = &#39;{self._child_circle.name}&#39;,&#34;)
        code.append(f&#34;                       parent = &#39;{self._parent_circle.name}&#39;,&#34;)
        code.append(f&#34;                       inside={self.inside},&#34;)

        if self.inside and self.swivel == 0:
            pass  # default for inside
        else:
            if not self.inside and self.swivel == 90:
                pass  # default for outside
            else:
                code.append(f&#34;                       swivel={self.swivel},&#34;)

        if not self.swivel_fixed:
            code.append(f&#34;                       swivel_fixed={self.swivel_fixed},&#34;)
        if self.fixed_to_parent:
            code.append(
                f&#34;                       parent_rotation={self.rotation_on_parent},&#34;
            )
            code.append(
                f&#34;                       fixed_to_parent={self.fixed_to_parent},&#34;
            )
        else:
            code.append(
                f&#34;                       fixed_to_parent=solved({self.fixed_to_parent}),&#34;
            )
        if self.child_fixed:
            code.append(f&#34;                       child_fixed={self.child_fixed},&#34;)
            code.append(f&#34;                       child_rotation={self.child_rotation},&#34;)
        else:
            code.append(
                f&#34;                       child_rotation=solved({self.child_rotation}),&#34;
            )

        code = [
            *code[:-1],
            code[-1][:-1] + &#34; )&#34;,
        ]  # remove the , from the last entry [should be a quicker way to do this]

        self._scene.current_manager = old_manger

        return &#34;\n&#34;.join(code)


class Sling(Manager):
    &#34;&#34;&#34;A Sling is a single wire with an eye on each end. The eyes are created by splicing the end of the sling back
    into the itself.

    The geometry of a sling is defined as follows:

    diameter : diameter of the wire
    LeyeA, LeyeB : inside lengths of the eyes
    LsplicaA, LspliceB : the length of the splices
    Total : the distance between the insides of ends of the eyes A and B when pulled straight.

    Stiffness:
    The stiffness of the sling is specified by a single value: EA
    This determines the stiffnesses of the individual parts as follows:
    Wire in the eyes: EA
    Splices: Infinity (rigid)
    Main part: determined such that total stiffness (k) of the sling is EA/L


      Eye A           Splice A             nodeA part                   Splice B          Eye B

    /---------------\                                                                /---------------\
    |                =============-------------------------------------===============                |
    \---------------/                                                                \---------------/

    See Also: Grommet

    &#34;&#34;&#34;

    def __init__(
        self,
        scene,
        name,
        length,
        LeyeA,
        LeyeB,
        LspliceA,
        LspliceB,
        diameter,
        EA,
        mass,
        endA=None,
        endB=None,
        sheaves=None,
    ):
        &#34;&#34;&#34;
        Creates a new sling with the following structure

            endA
            eyeA (cable)
            splice (body , mass/2)
            nodeA (cable)     [optional: runs over sheave]
            splice (body, mass/2)
            eyeB (cable)
            endB

        Args:
            scene:     The scene in which the sling should be created
            name:  Name prefix
            length: Total length measured between the inside of the eyes of the sling is pulled straight.
            LeyeA: Total inside length in eye A if stretched flat
            LeyeB: Total inside length in eye B if stretched flat
            LspliceA: Length of the splice at end A
            LspliceB: Length of the splice at end B
            diameter: Diameter of the sling
            EA: Effective mean EA of the sling
            mass: total mass
            endA : Sheave or poi to fix end A of the sling to [optional]
            endB : Sheave or poi to fix end A of the sling to [optional]
            sheave : Sheave or poi for the nodeA part of the sling

        Returns:

        &#34;&#34;&#34;

        super().__init__(scene)
        self.name = name

        name_prefix = self.name + vfc.MANAGED_NODE_IDENTIFIER

        # store the properties
        self._length = length
        self._LeyeA = LeyeA
        self._LeyeB = LeyeB
        self._LspliceA = LspliceA
        self._LspliceB = LspliceB
        self._diameter = diameter
        self._EA = EA
        self._mass = mass
        self._endA = scene._poi_or_sheave_from_node(endA)
        self._endB = scene._poi_or_sheave_from_node(endB)

        # create the two splices

        self.sa = scene.new_rigidbody(
            scene.available_name_like(name_prefix + &#34;_spliceA&#34;), fixed=False
        )
        self.a1 = scene.new_point(
            scene.available_name_like(name_prefix + &#34;_spliceA&#34;), parent=self.sa
        )
        self.a2 = scene.new_point(
            scene.available_name_like(name_prefix + &#34;_spliceA2&#34;), parent=self.sa
        )
        self.am = scene.new_point(
            scene.available_name_like(name_prefix + &#34;_spliceAM&#34;), parent=self.sa
        )

        self.avis = scene.new_visual(
            name + &#34;_spliceA_visual&#34;,
            parent=self.sa,
            path=r&#34;cylinder 1x1x1 lowres.obj&#34;,
            offset=(-LspliceA / 2, 0.0, 0.0),
            rotation=(0.0, 90.0, 0.0),
            scale=(LspliceA, 2 * diameter, diameter),
        )

        self.sb = scene.new_rigidbody(
            scene.available_name_like(name_prefix + &#34;_spliceB&#34;),
            rotation=(0, 0, 180),
            fixed=False,
        )
        self.b1 = scene.new_point(
            scene.available_name_like(name_prefix + &#34;_spliceB1&#34;), parent=self.sb
        )
        self.b2 = scene.new_point(
            scene.available_name_like(name_prefix + &#34;_spliceB2&#34;), parent=self.sb
        )
        self.bm = scene.new_point(
            scene.available_name_like(name_prefix + &#34;_spliceBM&#34;), parent=self.sb
        )

        self.bvis = scene.new_visual(
            scene.available_name_like(name_prefix + &#34;_spliceB_visual&#34;),
            parent=self.sb,
            path=r&#34;cylinder 1x1x1 lowres.obj&#34;,
            offset=(-LspliceB / 2, 0.0, 0.0),
            rotation=(0.0, 90.0, 0.0),
            scale=(LspliceB, 2 * diameter, diameter),
        )

        self.main = scene.new_cable(
            scene.available_name_like(name_prefix + &#34;_main_part&#34;),
            endA=self.am,
            endB=self.bm,
            length=1,
            EA=1,
            diameter=diameter,
        )

        self.eyeA = scene.new_cable(
            scene.available_name_like(name_prefix + &#34;_eyeA&#34;),
            endA=self.a1,
            endB=self.a2,
            length=1,
            EA=1,
        )
        self.eyeB = scene.new_cable(
            scene.available_name_like(name_prefix + &#34;_eyeB&#34;),
            endA=self.b1,
            endB=self.b2,
            length=1,
            EA=1,
        )

        # set initial positions of splices if we can
        if self._endA is not None and self._endB is not None:
            a = np.array(self._endA.global_position)
            b = np.array(self._endB.global_position)

            dir = b - a
            dir /= np.linalg.norm(dir)

            self.sa.rotation = rotation_from_x_axis_direction(-dir)
            self.sb.rotation = rotation_from_x_axis_direction(dir)
            self.sa.position = a + (LeyeA + 0.5 * LspliceA) * dir
            self.sb.position = b - (LeyeB + 0.5 * LspliceB) * dir

        # Update properties
        self.sheaves = sheaves
        self._update_properties()

        for n in self.managed_nodes():
            n.manager = self

    def _update_properties(self):

        # The stiffness of the nodeA part is corrected to account for the stiffness of the splices.
        # It is considered that the stiffness of the splices is two times that of the wire.
        #
        # Springs in series: 1/Ktotal = 1/k1 + 1/k2 + 1/k3

        backup = self._scene.current_manager  # store
        self._scene.current_manager = self

        Lmain = (
            self._length - self._LspliceA - self._LspliceB - self._LeyeA - self._LeyeB
        )

        if self._EA == 0:
            EAmain = 0
        else:
            ka = 2 * self._EA / self._LspliceA
            kb = 2 * self._EA / self._LspliceB
            kmain = self._EA / Lmain
            k_total = 1 / ((1 / ka) + (1 / kmain) + (1 / kb))

            EAmain = k_total * Lmain

        self.sa.mass = self._mass / 2
        self.sa.inertia_radii = (
            self._LspliceA / 2,
            self._LspliceA / 2,
            self._diameter / 2,
        )

        self.a1.position = (self._LspliceA / 2, self._diameter / 2, 0)
        self.a2.position = (self._LspliceA / 2, -self._diameter / 2, 0)
        self.am.position = (-self._LspliceA / 2, 0, 0)

        self.avis.offset = (-self._LspliceA / 2, 0.0, 0.0)
        self.avis.scale = (self._LspliceA, 2 * self._diameter, self._diameter)

        self.sb.mass = self._mass / 2
        self.sb.inertia_radii = (
            self._LspliceB / 2,
            self._LspliceB / 2,
            self._diameter / 2,
        )

        self.b1.position = (self._LspliceB / 2, self._diameter / 2, 0)
        self.b2.position = (self._LspliceB / 2, -self._diameter / 2, 0)
        self.bm.position = (-self._LspliceB / 2, 0, 0)

        self.bvis.offset = (-self._LspliceB / 2, 0.0, 0.0)
        self.bvis.scale = (self._LspliceB, 2 * self._diameter, self._diameter)

        self.main.length = Lmain
        self.main.EA = EAmain
        self.main.diameter = self._diameter
        self.main.connections = tuple([self.am, *self._sheaves, self.bm])

        self.eyeA.length = self._LeyeA * 2 - self._diameter
        self.eyeA.EA = self._EA
        self.eyeA.diameter = self._diameter

        if self._endA is not None:
            self.eyeA.connections = (self.a1, self._endA, self.a2)
        else:
            self.eyeA.connections = (self.a1, self.a2)

        self.eyeB.length = self._LeyeB * 2 - self._diameter
        self.eyeB.EA = self._EA
        self.eyeB.diameter = self._diameter

        if self._endB is not None:
            self.eyeB.connections = (self.b1, self._endB, self.b2)
        else:
            self.eyeB.connections = (self.b1, self.b2)

        self._scene.current_manager = backup  # restore

    def depends_on(self):
        &#34;&#34;&#34;The sling depends on the endpoints and sheaves (if any)&#34;&#34;&#34;

        a = list()

        if self._endA is not None:
            a.append(self._endA)
        if self._endB is not None:
            a.append(self._endB)

        a.extend(self.sheaves)

        return a

    def managed_nodes(self):
        a = [
            self.sa,
            self.a1,
            self.a2,
            self.am,
            self.avis,
            self.sb,
            self.b1,
            self.b2,
            self.bm,
            self.bvis,
            self.main,
            self.eyeA,
            self.eyeB,
        ]

        return a

    def creates(self, node: Node):
        return node in self.managed_nodes()  # all these are created

    def delete(self):

        # delete created nodes
        a = self.managed_nodes()

        for n in a:
            n._manager = None

        for n in a:
            if n in self._scene._nodes:
                self._scene.delete(n)  # delete if it is still available

    def give_python_code(self):
        code = f&#34;# Exporting {self.name}&#34;

        # if self.endA is not None:
        #     code += self.endA.give_python_code()
        # if self.endB is not None:
        #     code += self.endB.give_python_code()
        # for s in self.sheaves:
        #     code += s.give_python_code()

        code += &#34;\n# Create sling&#34;

        # (self, scene, name, Ltotal, LeyeA, LeyeB, LspliceA, LspliceB, diameter, EA, mass, endA = None, endB=None, sheaves=None):

        code += f&#39;\ns.new_sling(&#34;{self.name}&#34;, length = {self.length},&#39;
        code += f&#34;\n            LeyeA = {self.LeyeA},&#34;
        code += f&#34;\n            LeyeB = {self.LeyeB},&#34;
        code += f&#34;\n            LspliceA = {self.LspliceA},&#34;
        code += f&#34;\n            LspliceB = {self.LspliceB},&#34;
        code += f&#34;\n            diameter = {self.diameter},&#34;
        code += f&#34;\n            EA = {self.EA},&#34;
        code += f&#34;\n            mass = {self.mass},&#34;
        code += f&#39;\n            endA = &#34;{self.endA.name}&#34;,&#39;
        code += f&#39;\n            endB = &#34;{self.endB.name}&#34;,&#39;

        if self.sheaves:
            sheaves = &#34;[&#34;
            for s in self.sheaves:
                sheaves += f&#39;&#34;{s.name}&#34;, &#39;
            sheaves = sheaves[:-2] + &#34;]&#34;
        else:
            sheaves = &#34;None&#34;

        code += f&#34;\n            sheaves = {sheaves})&#34;

        return code

    # properties
    @property
    def length(self):
        &#34;&#34;&#34;Total length measured between the INSIDE of the eyes of the sling is pulled straight. [m]&#34;&#34;&#34;
        return self._length

    @length.setter
    @node_setter_manageable
    @node_setter_observable
    def length(self, value):

        min_length = self.LeyeA + self.LeyeB + self.LspliceA + self.LspliceB
        if value &lt;= min_length:
            raise ValueError(
                &#34;Total length of the sling should be at least the length of the eyes plus the length of the splices&#34;
            )

        self._length = value
        self._update_properties()

    @property
    def LeyeA(self):
        &#34;&#34;&#34;Total length inside eye A if stretched flat [m]&#34;&#34;&#34;
        return self._LeyeA

    @LeyeA.setter
    @node_setter_manageable
    @node_setter_observable
    def LeyeA(self, value):

        max_length = self.length - (self.LeyeB + self.LspliceA + self.LspliceB)
        if value &gt;= max_length:
            raise ValueError(
                &#34;Total length of the sling should be at least the length of the eyes plus the length of the splices&#34;
            )

        self._LeyeA = value
        self._update_properties()

    @property
    def LeyeB(self):
        &#34;&#34;&#34;Total length inside eye B if stretched flat [m]&#34;&#34;&#34;
        return self._LeyeB

    @LeyeB.setter
    @node_setter_manageable
    @node_setter_observable
    def LeyeB(self, value):

        max_length = self.length - (self.LeyeA + self.LspliceA + self.LspliceB)
        if value &gt;= max_length:
            raise ValueError(
                &#34;Total length of the sling should be at least the length of the eyes plus the length of the splices&#34;
            )

        self._LeyeB = value
        self._update_properties()

    @property
    def LspliceA(self):
        &#34;&#34;&#34;Length of the splice at end A [m]&#34;&#34;&#34;
        return self._LspliceA

    @LspliceA.setter
    @node_setter_manageable
    @node_setter_observable
    def LspliceA(self, value):

        max_length = self.length - (self.LeyeA + self.LeyeB + self.LspliceB)
        if value &gt;= max_length:
            raise ValueError(
                &#34;Total length of the sling should be at least the length of the eyes plus the length of the splices&#34;
            )

        self._LspliceA = value
        self._update_properties()

    @property
    def LspliceB(self):
        &#34;&#34;&#34;Length of the splice at end B [m]&#34;&#34;&#34;
        return self._LspliceB

    @LspliceB.setter
    @node_setter_manageable
    @node_setter_observable
    def LspliceB(self, value):

        max_length = self.length - (self.LeyeA + self.LeyeB + self.LspliceA)
        if value &gt;= max_length:
            raise ValueError(
                &#34;Total length of the sling should be at least the length of the eyes plus the length of the splices&#34;
            )

        self._LspliceB = value
        self._update_properties()

    @property
    def diameter(self):
        &#34;&#34;&#34;Diameter of the sling (except the splices) [m]&#34;&#34;&#34;
        return self._diameter

    @diameter.setter
    @node_setter_manageable
    @node_setter_observable
    def diameter(self, value):
        self._diameter = value
        self._update_properties()

    @property
    def EA(self):
        &#34;&#34;&#34;Effective mean EA of the sling when eyes are flat [kN].
        This is the EA that would be obtained when measuring the stiffness of the sling by putting zero-diameter pins in the eyes and stretching the sling and then using the length between the insides of the eyes.&#34;&#34;&#34;
        return self._EA

    @EA.setter
    @node_setter_manageable
    @node_setter_observable
    def EA(self, value):
        self._EA = value
        self._update_properties()

    @property
    def mass(self):
        &#34;&#34;&#34;Mass and weight of the sling. This mass is discretized  distributed over the two splices [mT]&#34;&#34;&#34;
        return self._mass

    @mass.setter
    @node_setter_manageable
    @node_setter_observable
    def mass(self, value):
        self._mass = value
        self._update_properties()

    @property
    def endA(self):
        &#34;&#34;&#34;End A [circle or point node]&#34;&#34;&#34;
        return self._endA

    @endA.setter
    @node_setter_manageable
    @node_setter_observable
    def endA(self, value):
        node = self._scene._node_from_node_or_str(value)
        self._endA = self._scene._poi_or_sheave_from_node(node)
        self._update_properties()

    @property
    def endB(self):
        &#34;&#34;&#34;End B [circle or point node]&#34;&#34;&#34;
        return self._endB

    @endB.setter
    @node_setter_manageable
    @node_setter_observable
    def endB(self, value):
        node = self._scene._node_from_node_or_str(value)
        self._endB = self._scene._poi_or_sheave_from_node(node)
        self._update_properties()

    @property
    def sheaves(self):
        &#34;&#34;&#34;List of sheaves (circles, points) that the sling runs over between the two ends.

        May be provided as list of nodes or node-names.
        &#34;&#34;&#34;
        return self._sheaves

    @sheaves.setter
    @node_setter_manageable
    @node_setter_observable
    def sheaves(self, value):
        s = []
        for v in value:
            node = self._scene._node_from_node_or_str(v)
            s.append(self._scene._poi_or_sheave_from_node(node))
        self._sheaves = s
        self._update_properties()


class Shackle(Manager, RigidBody):
    &#34;&#34;&#34;
    Green-Pin Heavy Duty Bow Shackle BN

    visual from: https://www.traceparts.com/en/product/green-pinr-p-6036-green-pinr-heavy-duty-bow-shackle-bn-hdgphm0800-mm?CatalogPath=TRACEPARTS%3ATP04001002006&amp;Product=10-04072013-086517&amp;PartNumber=HDGPHM0800
    details from: https://www.greenpin.com/sites/default/files/2019-04/brochure-april-2019.pdf

    wll a b c d e f g h i j k weight
    [t] [mm]  [kg]
    120 95 95 208 95 147 400 238 647 453 428 50 110
    150 105 108 238 105 169 410 275 688 496 485 50 160
    200 120 130 279 120 179 513 290 838 564 530 70 235
    250 130 140 299 130 205 554 305 904 614 565 70 295
    300 140 150 325 140 205 618 305 996 644 585 80 368
    400 170 175 376 164 231 668 325 1114 690 665 70 560
    500 180 185 398 164 256 718 350 1190 720 710 70 685
    600 200 205 444 189 282 718 375 1243 810 775 70 880
    700 210 215 454 204 308 718 400 1263 870 820 70 980
    800 210 220 464 204 308 718 400 1270 870 820 70 1100
    900 220 230 485 215 328 718 420 1296 920 860 70 1280
    1000 240 240 515 215 349 718 420 1336 940 900 70 1460
    1250 260 270 585 230 369 768 450 1456 1025 970 70 1990
    1500 280 290 625 230 369 818 450 1556 1025 1010 70 2400

    Returns:

    &#34;&#34;&#34;

    data = dict()
    # key = wll in t
    # dimensions a..k in [mm]
    #             a     b    c   d     e    f    g    h     i     j    k   weight[kg]
    # index       0     1    2    3    4    5    6    7     8     9    10   11
    data[&#34;GP120&#34;] = (95, 95, 208, 95, 147, 400, 238, 647, 453, 428, 50, 110)
    data[&#34;GP150&#34;] = (105, 108, 238, 105, 169, 410, 275, 688, 496, 485, 50, 160)
    data[&#34;GP200&#34;] = (120, 130, 279, 120, 179, 513, 290, 838, 564, 530, 70, 235)
    data[&#34;GP250&#34;] = (130, 140, 299, 130, 205, 554, 305, 904, 614, 565, 70, 295)
    data[&#34;GP300&#34;] = (140, 150, 325, 140, 205, 618, 305, 996, 644, 585, 80, 368)
    data[&#34;GP400&#34;] = (170, 175, 376, 164, 231, 668, 325, 1114, 690, 665, 70, 560)
    data[&#34;GP500&#34;] = (180, 185, 398, 164, 256, 718, 350, 1190, 720, 710, 70, 685)
    data[&#34;GP600&#34;] = (200, 205, 444, 189, 282, 718, 375, 1243, 810, 775, 70, 880)
    data[&#34;GP700&#34;] = (210, 215, 454, 204, 308, 718, 400, 1263, 870, 820, 70, 980)
    data[&#34;GP800&#34;] = (210, 220, 464, 204, 308, 718, 400, 1270, 870, 820, 70, 1100)
    data[&#34;GP900&#34;] = (220, 230, 485, 215, 328, 718, 420, 1296, 920, 860, 70, 1280)
    data[&#34;GP1000&#34;] = (240, 240, 515, 215, 349, 718, 420, 1336, 940, 900, 70, 1460)
    data[&#34;GP1250&#34;] = (260, 270, 585, 230, 369, 768, 450, 1456, 1025, 970, 70, 1990)
    data[&#34;GP1500&#34;] = (280, 290, 625, 230, 369, 818, 450, 1556, 1025, 1010, 70, 2400)

    def defined_kinds(self):
        &#34;&#34;&#34;Defined shackle kinds&#34;&#34;&#34;
        list = [a for a in Shackle.data.keys()]
        return list

    def _give_values(self, kind):
        if kind not in Shackle.data:
            for key in Shackle.data.keys():
                print(key)
            raise ValueError(
                f&#34;No data available for a Shackle of kind {kind}. Available values printed above&#34;
            )

        return Shackle.data[kind]

    def __init__(self, scene, name, kind, a, p, g):

        Manager.__init__(self, scene)
        RigidBody.__init__(self, scene, axis=a, poi=p, force=g)

        self.name = name

        _ = self._give_values(kind)  # to make sure it exists

        # origin is at center of pin
        # z-axis up
        # y-axis in direction of pin

        # self.body = scene.new_rigidbody(name=name + &#39;_body&#39;)

        # pin
        self.pin_point = scene.new_point(
            name=name + &#34;_pin_point&#34;, parent=self, position=(0.0, 0.0, 0.0)
        )
        self.pin = scene.new_circle(
            name=name + &#34;_pin&#34;, parent=self.pin_point, axis=(0.0, 1.0, 0.0)
        )

        # bow
        self.bow_point = scene.new_point(name=name + &#34;_bow_point&#34;, parent=self)

        self.bow = scene.new_circle(
            name=name + &#34;_bow&#34;, parent=self.bow_point, axis=(0.0, 1.0, 0.0)
        )

        # inside circle
        self.inside_point = scene.new_point(
            name=name + &#34;_inside_circle_center&#34;, parent=self
        )
        self.inside = scene.new_circle(
            name=name + &#34;_inside&#34;, parent=self.inside_point, axis=(1.0, 0, 0)
        )

        # code for GP800_visual
        self.visual_node = scene.new_visual(
            name=name + &#34;_visual&#34;,
            parent=self,
            path=r&#34;shackle_gp800.obj&#34;,
            offset=(0, 0, 0),
            rotation=(0, 0, 0),
        )

        self.kind = kind

        for n in self.managed_nodes():
            n.manager = self

    def depends_on(self):
        return []

    @property
    def kind(self):
        &#34;&#34;&#34;Type of shackle, for example GP800 [text]&#34;&#34;&#34;
        return self._kind

    @kind.setter
    # @node_setter_manageable   : allow changing of shackle kind
    @node_setter_observable
    def kind(self, kind):

        values = self._give_values(kind)
        weight = values[11] / 1000  # convert to tonne
        pin_dia = values[1] / 1000
        bow_dia = values[0] / 1000
        bow_length_inside = values[5] / 1000
        bow_circle_inside = values[6] / 1000

        cogz = 0.5 * pin_dia + bow_length_inside / 3  # estimated

        remember = self._scene.current_manager

        self._scene.current_manager = (
            self.manager
        )  # WORK-AROUND : in case the shackle itself is managed, fake management

        self.mass = weight
        self.cog = (0, 0, cogz)

        self._scene.current_manager = self  # register self a manager (as it should)

        self.pin.radius = pin_dia / 2

        self.bow_point.position = (
            0.0,
            0.0,
            0.5 * pin_dia + bow_length_inside + 0.5 * bow_dia,
        )
        self.bow.radius = bow_dia / 2

        self.inside_point.position = (
            0,
            0,
            0.5 * pin_dia + bow_length_inside - 0.5 * bow_circle_inside,
        )
        self.inside.radius = bow_circle_inside / 2

        # determine the scale for the shackle
        # based on a GP800
        #
        actual_size = 0.5 * pin_dia + 0.5 * bow_dia + bow_length_inside
        gp800_size = 0.5 * 0.210 + 0.5 * 0.220 + 0.718

        scale = actual_size / gp800_size

        self.visual_node.scale = [scale, scale, scale]

        self._scene.current_manager = remember

        self._kind = kind

    def managed_nodes(self):
        return [
            self.pin_point,
            self.pin,
            self.bow_point,
            self.bow,
            self.inside_point,
            self.inside,
            self.visual_node,
        ]

    def creates(self, node: Node):
        return node in self.managed_nodes()  # all these are created

    def delete(self):

        # delete created nodes
        a = self.managed_nodes()

        for n in a:
            n._manager = None

        for n in a:
            if n in self._scene._nodes:
                self._scene.delete(n)  # delete if it is still available

    def give_python_code(self):
        code = f&#34;# Exporting {self.name}&#34;

        code += &#34;\n# Create Shackle&#34;
        code += f&#39;\ns.new_shackle(&#34;{self.name}&#34;, kind = &#34;{self.kind}&#34;)&#39;  # , elastic={self.elastic})&#39;

        if self.parent_for_export:
            code += f&#34;\ns[&#39;{self.name}&#39;].parent = s[&#39;{self.parent_for_export.name}&#39;]&#34;

        code += &#34;\ns[&#39;{}&#39;].position = ({},{},{})&#34;.format(self.name, *self.position)
        code += &#34;\ns[&#39;{}&#39;].rotation = ({},{},{})&#34;.format(self.name, *self.rotation)

        return code


# =============== Scene


class Scene:
    &#34;&#34;&#34;
    A Scene is the main component of DAVE.

    It provides a world to place nodes (elements) in.
    It interfaces with the equilibrium core for all calculations.

    By convention a Scene element is created with the name s, but create as many scenes as you want.

    Examples:

        s = Scene()
        s.new_axis(&#39;my_axis&#39;, position = (0,0,1))

        a = Scene() # another world
        a.new_point(&#39;a point&#39;)


    &#34;&#34;&#34;

    def __init__(self, filename=None, copy_from=None, code=None):
        &#34;&#34;&#34;Creates a new Scene

        Args:
            filename: (str or Path) Insert contents from this file into the newly created scene
            copy_from:  (Scene) Copy nodes from this other scene into the newly created scene
        &#34;&#34;&#34;

        count = 0
        if filename:
            count += 1
        if copy_from:
            count += 1
        if code:
            count += 1
        if count &gt; 1:
            raise ValueError(
                &#34;Only one of the named arguments (filename OR copy_from OR code) can be used&#34;
            )

        self.verbose = True
        &#34;&#34;&#34;Report actions using print()&#34;&#34;&#34;

        self._vfc = pyo3d.Scene()
        &#34;&#34;&#34;_vfc : DAVE Core, where the actual magic happens&#34;&#34;&#34;

        self._nodes = []
        &#34;&#34;&#34;Contains a list of all nodes in the scene&#34;&#34;&#34;

        self.static_tolerance = 0.01
        &#34;&#34;&#34;Desired tolerance when solving statics&#34;&#34;&#34;

        self.resources_paths = []
        &#34;&#34;&#34;A list of paths where to look for resources such as .obj files. Priority is given to paths earlier in the list.&#34;&#34;&#34;
        self.resources_paths.extend(vfc.RESOURCE_PATH)

        self._savepoint = None
        &#34;&#34;&#34;Python code to re-create the scene, see savepoint_make()&#34;&#34;&#34;

        self._name_prefix = &#34;&#34;
        &#34;&#34;&#34;An optional prefix to be applied to node names. Used when importing scenes.&#34;&#34;&#34;

        self.current_manager = None
        &#34;&#34;&#34;Setting this to an instance of a Manager allows nodes with that manager to be changed&#34;&#34;&#34;

        self._godmode = False
        &#34;&#34;&#34;Icarus warning, wear proper PPE&#34;&#34;&#34;

        if filename is not None:
            self.load_scene(filename)

        if copy_from is not None:
            self.import_scene(copy_from, containerize=False)

        if code is not None:
            self.run_code(code)

    def clear(self):
        &#34;&#34;&#34;Deletes all nodes&#34;&#34;&#34;

        self._nodes = []
        del self._vfc
        self._vfc = pyo3d.Scene()

    # =========== private functions =============

    def _print_cpp(self):
        print(self._vfc.to_string())

    def _print(self, what):
        if self.verbose:
            print(what)

    def _prefix_name(self, name):
        return self._name_prefix + name

    def _verify_name_available(self, name):
        &#34;&#34;&#34;Throws an error if a node with name &#39;name&#39; already exists&#34;&#34;&#34;
        names = [n.name for n in self._nodes]
        names.extend(self._vfc.names)
        if name in names:
            raise Exception(
                &#34;The name &#39;{}&#39; is already in use. Pick a unique name&#34;.format(name)
            )

    def _node_from_node_or_str(self, node):
        &#34;&#34;&#34;If node is a string, then returns the node with that name,
        if node is a node, then returns that node

        Raises:
            ValueError if a string is passed with an non-existing node
        &#34;&#34;&#34;

        if isinstance(node, Node):
            return node
        if isinstance(node, str):
            return self[node]
        raise ValueError(
            &#34;Node should be a Node or a string, not a {}&#34;.format(type(node))
        )

    def _node_from_node(self, node, reqtype):
        &#34;&#34;&#34;Gets a node from the specified type

        Returns None if node is None
        Returns node if node is already a reqtype type node
        Else returns the axis with the given name

        Raises Exception if a node with name is not found&#34;&#34;&#34;

        if node is None:
            return None

        # node is a string then get the node with this name
        if type(node) == str:
            node = self[self._name_prefix + node]

        reqtype = make_iterable(reqtype)

        for r in reqtype:
            if isinstance(node, r):
                return node

        if issubclass(type(node), Node):
            raise Exception(
                &#34;Element with name {} can not be used , it should be a {} or derived type but is a {}.&#34;.format(
                    node.name, reqtype, type(node)
                )
            )

        raise Exception(&#34;This is not an acceptable input argument {}&#34;.format(node))

    def _parent_from_node(self, node):
        &#34;&#34;&#34;Returns None if node is None
        Returns node if node is an axis type node
        Else returns the axis with the given name

        Raises Exception if a node with name is not found&#34;&#34;&#34;

        return self._node_from_node(node, Axis)

    def _poi_from_node(self, node):
        &#34;&#34;&#34;Returns None if node is None
        Returns node if node is an poi type node
        Else returns the poi with the given name

        Raises Exception if anything is not ok&#34;&#34;&#34;

        return self._node_from_node(node, Point)

    def _poi_or_sheave_from_node(self, node):
        &#34;&#34;&#34;Returns None if node is None
        Returns node if node is an poi type node
        Else returns the poi with the given name

        Raises Exception if anything is not ok&#34;&#34;&#34;

        return self._node_from_node(node, [Point, Circle])

    def _sheave_from_node(self, node):
        &#34;&#34;&#34;Returns None if node is None
        Returns node if node is an poi type node
        Else returns the poi with the given name

        Raises Exception if anything is not ok&#34;&#34;&#34;

        return self._node_from_node(node, Circle)

    def _geometry_changed(self):
        &#34;&#34;&#34;Notify the scene that the geometry has changed and that the global transforms are invalid&#34;&#34;&#34;
        self._vfc.geometry_changed()

    def _fix_vessel_heel_trim(self):
        &#34;&#34;&#34;Fixes the heel and trim of each node that has a buoyancy or linear hydrostatics node attached.

        Returns:
            Dictionary with original fixed properties as dict({&#39;node name&#39;,fixed[6]}) which can be passed to _restore_original_fixes
        &#34;&#34;&#34;

        vessel_indicators = [
            *self.nodes_of_type(Buoyancy),
            *self.nodes_of_type(HydSpring),
        ]
        r = dict()

        for node in vessel_indicators:
            parent = node.parent  # axis

            if parent.fixed[3] and parent.fixed[4]:
                continue  # already fixed

            r[parent.name] = parent.fixed  # store original fixes
            fixed = [*parent.fixed]
            fixed[3] = True
            fixed[4] = True

            # if fixed[3] and fixed[4] are non-zero, then yaw has to be fixed as well.
            # The solver does not support it when an angular dof is free, but one of the fixed
            # angular dofs is non-zero

            fixed[5] = True

            parent.fixed = fixed

        return r

    def _restore_original_fixes(self, original_fixes):
        &#34;&#34;&#34;Restores the fixes as in original_fixes

        See also: _fix_vessel_heel_trim

        Args:
            original_fixes: dict with {&#39;node name&#39;,fixes[6] }

        Returns:
            None

        &#34;&#34;&#34;
        if original_fixes is None:
            return

        for name in original_fixes.keys():
            self.node_by_name(name).fixed = original_fixes[name]

    def _check_and_fix_geometric_contact_orientations(self) -&gt; (bool, str):
        &#34;&#34;&#34;A Geometric pin on pin contact may end up with tension in the contact. Fix that by moving the child pin to the other side of the parent pin

        Returns:
            True if anything was changed; False otherwise
        &#34;&#34;&#34;

        changed = False
        message = &#34;&#34;
        for n in self.nodes_of_type(GeometricContact):
            if not n.inside:

                # connection force of the child is the
                # force applied on the connecting rod
                # in the axis system of the rod
                if n._axis_on_child.connection_force_x &gt; 0:
                    message += f&#34;Changing side of pin-pin connection {n.name} due to tension in connection\n&#34;
                    n.change_side()
                    changed = True

        return (changed, message)

    # ======== resources =========

    def get_resource_path(self, url) -&gt; Path:
        &#34;&#34;&#34;Resolves the path on disk for resource url. Urls statring with res: result in a file from the resources system.

        Looks for a file with &#34;name&#34; in the specified resource-paths and returns the full path to the the first one
        that is found.
        If name is a full path to an existing file, then that is returned.

        See Also:
            resource_paths


        Returns:
            Full path to resource

        Raises:
            FileExistsError if resource is not found

        &#34;&#34;&#34;

        # warning and work-around for backwards compatibility
        # filenames without a path get res: in front of it
        try:
            if isinstance(url, Path):
                test = str(url)
            else:
                test = url

            if not test.startswith(&#34;res:&#34;):
                test = Path(test)
                if str(test.parent) == &#34;.&#34;:
                    # from warnings import warn
                    #
                    # warn(
                    #     f&#39;Resources should start with res: --&gt; fixing &#34;{url}&#34; to &#34;res: {url}&#34;&#39;
                    # )
                    url = &#34;res: &#34; + str(test)
        except:
            pass

        if isinstance(url, Path):
            file = url
        elif isinstance(url, str):
            if not url.startswith(&#34;res:&#34;):
                file = Path(url)
            else:
                # we have a string starting with &#39;res:&#39;
                filename = url[4:].strip()

                for res in self.resources_paths:
                    p = Path(res)

                    file = p / filename
                    if isfile(file):
                        return file

                # prepare feedback for error
                ext = str(url).split(&#34;.&#34;)[-1]  # everything after the last .

                print(&#34;Resource folders:&#34;)
                for res in self.resources_paths:
                    print(str(res))


                print(
                    &#34;The following resources with extension {} are available with &#34;.format(
                        ext
                    )
                )
                available = self.get_resource_list(ext)
                for a in available:
                    print(a)
                raise FileExistsError(
                    &#39;Resource &#34;{}&#34; not found in resource paths. A list with available resources with this extension is printed above this error&#39;.format(
                        url
                    )
                )
        else:
            raise ValueError(
                f&#34;Provided url shall be a Path or a string, not a {type(url)}&#34;
            )

        if file.exists():
            return file

        raise FileExistsError(
            &#39;File &#34;{}&#34; not found.\nHint: To obtain a resource put res: in front of the name.&#39;.format(
                url
            )
        )

    def get_resource_list(self, extension):
        &#34;&#34;&#34;Returns a list of all file-paths (strings) given extension in any of the resource-paths&#34;&#34;&#34;

        r = []

        for dir in self.resources_paths:
            try:
                files = listdir(dir)
                for file in files:
                    if file.lower().endswith(extension):
                        if file not in r:
                            r.append(&#34;res: &#34; + file)
            except FileNotFoundError:
                pass

        return r

    # ======== element functions =========

    def node_by_name(self, node_name, silent=False):
        for N in self._nodes:
            if N.name == node_name:
                return N

        if not silent:
            self.print_node_tree()
        raise ValueError(
            &#39;No node with name &#34;{}&#34;. Available names printed above.&#39;.format(node_name)
        )

    def __getitem__(self, node_name):
        &#34;&#34;&#34;Returns a node with name&#34;&#34;&#34;
        return self.node_by_name(node_name)

    def nodes_of_type(self, node_class):
        &#34;&#34;&#34;Returns all nodes of the specified or derived type

        Examples:
            pois = scene.nodes_of_type(DAVE.Poi)
            axis_and_bodies = scene.nodes_of_type(DAVE.Axis)
        &#34;&#34;&#34;
        r = list()
        for n in self._nodes:
            if isinstance(n, node_class):
                r.append(n)
        return r

    def assert_unique_names(self):
        &#34;&#34;&#34;Asserts that all names are unique&#34;&#34;&#34;
        names = [n.name for n in self._nodes]
        unique_names = set(names)

        if len(unique_names) != len(names):
            previous_name = &#34;&#34;
            names.sort()
            duplicates = &#34;&#34;
            for name in names:
                if name == previous_name:
                    print(f&#34;Duplicate: {name}&#34;)
                    duplicates += name + &#34; &#34;

                    for n in self._nodes:
                        if n.name == name:
                            print(n)

                previous_name = name
            raise ValueError(f&#34;Duplicate names exist: &#34; + duplicates)

    def sort_nodes_by_parent(self):
        &#34;&#34;&#34;Sorts the nodes such that the parent of this node (if any) occurs earlier in the list.

        See Also:
            sort_nodes_by_dependency
        &#34;&#34;&#34;

        self.assert_unique_names()

        exported = []
        to_be_exported = self._nodes.copy()
        counter = 0

        while to_be_exported:

            counter += 1
            if counter &gt; len(self._nodes):
                raise Exception(
                    &#34;Could not sort nodes by dependency, circular references exist?&#34;
                )

            can_be_exported = []

            for node in to_be_exported:

                if hasattr(node, &#34;parent&#34;):
                    parent = node.parent
                    if parent is not None and parent not in exported:
                        continue

                if node.manager is not None and node.manager not in exported:
                    continue

                # otherwise the node can be exported
                can_be_exported.append(node)

            # remove exported nodes from
            for n in can_be_exported:
                to_be_exported.remove(n)

            exported.extend(can_be_exported)

        self._nodes = exported

    def sort_nodes_by_dependency(self):
        &#34;&#34;&#34;Sorts the nodes such that a nodes creation only depends on nodes earlier in the list.

        This sorting is used for node creation order

        See Also:
            sort_nodes_by_parent
        &#34;&#34;&#34;

        self.assert_unique_names()

        exported = []
        to_be_exported = self._nodes.copy()
        counter = 0

        while to_be_exported:

            counter += 1
            if counter &gt; len(self._nodes):

                for node in to_be_exported:
                    print(f&#34;Node : {node.name}&#34;)
                    for d in node.depends_on():
                        print(f&#34;  depends on: {d.name}&#34;)
                    if node._manager:
                        print(f&#34;   managed by: {node._manager.name}&#34;)

                raise Exception(
                    &#34;Could not sort nodes by dependency, circular references exist?&#34;
                )

            can_be_exported = []

            for node in to_be_exported:
                # if node._manager:
                #     if node._manager in exported:
                #         can_be_exported.append(node)
                # el
                if all(el in exported for el in node.depends_on()):
                    can_be_exported.append(node)

            # remove exported nodes from
            for n in can_be_exported:
                to_be_exported.remove(n)

            exported.extend(can_be_exported)

        self._nodes = exported

        # scene_names = [n.name for n in self._nodes]
        #
        # self._vfc.state_update()  # use the function from the core.
        # new_list = []
        # for name in self._vfc.names:  # and then build a new list using the names
        #     if vfc.VF_NAME_SPLIT in name:
        #         continue
        #
        #     if name not in scene_names:
        #         raise Exception(&#39;Something went wrong with sorting the the nodes by dependency. &#39;
        #                         &#39;Node naming between core and scene is inconsistent for node {}&#39;.format(name))
        #
        #     new_list.append(self[name])
        #
        # # and add the nodes without a vfc-core connection
        # for node in self._nodes:
        #     if not node in new_list:
        #         new_list.append(node)
        #
        # self._nodes = new_list

    def name_available(self, name):
        &#34;&#34;&#34;Returns True if the name is still available&#34;&#34;&#34;
        names = [n.name for n in self._nodes]
        names.extend(self._vfc.names)
        return not (name in names)

    def available_name_like(self, like):
        &#34;&#34;&#34;Returns an available name like the one given, for example Axis23&#34;&#34;&#34;
        if self.name_available(like):
            return like
        counter = 1
        while True:
            name = like + &#34;_&#34; + str(counter)
            if self.name_available(name):
                return name
            counter += 1

    def node_A_core_depends_on_B_core(self, A, B):
        &#34;&#34;&#34;Returns True if the node core of node A depends on the core node of node B&#34;&#34;&#34;

        A = self._node_from_node_or_str(A)
        B = self._node_from_node_or_str(B)

        if not isinstance(A, CoreConnectedNode):
            raise ValueError(
                f&#34;{A.name} is not connected to a core node. Dependancies can not be traced using this function&#34;
            )
        if not isinstance(B, CoreConnectedNode):
            raise ValueError(
                f&#34;{B.name} is not connected to a core node. Dependancies can not be traced using this function&#34;
            )

        return self._vfc.element_A_depends_on_B(A._vfNode.name, B._vfNode.name)

    def nodes_managed_by(self, manager : Manager):
        &#34;&#34;&#34;Returns a list of nodes managed by manager&#34;&#34;&#34;

        return [node for node in self._nodes if node.manager == manager]

    def nodes_depending_on(self, node):
        &#34;&#34;&#34;Returns a list of nodes that physically depend on node. Only direct dependants are obtained with a connection to the core.
        This function should be used to determine if a node can be created, deleted, exported.

        For making node-trees please use nodes_with_parent instead.

        Args:
            node : Node or node-name

        Returns:
            list of names

        See Also: nodes_with_parent
        &#34;&#34;&#34;

        if isinstance(node, Node):
            node = node.name

        # check the node type
        _node = self[node]
        if not isinstance(_node, CoreConnectedNode):
            return []
        else:
            names = self._vfc.elements_depending_directly_on(node)

        r = []
        for name in names:
            try:
                node = self.node_by_name(name, silent=True)
                r.append(node.name)
            except:
                pass

        # check all other nodes in the scene

        for n in self._nodes:
            if _node in n.depends_on():
                if n.name not in r:
                    r.append(n.name)

        # for v in [*self.nodes_of_type(Visual), *self.nodes_of_type(WaveInteraction1)]:
        #     if v.parent is _node:
        #         r.append(v.name)

        return r

    def nodes_with_parent(self, node):
        &#34;&#34;&#34;Returns a list of nodes that have given node as a parent. Good for making trees.
        For checking physical connections use nodes_depending_on instead.

        Args:
            node : Node or node-name

        Returns:
            list of names

        See Also: nodes_depending_on
        &#34;&#34;&#34;

        if isinstance(node, str):
            node = self[node]

        r = []

        for n in self._nodes:

            try:
                parent = n.parent
            except AttributeError:
                continue

            if parent == node:
                r.append(n.name)

        return r

    def delete(self, node):
        &#34;&#34;&#34;Deletes the given node from the scene as well as all nodes depending on it.

        See Also:
            dissolve
        &#34;&#34;&#34;

        if isinstance(node, str):
            node = self[node]

        if node not in self._nodes:
            raise ValueError(
                &#34;Can not delete node because it is not a node of this scene&#34;
            )

        if isinstance(node, Manager):
            node.delete()
            # self._nodes.remove(node)
            # return &lt;-- do not return

        depending_nodes = self.nodes_depending_on(node)
        depending_nodes.extend([n.name for n in node.observers])

        if node._manager:  # node, delete its manager
            # print(&#39;Deleting manager&#39;)
            self.delete(node._manager)
            if node in self._nodes:
                self.delete(node)  # node may have been deleted by the manager

        else:
            self._print(
                &#34;Deleting {} [{}]&#34;.format(
                    node.name, str(type(node)).split(&#34;.&#34;)[-1][:-2]
                )
            )

            # First delete the dependencies
            for d in depending_nodes:
                if not self.name_available(d):  # element is still here
                    self.delete(d)

            # then remove the vtk node itself
            # self._print(&#39;removing vfc node&#39;)
            node._delete_vfc()
            self._nodes.remove(node)

    def dissolve(self, node):
        &#34;&#34;&#34;Attempts to delete the given node without affecting the rest of the model.

        1. Look for nodes that have this node as parent
        2. Attach those nodes to the parent of this node.
        3. Delete this node.

        There are many situations in which this will fail because an it is impossible to dissolve
        the element. For example a poi can only be dissolved when nothing is attached to it.

        For now this function only works on AXIS

        #TODO: Add managers - just release management

        &#34;&#34;&#34;

        if isinstance(node, str):
            node = self[node]

        ok = False
        if isinstance(node, Manager):

            if isinstance(node, Axis):
                p = self.new_axis(node.name + &#39;_dissolved&#39;)
            else:
                p = None

            for d in self.nodes_managed_by(node):
                with ClaimManagement(self,node):
                    if node in d.observers:
                        d.observers.remove(node)
                    d.manager = None

                    if isinstance(d, NodeWithParent):
                        if d.parent == node:
                            d.parent = p

            ok = True

        if isinstance(node, Axis):
            for d in self.nodes_depending_on(node):
                self[d].change_parent_to(node.parent)
            ok = True

        if not ok:
            raise TypeError(&#34;Only nodes of type Axis and Manager can be dissolved at this moment&#34;)

        self._nodes.remove(node)  # do not call delete as that will fail on managers

    def savepoint_make(self):
        self._savepoint = self.give_python_code()

    def savepoint_restore(self):
        if self._savepoint is not None:
            self.clear()
            exec(self._savepoint, {}, {&#34;s&#34;: self})
            self._savepoint = None
            return True
        else:
            return False

    # ========= The most important functions ========

    def update(self):
        &#34;&#34;&#34;Updates the interface between the nodes and the core. This includes the re-calculation of all forces,
        buoyancy positions, ballast-system cogs etc.
        &#34;&#34;&#34;
        for n in self._nodes:
            n.update()
        self._vfc.state_update()

    def solve_statics(self, silent=False, timeout=None):
        &#34;&#34;&#34;Solves statics

        Args:
            silent: Do not print if successfully solved

        Returns:
            bool: True if successful, False otherwise.

        &#34;&#34;&#34;
        self.update()

        if timeout is None:
            solve_func = self._vfc.state_solve_statics
        else:
            #       bool doStabilityCheck,
            #       double timeout,
            #           bool do_prepare_state,
            #           bool solve_linear_dofs_first,
            #           double stability_check_delta
            solve_func = lambda: self._vfc.state_solve_statics_with_timeout(
                True, timeout, True, True, 0
            )  # default stability value

        # pass 1
        orignal_fixes = self._fix_vessel_heel_trim()
        succes = solve_func()
        if not succes:
            self._restore_original_fixes(orignal_fixes)
            return False

        if orignal_fixes:
            # pass 2
            self._restore_original_fixes(orignal_fixes)
            succes = solve_func()

        if self.verify_equilibrium():

            changed, message = self._check_and_fix_geometric_contact_orientations()
            if changed:
                print(message)
                solve_func()
                if not self.verify_equilibrium():
                    return False

            if not silent:
                self._print(&#34;Solved to {}.&#34;.format(self._vfc.Emaxabs))
            return True

        d = np.array(self._vfc.get_dofs())
        if np.any(np.abs(d) &gt; 2000):
            print(
                &#34;Error: One of the degrees of freedom exceeded the boundary of 2000 [m]/[rad].&#34;
            )
            return False

        return False

    def verify_equilibrium(self, tol=1e-2):
        &#34;&#34;&#34;Checks if the current state is an equilibrium

        Returns:
            bool: True if successful, False if not an equilibrium.

        &#34;&#34;&#34;
        self.update()
        return self._vfc.Emaxabs &lt; tol

    # ====== goal seek ========

    def goal_seek(
        self, evaluate, target, change_node, change_property, bracket=None, tol=1e-3
    ):
        &#34;&#34;&#34;goal_seek

        Goal seek is the classic goal-seek. It changes a single property of a single node in order to get
        some property of some node to a specified value. Just like excel.

        Args:
            evaluate : code to be evaluated to yield the value that is solved for. Eg: s[&#39;poi&#39;].fx Scene is abbiviated as &#34;s&#34;
            target (number):       target value for that property
            change_node(Node or str):  node to be adjusted
            change_property (str): property of that node to be adjusted
            range(optional)  : specify the possible search-interval

        Returns:
            bool: True if successful, False otherwise.

        Examples:
            Change the y-position of the cog of a rigid body (&#39;Barge&#39;)  in order to obtain zero roll (rx)
            &gt;&gt;&gt; s.goal_seek(&#34;s[&#39;Barge&#39;].fx&#34;,0,&#39;Barge&#39;,&#39;cogy&#39;)

        &#34;&#34;&#34;
        s = self

        change_node = self._node_from_node_or_str(change_node)

        # check that the attributes exist and are single numbers
        test = eval(evaluate)

        try:
            float(test)
        except:
            raise ValueError(&#34;Evaluation of {} does not result in a float&#34;)

        self._print(
            &#34;Attempting to evaluate {} to {} (now {})&#34;.format(evaluate, target, test)
        )

        initial = getattr(change_node, change_property)
        self._print(
            &#34;By changing the value of {}.{} (now {})&#34;.format(
                change_node.name, change_property, initial
            )
        )

        def set_and_get(x):
            setattr(change_node, change_property, x)
            self.solve_statics(silent=True)
            s = self
            result = eval(evaluate)
            self._print(&#34;setting {} results in {}&#34;.format(x, result))
            return result - target

        from scipy.optimize import root_scalar

        x0 = initial
        x1 = initial + 0.0001

        if bracket is not None:
            res = root_scalar(set_and_get, x0=x0, x1=x1, bracket=bracket, xtol=tol)
        else:
            res = root_scalar(set_and_get, x0=x0, x1=x1, xtol=tol)

        self._print(res)

        # evaluate result
        final_value = eval(evaluate)
        if abs(final_value - target) &gt; 1e-3:
            raise ValueError(
                &#34;Target not reached. Target was {}, reached value is {}&#34;.format(
                    target, final_value
                )
            )

        return True

    def plot_effect(self, evaluate, change_node, change_property, start, to, steps):
        &#34;&#34;&#34;Produces a 2D plot with the relation between two properties of the scene. For example the length of a cable
        versus the force in another cable.

        The evaluate argument is processed using &#34;eval&#34; and may contain python code. This may be used to combine multiple
        properties to one value. For example calculate the diagonal load distribution from four independent loads.

        The plot is produced using matplotlob. The plot is produced in the current figure (if any) and plt.show is not executed.

        Args:
            evaluate (str): code to be evaluated to yield the value on the y-axis. Eg: s[&#39;poi&#39;].fx Scene is abbiviated as &#34;s&#34;
            change_node(Node or str):  node to be adjusted
            change_property (str): property of that node to be adjusted
            start : left side of the interval
            to : right side of the interval
            steps : number of steps in the interval

        Returns:
            Tuple (x,y) with x and y coordinates

        Examples:
            &gt;&gt;&gt; s.plot_effect(&#34;s[&#39;cable&#39;].tension&#34;, &#34;cable&#34;, &#34;length&#34;, 11, 14, 10)
            &gt;&gt;&gt; import matplotlib.pyplot as plt
            &gt;&gt;&gt; plt.show()

        &#34;&#34;&#34;
        s = self
        change_node = self._node_from_node_or_str(change_node)

        # check that the attributes exist and are single numbers
        test = eval(evaluate)

        try:
            float(test)
        except:
            raise ValueError(&#34;Evaluation of {} does not result in a float&#34;)

        def set_and_get(x):
            setattr(change_node, change_property, x)
            self.solve_statics(silent=True)
            s = self
            result = eval(evaluate)
            self._print(&#34;setting {} results in {}&#34;.format(x, result))
            return result

        xs = np.linspace(start, to, steps)
        y = []
        for x in xs:
            y.append(set_and_get(x))

        y = np.array(y)
        import matplotlib.pyplot as plt

        plt.plot(xs, y)
        plt.xlabel(&#34;{} of {}&#34;.format(change_property, change_node.name))
        plt.ylabel(evaluate)

        return (xs, y)

    # ======== create functions =========

    def new_axis(
        self,
        name,
        parent=None,
        position=None,
        rotation=None,
        inertia=None,
        inertia_radii=None,
        fixed=True,
    ) -&gt; Axis:
        &#34;&#34;&#34;Creates a new *axis* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: optional, name of the parent of the node
            position: optional, position for the node (x,y,z)
            rotation: optional, rotation for the node (rx,ry,rz)
            fixed [True]: optional, determines whether the axis is fixed [True] or free [False]. May also be a sequence of 6 booleans.

        Returns:
            Reference to newly created axis

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if position is not None:
            assert3f(position, &#34;Position &#34;)
        if rotation is not None:
            assert3f(rotation, &#34;Rotation &#34;)

        if inertia is not None:
            assert1f_positive_or_zero(inertia, &#34;inertia &#34;)

        if inertia_radii is not None:
            assert3f_positive(inertia_radii, &#34;Radii of inertia&#34;)
            assert inertia is not None, ValueError(
                &#34;Can not set radii of gyration without specifying inertia&#34;
            )

        if not isinstance(fixed, bool):
            if len(fixed) != 6:
                raise Exception(
                    &#39;&#34;fixed&#34; parameter should either be True/False or a 6x bool sequence such as (True,True,False,False,True,False)&#39;
                )

        # then create
        a = self._vfc.new_axis(name)

        new_node = Axis(self, a)

        # and set properties
        if b is not None:
            new_node.parent = b
        if position is not None:
            new_node.position = position
        if rotation is not None:
            new_node.rotation = rotation
        if inertia is not None:
            new_node.inertia = inertia
        if inertia_radii is not None:
            new_node.inertia_radii = inertia_radii

        if isinstance(fixed, bool):
            if fixed:
                new_node.set_fixed()
            else:
                new_node.set_free()
        else:
            new_node.fixed = fixed

        self._nodes.append(new_node)
        return new_node

    def new_geometriccontact(
        self,
        name,
        child,
        parent,
        inside=False,
        swivel=None,
        rotation_on_parent=None,
        child_rotation=None,
        swivel_fixed=True,
        fixed_to_parent=False,
        child_fixed=False,
    ) -&gt; GeometricContact:
        &#34;&#34;&#34;Creates a new *new_geometriccontact* node and adds it to the scene.

        Geometric contact connects two circular elements and can be used to model bar-bar connections or pin-in-hole connections.

        By default a bar-bar connection is created between item1 and item2.

        Args:
            name: Name for the node, should be unique
            child : [Sheave] will be the nodeA of the connection
            parent : [Sheave] will be the nodeB of the connection
            inside: [False] False creates a pinpin connection. True creates a pin-hole type of connection
            swivel: Rotation angle between the two items. Defaults to 90 for pinpin and 0 for pin-hole
            rotation_on_parent: Angle of the connecting hinge relative to nodeA or None for default
            child_rotation: Angle of the nodeB relative to the connecting hinge or None for default
            swivel_fixed: Fix swivel [True]
            fixed_to_parent: Fix connecting hinge to nodeA [False]
            child_fixed: Fix nodeB to connecting hinge [False]

        Note:
            For pin-hole connections there is no geometrical difference between the pin and the hole. Therefore it is not needed to specify
            which is the pin and which is the hole

        Returns:
            Reference to newly created new_geometriccontact

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)

        name_prefix = name + vfc.MANAGED_NODE_IDENTIFIER
        postfixes = [
            &#34;_axis_on_parent&#34;,
            &#34;_pin_hole_connection&#34;,
            &#34;_axis_on_child&#34;,
            &#34;_connection_axial_rotation&#34;,
        ]

        for pf in postfixes:
            self._verify_name_available(name_prefix + pf)

        child = self._sheave_from_node(child)
        parent = self._sheave_from_node(parent)

        assertBool(inside, &#34;inside&#34;)
        assertBool(swivel_fixed, &#34;swivel_fixed&#34;)
        assertBool(fixed_to_parent, &#34;fixed_to_parent&#34;)
        assertBool(child_fixed, &#34;child_fixed&#34;)

        GeometricContact._assert_parent_child_possible(parent, child)

        if swivel is None:
            if inside:
                swivel = 0
            else:
                swivel = 90

        assert1f(swivel, &#34;swivel_angle&#34;)

        if rotation_on_parent is not None:
            assert1f(rotation_on_parent, &#34;rotation_on_parent should be either None or &#34;)
        if child_rotation is not None:
            assert1f(child_rotation, &#34;child_rotation should be either None or &#34;)

        if child is None:
            raise ValueError(&#34;child needs to be a sheave-type node&#34;)
        if parent is None:
            raise ValueError(&#34;parent needs to be a sheave-type node&#34;)

        if child.parent.parent is None:
            raise ValueError(
                f&#34;The parent {child.parent.name} of the child item {child.name} is not located on an axis. Can not create the connection because there is no axis to nodeB&#34;
            )

        if child.parent.parent.manager is not None:
            self.print_node_tree()
            raise ValueError(
                f&#34;The axis or body that {child.name} is on is already managed by {child.parent.parent.manager.name} and can therefore not be changed - unable to create geometric contact&#34;
            )

        new_node = GeometricContact(self, child, parent, name)
        if inside:
            new_node.set_pin_in_hole_connection()
        else:
            new_node.set_pin_pin_connection()

        new_node.swivel = swivel
        if rotation_on_parent is not None:
            new_node.rotation_on_parent = rotation_on_parent
        if child_rotation is not None:
            new_node.child_rotation = child_rotation

        new_node.fixed_to_parent = fixed_to_parent
        new_node.child_fixed = child_fixed
        new_node.swivel_fixed = swivel_fixed

        self._nodes.append(new_node)
        return new_node

    def new_waveinteraction(
        self,
        name,
        path,
        parent=None,
        offset=None,
    ) -&gt; WaveInteraction1:
        &#34;&#34;&#34;Creates a new *wave interaction* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            path: Path to the hydrodynamic database
            parent: optional, name of the parent of the node
            offset: optional, position for the node (x,y,z)

        Returns:
            Reference to newly created wave-interaction object

        &#34;&#34;&#34;

        if not parent:
            raise ValueError(&#34;Wave-interaction has to be located on an Axis&#34;)

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if b is None:
            raise ValueError(&#34;Wave-interaction has to be located on an Axis&#34;)

        if offset is not None:
            assert3f(offset, &#34;Offset &#34;)

        self.get_resource_path(path)  # raises error when resource is not found

        # then create

        new_node = WaveInteraction1(self)

        new_node.name = name
        new_node.path = path
        new_node.parent = parent

        # and set properties
        new_node.parent = b
        if offset is not None:
            new_node.offset = offset

        self._nodes.append(new_node)
        return new_node

    def new_visual(
        self, name, path, parent=None, offset=None, rotation=None, scale=None
    ) -&gt; Visual:
        &#34;&#34;&#34;Creates a new *Visual* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            path: Path to the resource
            parent: optional, name of the parent of the node
            offset: optional, position for the node (x,y,z)
            rotation: optional, rotation for the node (rx,ry,rz)
            scale : optional, scale of the visual (x,y,z).

        Returns:
            Reference to newly created visual

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if offset is not None:
            assert3f(offset, &#34;Offset &#34;)
        if rotation is not None:
            assert3f(rotation, &#34;Rotation &#34;)

        self.get_resource_path(path)  # raises error when resource is not found

        # then create

        new_node = Visual(self)

        new_node.name = name
        new_node.path = path
        new_node.parent = parent

        # and set properties
        if b is not None:
            new_node.parent = b
        if offset is not None:
            new_node.offset = offset
        if rotation is not None:
            new_node.rotation = rotation
        if scale is not None:
            new_node.scale = scale

        self._nodes.append(new_node)
        return new_node

    def new_point(self, name, parent=None, position=None) -&gt; Point:
        &#34;&#34;&#34;Creates a new *poi* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: optional, name of the parent of the node
            position: optional, position for the node (x,y,z)


        Returns:
            Reference to newly created poi

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if position is not None:
            assert3f(position, &#34;Position &#34;)

        # then create
        a = self._vfc.new_poi(name)

        new_node = Point(self, a)

        # and set properties
        if b is not None:
            new_node.parent = b
        if position is not None:
            new_node.position = position

        self._nodes.append(new_node)
        return new_node

    def new_rigidbody(
        self,
        name,
        mass=0,
        cog=(0, 0, 0),
        parent=None,
        position=None,
        rotation=None,
        inertia_radii=None,
        fixed=True,
    ) -&gt; RigidBody:
        &#34;&#34;&#34;Creates a new *rigidbody* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            mass: optional, [0] mass in mT
            cog: optional, (0,0,0) cog-position in (m,m,m)
            parent: optional, name of the parent of the node
            position: optional, position for the node (x,y,z)
            rotation: optional, rotation for the node (rx,ry,rz)
            inertia_radii : optional, radii of gyration (rxx,ryy,rzz); only used for dynamics
            fixed [True]: optional, determines whether the axis is fixed [True] or free [False]. May also be a sequence of 6 booleans.

        Examples:
            scene.new_rigidbody(&#34;heavy_thing&#34;, mass = 10000, cog = (1.45, 0, -0.7))

        Returns:
            Reference to newly created RigidBody

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # check input
        assertValidName(name)
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if position is not None:
            assert3f(position, &#34;Position &#34;)
        if rotation is not None:
            assert3f(rotation, &#34;Rotation &#34;)

        if inertia_radii is not None:
            assert3f_positive(inertia_radii, &#34;Radii of inertia&#34;)
            assert mass &gt; 0, ValueError(
                &#34;Can not set radii of gyration without specifying mass&#34;
            )

        if not isinstance(fixed, bool):
            if len(fixed) != 6:
                raise Exception(
                    &#39;&#34;fixed&#34; parameter should either be True/False or a 6x bool sequence such as (True,True,False,False,True,False)&#39;
                )

        # make elements

        a = self._vfc.new_axis(name)

        p = self._vfc.new_poi(name + vfc.VF_NAME_SPLIT + &#34;cog&#34;)
        p.parent = a
        p.position = cog

        g = self._vfc.new_force(name + vfc.VF_NAME_SPLIT + &#34;gravity&#34;)
        g.parent = p
        g.force = (0, 0, -vfc.G * mass)

        r = RigidBody(self, a, p, g)

        r.cog = cog  # set inertia
        r.mass = mass

        # and set properties
        if b is not None:
            r.parent = b
        if position is not None:
            r.position = position
        if rotation is not None:
            r.rotation = rotation

        if inertia_radii is not None:
            r.inertia_radii = inertia_radii

        if isinstance(fixed, bool):
            if fixed:
                r.set_fixed()
            else:
                r.set_free()
        else:
            r.fixed = fixed

        self._nodes.append(r)
        return r

    def new_cable(
        self, name, endA, endB, length=-1, EA=0, diameter=0, sheaves=None
    ) -&gt; Cable:
        &#34;&#34;&#34;Creates a new *cable* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            endA : A Poi element to connect the first end of the cable to
            endB : A Poi element to connect the other end of the cable to
            length [-1] : un-stretched length of the cable in m; default [-1] create a cable with the current distance between the endpoints A and B
            EA [0] : stiffness of the cable in kN/m; default

            sheaves : [optional] A list of pois, these are sheaves that the cable runs over. Defined from endA to endB

        Examples:

            scene.new_cable(&#39;cable_name&#39; endA=&#39;poi_start&#39;, endB = &#39;poi_end&#39;)  # minimal use

            scene.new_cable(&#39;cable_name&#39;, length=50, EA=1000, endA=poi_start, endB = poi_end, sheaves=[sheave1, sheave2])

            scene.new_cable(&#39;cable_name&#39;, length=50, EA=1000, endA=&#39;poi_start&#39;, endB = &#39;poi_end&#39;, sheaves=[&#39;single_sheave&#39;]) # also a single sheave needs to be provided as a list

        Notes:
            The default options for length and EA can be used to measure distances between points

        Returns:
            Reference to newly created Cable

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        assert1f(length, &#34;length&#34;)
        assert1f(EA, &#34;EA&#34;)

        endA = self._poi_or_sheave_from_node(endA)
        endB = self._poi_or_sheave_from_node(endB)

        pois = [endA]
        if sheaves is not None:

            if isinstance(sheaves, Point):  # single sheave as poi or string
                sheaves = [sheaves]

            if isinstance(sheaves, Circle):  # single sheave as poi or string
                sheaves = [sheaves]

            if isinstance(sheaves, str):
                sheaves = [sheaves]

            for s in sheaves:
                # s may be a poi or a sheave
                pois.append(self._poi_or_sheave_from_node(s))

        pois.append(endB)

        # default options
        if length &gt; -1:
            if length &lt; 1e-9:
                raise Exception(&#34;Length should be more than 0&#34;)

        if EA &lt; 0:
            raise Exception(&#34;EA should be more than 0&#34;)

        assert1f(diameter, &#34;Diameter should be a number &gt;= 0&#34;)

        if diameter &lt; 0:
            raise Exception(&#34;Diameter should be &gt;= 0&#34;)

        # then create
        a = self._vfc.new_cable(name)
        new_node = Cable(self, a)
        if length &gt; 0:
            new_node.length = length
        new_node.EA = EA
        new_node.diameter = diameter

        new_node.connections = pois

        # and add to the scene
        self._nodes.append(new_node)

        if length &lt; 0:
            new_node.length = 1e-8
            self._vfc.state_update()

            new_length = new_node.stretch + 1e-8

            if new_length &gt; 0:
                new_node.length = new_length
            else:
                # is is possible that all nodes are at the same location which means the total length becomes 0
                self.delete(new_node.name)
                raise ValueError(
                    &#34;No lengh has been supplied and all connection points are at the same location - unable to determine a non-zero default length. Please supply a length&#34;
                )

        return new_node

    def new_force(self, name, parent=None, force=None, moment=None) -&gt; Force:
        &#34;&#34;&#34;Creates a new *force* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: name of the parent of the node [Poi]
            force: optional, global force on the node (x,y,z)
            moment: optional, global force on the node (x,y,z)


        Returns:
            Reference to newly created force

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._poi_from_node(parent)

        if force is not None:
            assert3f(force, &#34;Force &#34;)

        if moment is not None:
            assert3f(moment, &#34;Moment &#34;)

        # then create
        a = self._vfc.new_force(name)

        new_node = Force(self, a)

        # and set properties
        if b is not None:
            new_node.parent = b
        if force is not None:
            new_node.force = force
        if moment is not None:
            new_node.moment = moment

        self._nodes.append(new_node)
        return new_node

    def new_circle(self, name, parent, axis, radius=0.0) -&gt; Circle:
        &#34;&#34;&#34;Creates a new *sheave* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: name of the parent of the node [Poi]
            axis: direction of the axis of rotation (x,y,z)
            radius: optional, radius of the sheave


        Returns:
            Reference to newly created sheave

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._poi_from_node(parent)

        assert3f(axis, &#34;Axis of rotation &#34;)

        assert1f(radius, &#34;Radius of sheave&#34;)

        # then create
        a = self._vfc.new_sheave(name)

        new_node = Circle(self, a)

        # and set properties
        new_node.parent = b
        new_node.axis = axis
        new_node.radius = radius

        self._nodes.append(new_node)
        return new_node

    def new_hydspring(
        self,
        name,
        parent,
        cob,
        BMT,
        BML,
        COFX,
        COFY,
        kHeave,
        waterline,
        displacement_kN,
    ) -&gt; HydSpring:
        &#34;&#34;&#34;Creates a new *hydspring* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: name of the parent of the node [Axis]
            cob: position of the CoB (x,y,z) in the parent axis system
            BMT: Vertical distance between CoB and meta-center for roll
            BML: Vertical distance between CoB and meta-center for pitch
            COFX: X-location of center of flotation (center of waterplane) relative to CoB
            COFY: Y-location of center of flotation (center of waterplane) relative to CoB
            kHeave : heave stiffness (typically Awl * rho * g)
            waterline : Z-position (elevation) of the waterline relative to CoB
            displacement_kN : displacement (typically volume * rho * g)


        Returns:
            Reference to newly created hydrostatic spring

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._parent_from_node(parent)
        assert3f(cob, &#34;CoB &#34;)
        assert1f(BMT, &#34;BMT &#34;)
        assert1f(BML, &#34;BML &#34;)
        assert1f(COFX, &#34;COFX &#34;)
        assert1f(COFY, &#34;COFY &#34;)
        assert1f(kHeave, &#34;kHeave &#34;)
        assert1f(waterline, &#34;waterline &#34;)
        assert1f(displacement_kN, &#34;displacement_kN &#34;)

        # then create
        a = self._vfc.new_hydspring(name)
        new_node = HydSpring(self, a)

        new_node.cob = cob
        new_node.parent = b
        new_node.BMT = BMT
        new_node.BML = BML
        new_node.COFX = COFX
        new_node.COFY = COFY
        new_node.kHeave = kHeave
        new_node.waterline = waterline
        new_node.displacement_kN = displacement_kN

        self._nodes.append(new_node)

        return new_node

    def new_linear_connector_6d(self, name, main, secondary, stiffness=None) -&gt; LC6d:
        &#34;&#34;&#34;Creates a new *linear connector 6d* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            main: Main axis system [Axis]
            secondary: Secondary axis system [Axis]
            stiffness: optional, connection stiffness (x,y,z, rx,ry,rz)

        See :py:class:`LC6d` for details

        Returns:
            Reference to newly created connector

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        m = self._parent_from_node(secondary)
        s = self._parent_from_node(main)

        if stiffness is not None:
            assert6f(stiffness, &#34;Stiffness &#34;)
        else:
            stiffness = (0, 0, 0, 0, 0, 0)

        # then create
        a = self._vfc.new_linearconnector6d(name)

        new_node = LC6d(self, a)

        # and set properties
        new_node.main = m
        new_node.secondary = s
        new_node.stiffness = stiffness

        self._nodes.append(new_node)
        return new_node

    def new_connector2d(
        self, name, nodeA, nodeB, k_linear=0, k_angular=0
    ) -&gt; Connector2d:
        &#34;&#34;&#34;Creates a new *new_connector2d* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            nodeB: First axis system [Axis]
            nodeA: Second axis system [Axis]

            k_linear : linear stiffness in kN/m
            k_angular : angular stiffness in kN*m / rad

        Returns:
            Reference to newly created connector2d

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        m = self._parent_from_node(nodeA)
        s = self._parent_from_node(nodeB)

        assert1f(k_linear, &#34;Linear stiffness&#34;)
        assert1f(k_angular, &#34;Angular stiffness&#34;)

        # then create
        a = self._vfc.new_connector2d(name)

        new_node = Connector2d(self, a)

        # and set properties
        new_node.nodeA = m
        new_node.nodeB = s
        new_node.k_linear = k_linear
        new_node.k_angular = k_angular

        self._nodes.append(new_node)
        return new_node

    def new_beam(
        self,
        name,
        nodeA,
        nodeB,
        EIy=0,
        EIz=0,
        GIp=0,
        EA=0,
        L=None,
        mass=0,
        n_segments=1,
        tension_only=False,
    ) -&gt; Beam:
        &#34;&#34;&#34;Creates a new *beam* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            nodeA: First axis system [Axis]
            nodeB: Second axis system [Axis]

            All stiffness terms default to 0
            The length defaults to the distance between nodeA and nodeB


        See :py:class:`LinearBeam` for details

        Returns:
            Reference to newly created beam

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        m = self._parent_from_node(nodeA)
        s = self._parent_from_node(nodeB)

        if L is None:
            L = np.linalg.norm(
                np.array(m.global_position) - np.array(s.global_position)
            )
        else:
            if L &lt;= 0:
                raise ValueError(&#34;L should be &gt; 0 as stiffness is defined per length.&#34;)

        assert1f_positive_or_zero(EIy, &#34;EIy should be &gt;= 0&#34;)
        assert1f_positive_or_zero(EIz, &#34;EIz should be &gt;= 0&#34;)
        assert1f_positive_or_zero(GIp, &#34;GIp should be &gt;= 0&#34;)
        assert1f_positive_or_zero(EA, &#34;EA should be &gt;= 0&#34;)
        assertBool(tension_only, &#34;tension_only should be bool&#34;)
        assert1f(mass, &#34;Mass shall be a number&#34;)
        n_segments = int(round(n_segments))

        # then create
        a = self._vfc.new_linearbeam(name)

        new_node = Beam(self, a)

        # and set properties
        new_node.nodeA = m
        new_node.nodeB = s
        new_node.EIy = EIy
        new_node.EIz = EIz
        new_node.GIp = GIp
        new_node.EA = EA
        new_node.L = L
        new_node.mass = mass
        new_node.n_segments = n_segments
        new_node.tension_only = tension_only

        self._nodes.append(new_node)
        return new_node

    def new_buoyancy(self, name, parent=None, density=1.025) -&gt; Buoyancy:
        &#34;&#34;&#34;Creates a new *buoyancy* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: optional, name of the parent of the node


        Returns:
            Reference to newly created buoyancy

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if b is None:
            raise ValueError(&#34;A valid parent must be defined for a Buoyancy node&#34;)

        assert1f_positive_or_zero(density, &#34;density&#34;)

        # then create
        a = self._vfc.new_buoyancy(name)
        new_node = Buoyancy(self, a)

        # and set properties
        if b is not None:
            new_node.parent = b

        new_node.density = density

        self._nodes.append(new_node)
        return new_node

    def new_tank(self, name, parent=None, density=1.025, free_flooding=False) -&gt; Tank:
        &#34;&#34;&#34;Creates a new *tank* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: optional, name of the parent of the node

        Returns:
            Reference to newly created Tank

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if b is None:
            raise ValueError(&#34;A valid parent must be defined for a Tank&#34;)

        assert isinstance(free_flooding, bool), ValueError(
            &#34;free_flooding shall be True or False&#34;
        )

        assert1f(density, &#34;density&#34;)

        # then create
        a = self._vfc.new_tank(name)
        new_node = Tank(self, a)
        new_node.density = density

        # and set properties
        if b is not None:
            new_node.parent = b

        new_node.free_flooding = free_flooding

        self._nodes.append(new_node)
        return new_node

    def new_contactmesh(self, name, parent=None) -&gt; ContactMesh:
        &#34;&#34;&#34;Creates a new *contactmesh* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: optional, name of the parent of the node

        Returns:
            Reference to newly created contact mesh

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        # then create
        a = self._vfc.new_contactmesh(name)
        new_node = ContactMesh(self, a)

        # and set properties
        if b is not None:
            new_node.parent = b

        self._nodes.append(new_node)
        return new_node

    def new_spmt(
        self,
        name,
        parent,
        maximal_length=1.8,
        nominal_length=1.5,
        k=1e6,
        meshes=None,
        axles=None,
    ) -&gt; SPMT:
        &#34;&#34;&#34;Creates a new *SPMT* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: name of the parent of the node [Axis]
            maximal_length: optional, maximum distance between top and bottom of wheel (1.5m + 300mm)
            nominal_length: optional, nominal distance between top and bottom of wheel [1.5m]
            k : stiffness per axle [kN/m]
            meshes : list of contact meshes
            axles  : list of axle locations [(x,y,z),(x,y,z), ... ]

        Returns:
            Reference to newly created SPMT

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        parent = self._node_from_node_or_str(parent)
        assert isinstance(parent, Axis), ValueError(
            f&#34;Parent should be an axis system or derived, not a {type(parent)}&#34;
        )

        assert1f_positive_or_zero(maximal_length, &#34;maximal_length &#34;)
        assert1f_positive_or_zero(nominal_length, &#34;nominal_length &#34;)

        if meshes is not None:
            meshes = make_iterable(meshes)
            for mesh in meshes:
                test = self._node_from_node(
                    mesh, ContactMesh
                )  # throws error if not found

        if axles is not None:
            for p in axles:
                assert3f(p, &#34;axle locations should be (x,y,z)&#34;)

        # then create
        a = self._vfc.new_spmt(name)

        new_node = SPMT(self, a)

        # and set properties
        new_node.parent = parent
        new_node.k = k
        new_node.max_length = maximal_length
        new_node.nominal_length = nominal_length

        if meshes is not None:
            new_node.meshes = meshes

        if axles is not None:
            new_node.axles = axles

        self._nodes.append(new_node)
        return new_node

    def new_contactball(
        self, name, parent=None, radius=1, k=9999, meshes=None
    ) -&gt; ContactBall:
        &#34;&#34;&#34;Creates a new *force* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: name of the parent of the node [Poi]
            force: optional, global force on the node (x,y,z)
            moment: optional, global force on the node (x,y,z)


        Returns:
            Reference to newly created force

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._poi_from_node(parent)

        assert1f_positive_or_zero(radius, &#34;Radius &#34;)
        assert1f_positive_or_zero(k, &#34;k &#34;)

        if meshes is not None:
            meshes = make_iterable(meshes)
            for mesh in meshes:
                test = self._node_from_node(mesh, ContactMesh)

        # then create
        a = self._vfc.new_contactball(name)

        new_node = ContactBall(self, a)

        # and set properties
        if b is not None:
            new_node.parent = b
        if k is not None:
            new_node.k = k
        if radius is not None:
            new_node.radius = radius

        if meshes is not None:
            new_node.meshes = meshes

        self._nodes.append(new_node)
        return new_node

    def new_ballastsystem(self, name, parent: Axis) -&gt; BallastSystem:
        &#34;&#34;&#34;Creates a new *rigidbody* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: name of the parent of the ballast system (ie: the vessel axis system)

        Examples:
            scene.new_ballastsystem(&#34;cheetah_ballast&#34;, parent=&#34;Cheetah&#34;)

        Returns:
            Reference to newly created BallastSystem

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # check input
        assertValidName(name)
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        parent = self._parent_from_node(parent)  # handles verification of type as well

        # make elements
        r = BallastSystem(self, parent)
        r.name = name

        self._nodes.append(r)
        return r

    def new_sling(
        self,
        name,
        length=-1,
        EA=1.0,
        mass=0.1,
        endA=None,
        endB=None,
        LeyeA=None,
        LeyeB=None,
        LspliceA=None,
        LspliceB=None,
        diameter=0.1,
        sheaves=None,
    ) -&gt; Sling:
        &#34;&#34;&#34;
        Creates a new sling, adds it to the scene and returns a reference to the newly created object.

        See Also:
            Sling

        Args:
            name:    name
            length:  length of the sling [m], defaults to distance between endpoints
            EA:      stiffness in kN, default: 1.0 (note: equilibrium will fail if mass &gt;0 and EA=0)
            mass:    mass in mT, default  0.1
            endA:    element to connect end A to [poi, circle]
            endB:    element to connect end B to [poi, circle]
            LeyeA:   inside eye on side A length [m], defaults to 1/6th of length
            LeyeB:   inside eye on side B length [m], defaults to 1/6th of length
            LspliceA: splice length on side A [m] (the part where the cable is connected to itself)
            LspliceB: splice length on side B [m] (the part where the cable is connected to itself)
            diameter: cable diameter in m, defaul to 0.1
            sheaves:  optional: list of sheaves/pois that the sling runs over

        Returns:
            a reference to the newly created Sling object.

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)

        name_prefix = name + vfc.MANAGED_NODE_IDENTIFIER
        postfixes = [
            &#34;_spliceA&#34;,
            &#34;_spliceA&#34;,
            &#34;_spliceA2&#34;,
            &#34;_spliceAM&#34;,
            &#34;_spliceA_visual&#34;,
            &#34;spliceB&#34;,
            &#34;_spliceB1&#34;,
            &#34;_spliceB2&#34;,
            &#34;_spliceBM&#34;,
            &#34;_spliceB_visual&#34;,
            &#34;_main_part&#34;,
            &#34;_eyeA&#34;,
            &#34;_eyeB&#34;,
        ]

        for pf in postfixes:
            self._verify_name_available(name_prefix + pf)

        endA = self._poi_or_sheave_from_node(endA)
        endB = self._poi_or_sheave_from_node(endB)

        if length == -1:  # default
            if endA is None or endB is None:
                raise ValueError(
                    &#34;Length for cable is not provided, so defaults to distance between endpoints; but at least one of the endpoints is None.&#34;
                )

            length = np.linalg.norm(
                np.array(endA.global_position) - np.array(endB.global_position)
            )

        if LeyeA is None:  # default
            LeyeA = length / 6
        if LeyeB is None:  # default
            LeyeB = length / 6
        if LspliceA is None:  # default
            LspliceA = length / 6
        if LspliceB is None:  # default
            LspliceB = length / 6

        if sheaves is None:
            sheaves = []

        assert1f_positive_or_zero(diameter, &#34;Diameter&#34;)
        assert1f_positive_or_zero(mass, &#34;mass&#34;)

        assert1f_positive(length, &#34;Length&#34;)
        assert1f_positive(LeyeA, &#34;length of eye A&#34;)
        assert1f_positive(LeyeB, &#34;length of eye B&#34;)
        assert1f_positive(LspliceA, &#34;length of splice A&#34;)
        assert1f_positive(LspliceB, &#34;length of splice B&#34;)

        for s in sheaves:
            _ = self._poi_or_sheave_from_node(s)

        # then make element
        # __init__(self, scene, name, Ltotal, LeyeA, LeyeB, LspliceA, LspliceB, diameter, EA, mass, endA = None, endB=None, sheaves=None):

        node = Sling(
            scene=self,
            name=name,
            length=length,
            LeyeA=LeyeA,
            LeyeB=LeyeB,
            LspliceA=LspliceA,
            LspliceB=LspliceB,
            diameter=diameter,
            EA=EA,
            mass=mass,
            endA=endA,
            endB=endB,
            sheaves=sheaves,
        )
        self._nodes.append(node)

        return node

    def new_shackle(self, name, kind=&#34;GP500&#34;) -&gt; Shackle:
        &#34;&#34;&#34;
        Creates a new shackle, adds it to the scene and returns a reference to the newly created object.

        See Also:
            Shackle

        Args:
            name:   name
            kind:  type of shackle; eg &#39;GP500&#39;


        Returns:
            a reference to the newly created Shackle object.

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)

        name_prefix = name + vfc.MANAGED_NODE_IDENTIFIER
        postfixes = [
            &#34;_body&#34;,
            &#34;_pin_point&#34;,
            &#34;_bow_point&#34;,
            &#34;_inside_circle_center&#34;,
            &#34;_inside&#34;,
            &#34;_visual&#34;,
        ]
        for pf in postfixes:
            self._verify_name_available(name_prefix + pf)

        # then make element

        # make elements

        a = self._vfc.new_axis(name)

        p = self._vfc.new_poi(name + vfc.VF_NAME_SPLIT + &#34;cog&#34;)
        p.parent = a

        g = self._vfc.new_force(name + vfc.VF_NAME_SPLIT + &#34;gravity&#34;)
        g.parent = p

        node = Shackle(scene=self, name=name, kind=kind, a=a, p=p, g=g)

        self._nodes.append(node)

        return node

    def print_python_code(self):
        &#34;&#34;&#34;Prints the python code that generates the current scene

        See also: give_python_code
        &#34;&#34;&#34;
        for line in self.give_python_code().split(&#34;\n&#34;):
            print(line)

    def give_python_code(self):
        &#34;&#34;&#34;Generates the python code that rebuilds the scene and elements in its current state.&#34;&#34;&#34;

        import datetime
        import getpass

        self.sort_nodes_by_dependency()

        code = &#34;# auto generated pyhton code&#34;
        try:
            code += &#34;\n# By {}&#34;.format(getpass.getuser())
        except:
            code += &#34;\n# By an unknown&#34;

        code += &#34;\n# Time: {} UTC&#34;.format(str(datetime.datetime.now()).split(&#34;.&#34;)[0])

        code += &#34;\n\n# To be able to distinguish the important number (eg: fixed positions) from&#34;
        code += &#34;\n# non-important numbers (eg: a position that is solved by the static solver) we use a dummy-function called &#39;solved&#39;.&#34;
        code += &#34;\n# For anything written as solved(number) that actual number does not influence the static solution&#34;
        code += &#34;\ndef solved(number):\n    return number\n&#34;

        for n in self._nodes:

            if n._manager is None:
                # print(f&#39;code for {n.name}&#39;)
                code += &#34;\n&#34; + n.give_python_code()
            else:
                if n._manager.creates(n):
                    pass
                else:
                    code += &#34;\n&#34; + n.give_python_code()

                # print(f&#39;skipping {n.name} &#39;)

        # store the visibility code separately

        for n in self._nodes:
            if not n.visible:
                code += f&#34;\ns[&#39;{n.name}&#39;].visible = False&#34;  # only report is not the default value

        return code

    def save_scene(self, filename):
        &#34;&#34;&#34;Saves the scene to a file

        This saves the scene in its current state to a file.
        Opening the saved file will reproduce exactly this scene.

        This sounds nice, but beware that it only saves the resulting model, not the process of creating the model.
        This means that if you created the model in a parametric fashion or assembled the model from other models then these are not re-evaluated when the model is openened again.
        So lets say this model uses a sub-model of a lifting hook which is imported from another file. If that other file is updated then
        the results of that update will not be reflected in the saved model.

        If no path is present in the file-name then the model will be saved in the last (lowest) resource-path (if any)

        Args:
            filename : filename or file-path to save the file. Default extension is .dave

        Returns:
            the full path to the saved file

        &#34;&#34;&#34;

        code = self.give_python_code()

        filename = Path(filename)

        # add .dave extension if needed
        if filename.suffix != &#34;.dave&#34;:
            filename = Path(str(filename) + &#34;.dave&#34;)

        # add path if not provided
        if not filename.is_absolute():
            try:
                filename = Path(self.resources_paths[-1]) / filename
            except:
                pass  # save in current folder

        # make sure directory exists
        directory = filename.parent
        if not directory.exists():
            directory.mkdir()

        f = open(filename, &#34;w+&#34;)
        f.write(code)
        f.close()

        self._print(&#34;Saved as {}&#34;.format(filename))

        return filename

    def print_node_tree(self):

        self.sort_nodes_by_dependency()

        to_be_printed = []
        for n in self._nodes:
            to_be_printed.append(n.name)

        # to_be_printed.reverse()

        def print_deps(name, spaces):

            node = self[name]
            deps = self.nodes_with_parent(node)
            print(spaces + name + &#34; [&#34; + str(type(node)).split(&#34;.&#34;)[-1][:-2] + &#34;]&#34;)

            if deps is not None:
                for dep in deps:
                    if spaces == &#34;&#34;:
                        spaces_plus = &#34; |-&gt; &#34;
                    else:
                        spaces_plus = &#34; |   &#34; + spaces
                    print_deps(dep, spaces_plus)

            to_be_printed.remove(name)

        while to_be_printed:
            name = to_be_printed[0]
            print_deps(name, &#34;&#34;)

    def run_code(self, code):
        &#34;&#34;&#34;Runs the provided code with &#39;s&#39; as self&#34;&#34;&#34;

        import DAVE

        locals = DAVE.__dict__
        locals[&#39;s&#39;] = self

        try:
            exec(code, {}, locals)
        except Exception as M:
            for i, line in enumerate(code.split(&#34;\n&#34;)):
                print(f&#34;{i} {line}&#34;)
            raise M

    def load_scene(self, filename=None):
        &#34;&#34;&#34;Loads the contents of filename into the current scene.

        This function is typically used on an empty scene.

        Filename is appended with .dave if needed.
        File is searched for in the resource-paths.

        See also: import scene&#34;&#34;&#34;

        if filename is None:
            raise Exception(&#34;Please provide a file-name&#34;)

        try:
            filename = self.get_resource_path(filename)
        except:
            if not str(filename).endswith(&#34;.dave&#34;):
                filename = Path(str(filename) + &#34;.dave&#34;)

        print(&#34;Loading {}&#34;.format(filename))

        f = open(file=filename, mode=&#34;r&#34;)
        code = &#34;&#34;
        for line in f:
            code += line + &#34;\n&#34;

        self.run_code(code)

    def import_scene(self, other, prefix=&#34;&#34;, containerize=True):
        &#34;&#34;&#34;Copy-paste all nodes of scene &#34;other&#34; into current scene.

        To avoid double names it is recommended to use a prefix. This prefix will be added to all element names.

        Returns:
            Contained (Axis-type Node) : if the imported scene is containerized then a reference to the created container is returned.
        &#34;&#34;&#34;

        if isinstance(other, Path):
            other = str(other)

        if isinstance(other, str):
            other = Scene(other)

        if not isinstance(other, Scene):
            raise TypeError(&#34;Other should be a Scene but is a &#34; + str(type(other)))

        old_prefix = self._name_prefix
        imported_element_names = []

        for n in other._nodes:
            imported_element_names.append(prefix + n.name)

        # check for double names

        for new_node_name in imported_element_names:
            if not self.name_available(new_node_name):
                raise NameError(
                    &#39;An element with name &#34;{}&#34; is already present. Please use a prefix to avoid double names&#39;.format(
                        new_node_name
                    )
                )

        self._name_prefix = prefix

        code = other.give_python_code()

        self.run_code(code)

        self._name_prefix = old_prefix  # restore

        # Move all imported elements without a parent into a newly created axis system
        if containerize:

            container_name = self.available_name_like(&#34;import_container&#34;)

            c = self.new_axis(prefix + container_name)

            for name in imported_element_names:

                node = self[name]

                if not node.manager:
                    if not isinstance(node, NodeWithParent):
                        continue

                    if node.parent is None:
                        node.change_parent_to(c)

            return c

        return None

    def copy(self):
        &#34;&#34;&#34;Creates a full and independent copy of the scene and returns it.

        Example:
            s = Scene()
            c = s.copy()
            c.new_axis(&#39;only in c&#39;)

        &#34;&#34;&#34;

        c = Scene()
        c.import_scene(self, containerize=False)
        return c

    # =================== DYNAMICS ==================

    def dynamics_M(self, delta=1e-6):
        &#34;&#34;&#34;Returns the mass matrix of the scene&#34;&#34;&#34;
        self.update()

        return self._vfc.M(delta)

    def dynamics_K(self, delta=1e-6):
        &#34;&#34;&#34;Returns the stiffness matrix of the scene for a perturbation of delta

        A component is positive if a displacement introduces an reaction force in the opposite direction.
        or:
        A component is positive if a positive force is needed to introduce a positive displacement.
        &#34;&#34;&#34;
        self.update()

        return -self._vfc.K(delta)

    def dynamics_nodes(self):
        &#34;&#34;&#34;Returns a list of nodes associated with the rows/columns of M and K&#34;&#34;&#34;
        self.update()
        nodes = self._vfc.get_dof_elements()

        node_names = [n.name for n in self._nodes]

        r = []
        for n in nodes:
            if n.name in node_names:
                r.append(self[n.name])
            else:
                r.append(None)

        return r

    def dynamics_modes(self):
        &#34;&#34;&#34;Returns a list of modes (0=x ... 5=rotation z) associated with the rows/columns of M and K&#34;&#34;&#34;
        self.update()
        return self._vfc.get_dof_modes()


# =================== None-Node Classes

&#34;&#34;&#34;This is a container for a pyo3d.MomentDiagram object providing plot methods&#34;&#34;&#34;


class LoadShearMomentDiagram:
    def __init__(self, datasource):
        &#34;&#34;&#34;

        Args:
            datasource: pyo3d.MomentDiagram object
        &#34;&#34;&#34;

        self.datasource = datasource

    def give_shear_and_moment(self, grid_n=100):
        &#34;&#34;&#34;Returns (position, shear, moment)&#34;&#34;&#34;
        x = self.datasource.grid(grid_n)
        return x, self.datasource.Vz, self.datasource.My

    def plot_simple(self, **kwargs):
        &#34;&#34;&#34;Plots the bending moment and shear in a single yy-plot.
        Creates a new figure

        any keyword arguments are passed to plt.figure(), so for example dpi=150 will increase the dpi

        Returns: figure
        &#34;&#34;&#34;
        x, Vz, My = self.give_shear_and_moment()
        import matplotlib.pyplot as plt
        plt.rcParams.update({&#34;font.family&#34;: &#34;sans-serif&#34;})
        plt.rcParams.update({&#34;font.sans-serif&#34;: &#34;consolas&#34;})
        plt.rcParams.update({&#34;font.size&#34;: 10})

        fig, ax1 = plt.subplots(1,1,**kwargs)
        ax2 = ax1.twinx()

        ax1.plot(x, My, &#34;g&#34;, lw=1, label=&#34;Bending Moment&#34;)
        ax2.plot(x, Vz, &#34;b&#34;, lw=1, label=&#34;Shear Force&#34;)

        from DAVE.gui.helpers.align_zeros_of_yyplots import align_y0_axis

        align_y0_axis(ax1, ax2)

        ax1.set_xlabel(&#34;Position [m]&#34;)
        ax1.set_ylabel(&#34;Bending Moment [kNm]&#34;)
        ax2.set_ylabel(&#34;Shear Force [kN]&#34;)

        ax1.tick_params(axis=&#34;y&#34;, colors=&#34;g&#34;)
        ax2.tick_params(axis=&#34;y&#34;, colors=&#34;b&#34;)

        # fig.legend()  - obvious from the axis

        ext = 0.1 * (np.max(x) - np.min(x))
        xx = [np.min(x) - ext, np.max(x) + ext]
        ax1.plot(xx, [0, 0], c=[0.5, 0.5, 0.5], lw=1, linestyle=&#34;:&#34;)
        ax1.set_xlim(xx)

        return fig

    def plot(self, grid_n=100, merge_adjacent_loads=True, filename=None):
        m = self.datasource  # alias

        x = m.grid(grid_n)
        linewidth = 1

        n = m.nLoads

        import matplotlib.pyplot as plt

        #
        plt.rcParams.update({&#34;font.family&#34;: &#34;sans-serif&#34;})
        plt.rcParams.update({&#34;font.sans-serif&#34;: &#34;consolas&#34;})
        plt.rcParams.update({&#34;font.size&#34;: 6})

        fig, (ax0, ax1, ax2) = plt.subplots(3, 1, figsize=(8.27, 11.69), dpi=100)
        textsize = 6

        # get loads

        loads = [m.load(i) for i in range(n)]

        texts = []  # for label placement
        texts_second = []  # for label placement

        # merge loads with same source and matching endpoints

        if merge_adjacent_loads:

            to_be_plotted = [loads[0]]

            for load in loads[1:]:
                name = load[2]

                # if the previous load is a continuous load from the same source
                # and the current load is also a continuous load
                # then merge the two.
                prev_load = to_be_plotted[-1]

                if len(prev_load[0]) != 2:  # not a point-load
                    if len(load[0]) != 2:  # not a point-load
                        if prev_load[2] == load[2]:  # same name

                            # merge the two
                            # remove the last (zero) entry of the previous lds
                            # as well as the first entry of these

                            # smoothed
                            xx = [*prev_load[0][:-1], *load[0][2:]]
                            yy = [
                                *prev_load[1][:-2],
                                0.5 * (prev_load[1][-2] + load[1][1]),
                                *load[1][2:],
                            ]

                            to_be_plotted[-1] = (xx, yy, load[2])

                            continue
                # else
                if np.max(np.abs(load[1])) &gt; 1e-6:
                    to_be_plotted.append(load)

        else:
            to_be_plotted = loads

        #
        from matplotlib import cm

        colors = cm.get_cmap(&#34;hsv&#34;, lut=len(to_be_plotted))

        from matplotlib.patches import Polygon

        ax0_second = ax0.twinx()

        for icol, ld in enumerate(to_be_plotted):

            xx = ld[0]
            yy = ld[1]
            name = ld[2]

            if np.max(np.abs(yy)) &lt; 1e-6:
                continue

            is_concentrated = len(xx) == 2

            # determine the name, default to Force / q-load if no name is present
            if name == &#34;&#34;:
                if is_concentrated:
                    name = &#34;Force &#34;
                else:
                    name = &#34;q-load &#34;

            col = [0.8 * c for c in colors(icol)]
            col[3] = 1.0  # alpha

            if is_concentrated:  # concentrated loads on left axis
                lbl = f&#34; {name} {ld[1][1]:.2f}&#34;
                texts.append(
                    ax0.text(
                        xx[0], yy[1], lbl, fontsize=textsize, horizontalalignment=&#34;left&#34;
                    )
                )
                ax0.plot(xx, yy, label=lbl, color=col, linewidth=linewidth)
                if yy[1] &gt; 0:
                    ax0.plot(xx[1], yy[1], marker=&#34;^&#34;, color=col, linewidth=linewidth)
                else:
                    ax0.plot(xx[1], yy[1], marker=&#34;v&#34;, color=col, linewidth=linewidth)

            else:  # distributed loads on right axis
                lbl = f&#34;{name}&#34;  # {yy[1]:.2f} kN/m at {xx[0]:.3f}m .. {yy[-2]:.2f} kN/m at {xx[-1]:.3f}m&#34;

                vertices = [(xx[i], yy[i]) for i in range(len(xx))]

                ax0_second.add_patch(
                    Polygon(vertices, facecolor=[col[0], col[1], col[2], 0.2])
                )
                ax0_second.plot(xx, yy, label=lbl, color=col, linewidth=linewidth)

                lx = np.mean(xx)
                ly = np.interp(lx, xx, yy)

                texts_second.append(
                    ax0_second.text(
                        lx,
                        ly,
                        lbl,
                        color=[0, 0, 0],
                        horizontalalignment=&#34;center&#34;,
                        fontsize=textsize,
                    )
                )

        ax0.grid()
        ax0.set_title(&#34;Loads&#34;)
        ax0.set_ylabel(&#34;Load [kN]&#34;)
        ax0_second.set_ylabel(&#34;Load [kN/m]&#34;)

        # plot moments
        # each concentrated load may have a moment as well
        for i in range(m.nLoads):
            mom = m.moment(i)
            if np.linalg.norm(mom) &gt; 1e-6:
                load = m.load(i)
                xx = load[0][0]
                lbl = f&#34;{load[2]}, m = {mom[1]:.2f} kNm&#34;
                ax0.plot(xx, 0, marker=&#34;x&#34;, label=lbl, color=(0, 0, 0, 1))
                texts.append(
                    ax0.text(
                        xx, 0, lbl, horizontalalignment=&#34;center&#34;, fontsize=textsize
                    )
                )

        fig.legend(loc=&#34;upper right&#34;)

        # add a zero-line
        xx = [np.min(x), np.max(x)]
        ax0.plot(xx, (0, 0), &#34;k-&#34;)

        from DAVE.gui.helpers.align_zeros_of_yyplots import align_y0_axis

        align_y0_axis(ax0, ax0_second)

        from DAVE.reporting.utils.TextAvoidOverlap import minimizeTextOverlap

        minimizeTextOverlap(
            texts_second,
            fig=fig,
            ax=ax0_second,
            vertical_only=True,
            optimize_initial_positions=False,
            annotate=False,
        )
        minimizeTextOverlap(
            texts,
            fig=fig,
            ax=ax0,
            vertical_only=True,
            optimize_initial_positions=False,
            annotate=False,
        )

        ax0.spines[&#34;top&#34;].set_visible(False)
        ax0.spines[&#34;bottom&#34;].set_visible(False)

        ax0_second.spines[&#34;top&#34;].set_visible(False)
        ax0_second.spines[&#34;bottom&#34;].set_visible(False)

        ax1.plot(x, m.Vz, &#34;k-&#34;, linewidth=linewidth)

        i = np.argmax(np.abs(m.Vz))
        ax1.plot(x[i], m.Vz[i], &#34;b*&#34;)
        ax1.text(x[i], m.Vz[i], f&#34;{m.Vz[i]:.2f}&#34;)

        ax1.grid()
        ax1.set_title(&#34;Shear&#34;)
        ax1.set_ylabel(&#34;[kN]&#34;)

        ax2.plot(x, m.My, &#34;k-&#34;, linewidth=linewidth)
        i = np.argmax(np.abs(m.My))
        ax2.plot(x[i], m.My[i], &#34;b*&#34;)
        ax2.text(x[i], m.My[i], f&#34;{m.My[i]:.2f}&#34;)

        ax2.grid()
        ax2.set_title(&#34;Moment&#34;)
        ax2.set_ylabel(&#34;[kN*m]&#34;)

        if filename is None:
            plt.show()
        else:
            fig.savefig(filename)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="DAVE.scene.node_setter_manageable"><code class="name flex">
<span>def <span class="ident">node_setter_manageable</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def node_setter_manageable(func):
    @functools.wraps(func)
    def wrapper_decorator(self, *args, **kwargs):
        self._verify_change_allowed()
        value = func(self, *args, **kwargs)
        return value

    return wrapper_decorator</code></pre>
</details>
</dd>
<dt id="DAVE.scene.node_setter_observable"><code class="name flex">
<span>def <span class="ident">node_setter_observable</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def node_setter_observable(func):
    @functools.wraps(func)
    def wrapper_decorator(self, *args, **kwargs):
        value = func(self, *args, **kwargs)
        # Do something after
        self._notify_observers()

        return value

    return wrapper_decorator</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="DAVE.scene.Axis"><code class="flex name class">
<span>class <span class="ident">Axis</span></span>
<span>(</span><span>scene, vfAxis)</span>
</code></dt>
<dd>
<div class="desc"><p>Axis</p>
<p>Axes are the main building blocks of the geometry. They have a position and an rotation in space. Other nodes can be placed on them.
Axes can be nested by parent/child relationships meaning that an axis can be placed on an other axis.
The possible movements of an axis can be controlled in each degree of freedom using the "fixed" property.</p>
<p>Axes are also the main building block of inertia.
Dynamics are controlled using the inertia properties of an axis: inertia [mT], inertia_position[m,m,m] and inertia_radii [m,m,m]</p>
<h2 id="notes">Notes</h2>
<ul>
<li>circular references are not allowed: It is not allowed to place a on b and b on a</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Axis(NodeWithParentAndFootprint):
    &#34;&#34;&#34;
    Axis

    Axes are the main building blocks of the geometry. They have a position and an rotation in space. Other nodes can be placed on them.
    Axes can be nested by parent/child relationships meaning that an axis can be placed on an other axis.
    The possible movements of an axis can be controlled in each degree of freedom using the &#34;fixed&#34; property.

    Axes are also the main building block of inertia.
    Dynamics are controlled using the inertia properties of an axis: inertia [mT], inertia_position[m,m,m] and inertia_radii [m,m,m]


    Notes:
         - circular references are not allowed: It is not allowed to place a on b and b on a

    &#34;&#34;&#34;

    def __init__(self, scene, vfAxis):
        super().__init__(scene, vfAxis)
        self._None_parent_acceptable = True

        self._inertia = 0
        self._inertia_position = (0, 0, 0)
        self._inertia_radii = (0, 0, 0)

        self._pointmasses = list()
        for i in range(6):
            p = scene._vfc.new_pointmass(
                self.name + vfc.VF_NAME_SPLIT + &#34;pointmass_{}&#34;.format(i)
            )
            p.parent = vfAxis
            self._pointmasses.append(p)
        self._update_inertia()

    def depends_on(self):
        if self.parent is None:
            return []
        else:
            return [self.parent]

    def _delete_vfc(self):
        for p in self._pointmasses:
            self._scene._vfc.delete(p.name)

        super()._delete_vfc()

    @property
    def inertia(self):
        &#34;&#34;&#34;The linear inertia of the axis in [mT] Aka: &#34;Mass&#34;
        - used only for dynamics&#34;&#34;&#34;
        return self._inertia

    @inertia.setter
    @node_setter_manageable
    @node_setter_observable
    def inertia(self, val):

        assert1f(val, &#34;Inertia&#34;)
        self._inertia = val
        self._update_inertia()

    @property
    def inertia_position(self):
        &#34;&#34;&#34;The position of the center of inertia. Aka: &#34;cog&#34; [m,m,m] (local axis)
        - used only for dynamics
        - defined in local axis system&#34;&#34;&#34;
        return tuple(self._inertia_position)

    @inertia_position.setter
    @node_setter_manageable
    @node_setter_observable
    def inertia_position(self, val):

        assert3f(val, &#34;Inertia position&#34;)
        self._inertia_position = tuple(val)
        self._update_inertia()

    @property
    def inertia_radii(self):
        &#34;&#34;&#34;The radii of gyration of the inertia [m,m,m] (local axis)

        Used to calculate the mass moments of inertia via

        Ixx = rxx^2 * inertia
        Iyy = rxx^2 * inertia
        Izz = rxx^2 * inertia

        Note that DAVE does not directly support cross terms in the interia matrix of an axis system. If you want to
        use cross terms then combine multiple axis system to reach the same result. This is because inertia matrices with
        diagonal terms can not be translated.
        &#34;&#34;&#34;
        return np.array(self._inertia_radii, dtype=float)

    @inertia_radii.setter
    @node_setter_manageable
    @node_setter_observable
    def inertia_radii(self, val):

        assert3f_positive(val, &#34;Inertia radii of gyration&#34;)
        self._inertia_radii = val
        self._update_inertia()

    def _update_inertia(self):
        # update mass
        for i in range(6):
            self._pointmasses[i].inertia = self._inertia / 6

        if self._inertia &lt;= 0:
            return

        # update radii and position
        pos = radii_to_positions(*self._inertia_radii)
        for i in range(6):
            p = (
                pos[i][0] + self._inertia_position[0],
                pos[i][1] + self._inertia_position[1],
                pos[i][2] + self._inertia_position[2],
            )
            self._pointmasses[i].position = p
            # print(&#39;{} at {} {} {}&#39;.format(self._inertia/6, *p))

    @property
    def fixed(self):
        &#34;&#34;&#34;Determines which of the six degrees of freedom are fixed, if any. (x,y,z,rx,ry,rz).
        True means that that degree of freedom will not change when solving statics.
        False means a that is may be changed in order to find equilibrium.

        These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)

        See Also: set_free, set_fixed
        &#34;&#34;&#34;
        return self._vfNode.fixed

    @fixed.setter
    @node_setter_manageable
    @node_setter_observable
    def fixed(self, var):

        if var == True:
            var = (True, True, True, True, True, True)
        if var == False:
            var = (False, False, False, False, False, False)

        self._vfNode.fixed = var

    def set_free(self):
        &#34;&#34;&#34;Sets .fixed to (False,False,False,False,False,False)&#34;&#34;&#34;
        self._vfNode.set_free()

    def set_fixed(self):
        &#34;&#34;&#34;Sets .fixed to (True,True,True,True,True,True)&#34;&#34;&#34;

        self._vfNode.set_fixed()

    @property
    def x(self):
        &#34;&#34;&#34;The x-component of the position vector (parent axis) [m]&#34;&#34;&#34;
        return self.position[0]

    @property
    def y(self):
        &#34;&#34;&#34;The y-component of the position vector (parent axis) [m]&#34;&#34;&#34;
        return self.position[1]

    @property
    def z(self):
        &#34;&#34;&#34;The z-component of the position vector (parent axis) [m]&#34;&#34;&#34;
        return self.position[2]

    @x.setter
    @node_setter_manageable
    @node_setter_observable
    def x(self, var):

        a = self.position
        self.position = (var, a[1], a[2])

    @y.setter
    @node_setter_manageable
    @node_setter_observable
    def y(self, var):

        a = self.position
        self.position = (a[0], var, a[2])

    @z.setter
    @node_setter_manageable
    @node_setter_observable
    def z(self, var):

        a = self.position
        self.position = (a[0], a[1], var)

    @property
    def position(self):
        &#34;&#34;&#34;Position of the axis (parent axis) [m,m,m]

        These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)&#34;&#34;&#34;
        return self._vfNode.position

    @position.setter
    @node_setter_manageable
    @node_setter_observable
    def position(self, var):

        assert3f(var, &#34;Position &#34;)
        self._vfNode.position = var
        self._scene._geometry_changed()

    @property
    def rx(self):
        &#34;&#34;&#34;The x-component of the rotation vector [degrees] (parent axis)&#34;&#34;&#34;
        return self.rotation[0]

    @property
    def ry(self):
        &#34;&#34;&#34;The y-component of the rotation vector [degrees] (parent axis)&#34;&#34;&#34;
        return self.rotation[1]

    @property
    def rz(self):
        &#34;&#34;&#34;The z-component of the rotation vector [degrees], (parent axis)&#34;&#34;&#34;
        return self.rotation[2]

    @rx.setter
    @node_setter_manageable
    @node_setter_observable
    def rx(self, var):

        a = self.rotation
        self.rotation = (var, a[1], a[2])

    @ry.setter
    @node_setter_manageable
    @node_setter_observable
    def ry(self, var):

        a = self.rotation
        self.rotation = (a[0], var, a[2])

    @rz.setter
    @node_setter_manageable
    @node_setter_observable
    def rz(self, var):

        a = self.rotation
        self.rotation = (a[0], a[1], var)

    @property
    def rotation(self):
        &#34;&#34;&#34;Rotation of the axis about its origin (rx,ry,rz).
        Defined as a rotation about an axis where the direction of the axis is (rx,ry,rz) and the angle of rotation is |(rx,ry,rz| degrees.
        These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)&#34;&#34;&#34;
        return np.rad2deg(self._vfNode.rotation)

    @rotation.setter
    @node_setter_manageable
    @node_setter_observable
    def rotation(self, var):

        # convert to degrees
        assert3f(var, &#34;Rotation &#34;)
        self._vfNode.rotation = np.deg2rad(var)
        self._scene._geometry_changed()

    # we need to over-ride the parent property to be able to call _geometry_changed afterwards
    @property
    def parent(self):
        &#34;&#34;&#34;Determines the parent of the axis. Should either be another axis or &#39;None&#39;

        Other axis may be refered to by reference or by name (str). So the following are identical

            p = s.new_axis(&#39;parent_axis&#39;)
            c = s.new_axis(&#39;child axis&#39;)

            c.parent = p
            c.parent = &#39;parent_axis&#39;

        To define that an axis does not have a parent use

            c.parent = None

        &#34;&#34;&#34;
        return super().parent

    @parent.setter
    @node_setter_manageable
    @node_setter_observable
    def parent(self, val):

        if val is not None:
            # Circular reference check: are we trying to make self depend on val while val depends on self?
            if self._scene.node_A_core_depends_on_B_core(val, self):
                if isinstance(val, Axis):  # it better be
                    val.change_parent_to(
                        None
                    )  # change the parent of other to None, this breaks the previous dependancy

        NodeWithParent.parent.fset(self, val)
        self._scene._geometry_changed()

    @property
    def gx(self):
        &#34;&#34;&#34;The x-component of the global position vector [m] (global axis )&#34;&#34;&#34;
        return self.global_position[0]

    @property
    def gy(self):
        &#34;&#34;&#34;The y-component of the global position vector [m] (global axis )&#34;&#34;&#34;
        return self.global_position[1]

    @property
    def gz(self):
        &#34;&#34;&#34;The z-component of the global position vector [m] (global axis )&#34;&#34;&#34;
        return self.global_position[2]

    @gx.setter
    @node_setter_manageable
    @node_setter_observable
    def gx(self, var):

        a = self.global_position
        self.global_position = (var, a[1], a[2])

    @gy.setter
    @node_setter_manageable
    @node_setter_observable
    def gy(self, var):

        a = self.global_position
        self.global_position = (a[0], var, a[2])

    @gz.setter
    @node_setter_manageable
    @node_setter_observable
    def gz(self, var):

        a = self.global_position
        self.global_position = (a[0], a[1], var)

    @property
    def global_position(self):
        &#34;&#34;&#34;The global position of the origin of the axis system  [m,m,m] (global axis)&#34;&#34;&#34;
        return self._vfNode.global_position

    @global_position.setter
    @node_setter_manageable
    @node_setter_observable
    def global_position(self, val):

        assert3f(val, &#34;Global Position&#34;)
        if self.parent:
            self.position = self.parent.to_loc_position(val)
        else:
            self.position = val

    @property
    def grx(self):
        &#34;&#34;&#34;The x-component of the global rotation vector [degrees] (global axis)&#34;&#34;&#34;
        return self.global_rotation[0]

    @property
    def gry(self):
        &#34;&#34;&#34;The y-component of the global rotation vector [degrees] (global axis)&#34;&#34;&#34;
        return self.global_rotation[1]

    @property
    def grz(self):
        &#34;&#34;&#34;The z-component of the global rotation vector [degrees] (global axis)&#34;&#34;&#34;
        return self.global_rotation[2]

    @grx.setter
    @node_setter_manageable
    @node_setter_observable
    def grx(self, var):

        a = self.global_rotation
        self.global_rotation = (var, a[1], a[2])

    @gry.setter
    @node_setter_manageable
    @node_setter_observable
    def gry(self, var):

        a = self.global_rotation
        self.global_rotation = (a[0], var, a[2])

    @grz.setter
    @node_setter_manageable
    @node_setter_observable
    def grz(self, var):

        a = self.global_rotation
        self.global_rotation = (a[0], a[1], var)

    @property
    def tilt_x(self):
        &#34;&#34;&#34;Tilt percentage. This is the z-component of the unit y vector [%].

        See Also: heel
        &#34;&#34;&#34;
        y = (0, 1, 0)
        uy = self.to_glob_direction(y)
        return float(100 * uy[2])

    @property
    def heel(self):
        &#34;&#34;&#34;Heel in degrees. SB down is positive [deg].
        This is the inverse sin of the unit y vector(This is the arcsin of the tiltx)

        See also: tilt_x
        &#34;&#34;&#34;
        return np.rad2deg(np.arcsin(self.tilt_x / 100))

    @property
    def tilt_y(self):
        &#34;&#34;&#34;Tilt percentage. This is the z-component of the unit -x vector [%].
        So a positive rotation about the y axis results in a positive tilt_y.

        See Also: trim
        &#34;&#34;&#34;
        x = (-1, 0, 0)
        ux = self.to_glob_direction(x)
        return float(100 * ux[2])

    @property
    def trim(self):
        &#34;&#34;&#34;Trim in degrees. Bow-down is positive [deg].

        This is the inverse sin of the unit -x vector(This is the arcsin of the tilt_y)

        See also: tilt_y
        &#34;&#34;&#34;
        return np.rad2deg(np.arcsin(self.tilt_y / 100))

    @property
    def heading(self):
        &#34;&#34;&#34;Direction (0..360) [deg] of the local x-axis relative to the global x axis. Measured about the global z axis

        heading = atan(u_y,u_x)

        typically:
            heading 0  --&gt; local axis align with global axis
            heading 90 --&gt; local x-axis in direction of global y axis


        See also: heading_compass
        &#34;&#34;&#34;
        x = (1, 0, 0)
        ux = self.to_glob_direction(x)
        heading = np.rad2deg(np.arctan2(ux[1], ux[0]))
        return np.mod(heading, 360)

    @property
    def heading_compass(self):
        &#34;&#34;&#34;The heading (0..360)[deg] assuming that the global y-axis is North and global x-axis is East and rotation accoring compass definition&#34;&#34;&#34;
        return np.mod(90 - self.heading, 360)

    @property
    def global_rotation(self):
        &#34;&#34;&#34;Rotation [deg,deg,deg] (global axis)&#34;&#34;&#34;
        return tuple(np.rad2deg(self._vfNode.global_rotation))

    @global_rotation.setter
    @node_setter_manageable
    @node_setter_observable
    def global_rotation(self, val):

        assert3f(val, &#34;Global Rotation&#34;)
        if self.parent:
            self.rotation = self.parent.to_loc_rotation(val)
        else:
            self.rotation = val

    @property
    def global_transform(self):
        &#34;&#34;&#34;Read-only: The global transform of the axis system [matrix]&#34;&#34;&#34;
        return self._vfNode.global_transform

    @property
    def connection_force(self):
        &#34;&#34;&#34;The forces and moments that this axis applies on its parent at the origin of this axis system. [kN, kN, kN, kNm, kNm, kNm] (Parent axis)

        If this axis would be connected to a point on its parent, and that point would be located at the location of the origin of this axis system
        then the connection force equals the force and moment applied on that point.

        Example:
            parent axis with name A
            this axis with name B
            this axis is located on A at position (10,0,0)
            there is a Point at the center of this axis system.
            A force with Fz = -10 acts on the Point.

            The connection_force is (-10,0,0,0,0,0)

            This is the force and moment as applied on A at point (10,0,0)


        &#34;&#34;&#34;
        return self._vfNode.connection_force

    @property
    def connection_force_x(self):
        &#34;&#34;&#34;The x-component of the connection-force vector [kN] (Parent axis)&#34;&#34;&#34;
        return self.connection_force[0]

    @property
    def connection_force_y(self):
        &#34;&#34;&#34;The y-component of the connection-force vector [kN] (Parent axis)&#34;&#34;&#34;
        return self.connection_force[1]

    @property
    def connection_force_z(self):
        &#34;&#34;&#34;The z-component of the connection-force vector [kN] (Parent axis)&#34;&#34;&#34;
        return self.connection_force[2]

    @property
    def connection_moment_x(self):
        &#34;&#34;&#34;The mx-component of the connection-force vector [kNm] (Parent axis)&#34;&#34;&#34;
        return self.connection_force[3]

    @property
    def connection_moment_y(self):
        &#34;&#34;&#34;The my-component of the connection-force vector [kNm] (Parent axis)&#34;&#34;&#34;
        return self.connection_force[4]

    @property
    def connection_moment_z(self):
        &#34;&#34;&#34;The mx-component of the connection-force vector [kNm] (Parent axis)&#34;&#34;&#34;
        return self.connection_force[5]

    @property
    def applied_force(self):
        &#34;&#34;&#34;The force and moment that is applied on origin of this axis [kN, kN, kN, kNm, kNm, kNm] (Global axis)&#34;&#34;&#34;
        return self._vfNode.applied_force

    @property
    def ux(self):
        &#34;&#34;&#34;The unit x axis [m,m,m] (Global axis)&#34;&#34;&#34;
        return self.to_glob_direction((1, 0, 0))

    @property
    def uy(self):
        &#34;&#34;&#34;The unit y axis [m,m,m] (Global axis)&#34;&#34;&#34;
        return self.to_glob_direction((0, 1, 0))

    @property
    def uz(self):
        &#34;&#34;&#34;The unit z axis [m,m,m] (Global axis)&#34;&#34;&#34;
        return self.to_glob_direction((0, 0, 1))

    @property
    def equilibrium_error(self):
        &#34;&#34;&#34;The unresolved force and moment that on this axis. Should be zero when in equilibrium  (applied-force minus connection force, Parent axis)&#34;&#34;&#34;
        return self._vfNode.equilibrium_error

    def to_loc_position(self, value):
        &#34;&#34;&#34;Returns the local position of a point in the global axis system.
        This considers the position and the rotation of the axis system.
        See Also: to_loc_direction
        &#34;&#34;&#34;
        return self._vfNode.global_to_local_point(value)

    def to_glob_position(self, value):
        &#34;&#34;&#34;Returns the global position of a point in the local axis system.
        This considers the position and the rotation of the axis system.
        See Also: to_glob_direction
        &#34;&#34;&#34;
        return self._vfNode.local_to_global_point(value)

    def to_loc_direction(self, value):
        &#34;&#34;&#34;Returns the local direction of a point in the global axis system.
        This considers only the rotation of the axis system.
        See Also: to_loc_position
        &#34;&#34;&#34;
        return self._vfNode.global_to_local_vector(value)

    def to_glob_direction(self, value):
        &#34;&#34;&#34;Returns the global direction of a point in the local axis system.
        This considers only the rotation of the axis system.
        See Also: to_glob_position&#34;&#34;&#34;
        return self._vfNode.local_to_global_vector(value)

    def to_loc_rotation(self, value):
        &#34;&#34;&#34;Returns the local rotation. Used for rotating rotations.
        See Also: to_loc_position, to_loc_direction
        &#34;&#34;&#34;
        return np.rad2deg(self._vfNode.global_to_local_rotation(np.deg2rad(value)))

    def to_glob_rotation(self, value):
        &#34;&#34;&#34;Returns the global rotation. Used for rotating rotations.
        See Also: to_loc_position, to_loc_direction
        &#34;&#34;&#34;
        return np.rad2deg(self._vfNode.local_to_global_rotation(np.deg2rad(value)))

    def give_load_shear_moment_diagram(
        self, axis_system=None
    ) -&gt; &#34;LoadShearMomentDiagram&#34;:
        &#34;&#34;&#34;Returns a LoadShearMoment diagram

        Args:
            axis_system : optional : coordinate system [axis node] to be used for calculation of the diagram.
            Defaults to the local axis system
        &#34;&#34;&#34;

        if axis_system is None:
            axis_system = self

        assert isinstance(axis_system, Axis), ValueError(
            f&#34;axis_system shall be an instance of Axis, but it is of type {type(axis_system)}&#34;
        )

        # calculate in the right global direction
        glob_dir = axis_system.to_glob_direction((1, 0, 0))
        self._scene._vfc.calculateBendingMoments(*glob_dir)

        lsm = self._vfNode.getBendingMomentDiagram(axis_system._vfNode)

        return LoadShearMomentDiagram(lsm)

    def change_parent_to(self, new_parent):
        &#34;&#34;&#34;Assigns a new parent to the node but keeps the global position and rotation the same.

        See also: .parent (property)

        Args:
            new_parent: new parent node

        &#34;&#34;&#34;

        # check new_parent
        if new_parent is not None:
            if not (
                isinstance(new_parent, Axis) or isinstance(new_parent, GeometricContact)
            ):
                raise TypeError(
                    &#34;Only None or Axis-type nodes (or derived types) can be used as parent. You tried to use a {} as parent&#34;.format(
                        type(new_parent)
                    )
                )

        glob_pos = self.global_position
        glob_rot = self.global_rotation
        self.parent = new_parent
        self.global_position = glob_pos
        self.global_rotation = glob_rot

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\ns.new_axis(name=&#39;{}&#39;,&#34;.format(self.name)
        if self.parent_for_export:
            code += &#34;\n           parent=&#39;{}&#39;,&#34;.format(self.parent_for_export.name)

        # position

        if self.fixed[0]:
            code += &#34;\n           position=({},&#34;.format(self.position[0])
        else:
            code += &#34;\n           position=(solved({}),&#34;.format(self.position[0])
        if self.fixed[1]:
            code += &#34;\n                     {},&#34;.format(self.position[1])
        else:
            code += &#34;\n                     solved({}),&#34;.format(self.position[1])
        if self.fixed[2]:
            code += &#34;\n                     {}),&#34;.format(self.position[2])
        else:
            code += &#34;\n                     solved({})),&#34;.format(self.position[2])

        # rotation

        if self.fixed[3]:
            code += &#34;\n           rotation=({},&#34;.format(self.rotation[0])
        else:
            code += &#34;\n           rotation=(solved({}),&#34;.format(self.rotation[0])
        if self.fixed[4]:
            code += &#34;\n                     {},&#34;.format(self.rotation[1])
        else:
            code += &#34;\n                     solved({}),&#34;.format(self.rotation[1])
        if self.fixed[5]:
            code += &#34;\n                     {}),&#34;.format(self.rotation[2])
        else:
            code += &#34;\n                     solved({})),&#34;.format(self.rotation[2])

        # inertia and radii of gyration
        if self.inertia &gt; 0:
            code += &#34;\n                     inertia = {},&#34;.format(self.inertia)

        if np.any(self.inertia_radii &gt; 0):
            code += &#34;\n                     inertia_radii = ({}, {}, {}),&#34;.format(
                *self.inertia_radii
            )

        # fixeties
        code += &#34;\n           fixed =({}, {}, {}, {}, {}, {}) )&#34;.format(*self.fixed)

        code += self.add_footprint_python_code()

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.NodeWithParentAndFootprint" href="#DAVE.scene.NodeWithParentAndFootprint">NodeWithParentAndFootprint</a></li>
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="DAVE.scene.RigidBody" href="#DAVE.scene.RigidBody">RigidBody</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Axis.applied_force"><code class="name">var <span class="ident">applied_force</span></code></dt>
<dd>
<div class="desc"><p>The force and moment that is applied on origin of this axis [kN, kN, kN, kNm, kNm, kNm] (Global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def applied_force(self):
    &#34;&#34;&#34;The force and moment that is applied on origin of this axis [kN, kN, kN, kNm, kNm, kNm] (Global axis)&#34;&#34;&#34;
    return self._vfNode.applied_force</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.connection_force"><code class="name">var <span class="ident">connection_force</span></code></dt>
<dd>
<div class="desc"><p>The forces and moments that this axis applies on its parent at the origin of this axis system. [kN, kN, kN, kNm, kNm, kNm] (Parent axis)</p>
<p>If this axis would be connected to a point on its parent, and that point would be located at the location of the origin of this axis system
then the connection force equals the force and moment applied on that point.</p>
<h2 id="example">Example</h2>
<p>parent axis with name A
this axis with name B
this axis is located on A at position (10,0,0)
there is a Point at the center of this axis system.
A force with Fz = -10 acts on the Point.</p>
<p>The connection_force is (-10,0,0,0,0,0)</p>
<p>This is the force and moment as applied on A at point (10,0,0)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connection_force(self):
    &#34;&#34;&#34;The forces and moments that this axis applies on its parent at the origin of this axis system. [kN, kN, kN, kNm, kNm, kNm] (Parent axis)

    If this axis would be connected to a point on its parent, and that point would be located at the location of the origin of this axis system
    then the connection force equals the force and moment applied on that point.

    Example:
        parent axis with name A
        this axis with name B
        this axis is located on A at position (10,0,0)
        there is a Point at the center of this axis system.
        A force with Fz = -10 acts on the Point.

        The connection_force is (-10,0,0,0,0,0)

        This is the force and moment as applied on A at point (10,0,0)


    &#34;&#34;&#34;
    return self._vfNode.connection_force</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.connection_force_x"><code class="name">var <span class="ident">connection_force_x</span></code></dt>
<dd>
<div class="desc"><p>The x-component of the connection-force vector [kN] (Parent axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connection_force_x(self):
    &#34;&#34;&#34;The x-component of the connection-force vector [kN] (Parent axis)&#34;&#34;&#34;
    return self.connection_force[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.connection_force_y"><code class="name">var <span class="ident">connection_force_y</span></code></dt>
<dd>
<div class="desc"><p>The y-component of the connection-force vector [kN] (Parent axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connection_force_y(self):
    &#34;&#34;&#34;The y-component of the connection-force vector [kN] (Parent axis)&#34;&#34;&#34;
    return self.connection_force[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.connection_force_z"><code class="name">var <span class="ident">connection_force_z</span></code></dt>
<dd>
<div class="desc"><p>The z-component of the connection-force vector [kN] (Parent axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connection_force_z(self):
    &#34;&#34;&#34;The z-component of the connection-force vector [kN] (Parent axis)&#34;&#34;&#34;
    return self.connection_force[2]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.connection_moment_x"><code class="name">var <span class="ident">connection_moment_x</span></code></dt>
<dd>
<div class="desc"><p>The mx-component of the connection-force vector [kNm] (Parent axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connection_moment_x(self):
    &#34;&#34;&#34;The mx-component of the connection-force vector [kNm] (Parent axis)&#34;&#34;&#34;
    return self.connection_force[3]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.connection_moment_y"><code class="name">var <span class="ident">connection_moment_y</span></code></dt>
<dd>
<div class="desc"><p>The my-component of the connection-force vector [kNm] (Parent axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connection_moment_y(self):
    &#34;&#34;&#34;The my-component of the connection-force vector [kNm] (Parent axis)&#34;&#34;&#34;
    return self.connection_force[4]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.connection_moment_z"><code class="name">var <span class="ident">connection_moment_z</span></code></dt>
<dd>
<div class="desc"><p>The mx-component of the connection-force vector [kNm] (Parent axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connection_moment_z(self):
    &#34;&#34;&#34;The mx-component of the connection-force vector [kNm] (Parent axis)&#34;&#34;&#34;
    return self.connection_force[5]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.equilibrium_error"><code class="name">var <span class="ident">equilibrium_error</span></code></dt>
<dd>
<div class="desc"><p>The unresolved force and moment that on this axis. Should be zero when in equilibrium
(applied-force minus connection force, Parent axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def equilibrium_error(self):
    &#34;&#34;&#34;The unresolved force and moment that on this axis. Should be zero when in equilibrium  (applied-force minus connection force, Parent axis)&#34;&#34;&#34;
    return self._vfNode.equilibrium_error</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.fixed"><code class="name">var <span class="ident">fixed</span></code></dt>
<dd>
<div class="desc"><p>Determines which of the six degrees of freedom are fixed, if any. (x,y,z,rx,ry,rz).
True means that that degree of freedom will not change when solving statics.
False means a that is may be changed in order to find equilibrium.</p>
<p>These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)</p>
<p>See Also: set_free, set_fixed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fixed(self):
    &#34;&#34;&#34;Determines which of the six degrees of freedom are fixed, if any. (x,y,z,rx,ry,rz).
    True means that that degree of freedom will not change when solving statics.
    False means a that is may be changed in order to find equilibrium.

    These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)

    See Also: set_free, set_fixed
    &#34;&#34;&#34;
    return self._vfNode.fixed</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.global_position"><code class="name">var <span class="ident">global_position</span></code></dt>
<dd>
<div class="desc"><p>The global position of the origin of the axis system
[m,m,m] (global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def global_position(self):
    &#34;&#34;&#34;The global position of the origin of the axis system  [m,m,m] (global axis)&#34;&#34;&#34;
    return self._vfNode.global_position</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.global_rotation"><code class="name">var <span class="ident">global_rotation</span></code></dt>
<dd>
<div class="desc"><p>Rotation [deg,deg,deg] (global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def global_rotation(self):
    &#34;&#34;&#34;Rotation [deg,deg,deg] (global axis)&#34;&#34;&#34;
    return tuple(np.rad2deg(self._vfNode.global_rotation))</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.global_transform"><code class="name">var <span class="ident">global_transform</span></code></dt>
<dd>
<div class="desc"><p>Read-only: The global transform of the axis system [matrix]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def global_transform(self):
    &#34;&#34;&#34;Read-only: The global transform of the axis system [matrix]&#34;&#34;&#34;
    return self._vfNode.global_transform</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.grx"><code class="name">var <span class="ident">grx</span></code></dt>
<dd>
<div class="desc"><p>The x-component of the global rotation vector [degrees] (global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def grx(self):
    &#34;&#34;&#34;The x-component of the global rotation vector [degrees] (global axis)&#34;&#34;&#34;
    return self.global_rotation[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.gry"><code class="name">var <span class="ident">gry</span></code></dt>
<dd>
<div class="desc"><p>The y-component of the global rotation vector [degrees] (global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gry(self):
    &#34;&#34;&#34;The y-component of the global rotation vector [degrees] (global axis)&#34;&#34;&#34;
    return self.global_rotation[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.grz"><code class="name">var <span class="ident">grz</span></code></dt>
<dd>
<div class="desc"><p>The z-component of the global rotation vector [degrees] (global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def grz(self):
    &#34;&#34;&#34;The z-component of the global rotation vector [degrees] (global axis)&#34;&#34;&#34;
    return self.global_rotation[2]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.gx"><code class="name">var <span class="ident">gx</span></code></dt>
<dd>
<div class="desc"><p>The x-component of the global position vector [m] (global axis )</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gx(self):
    &#34;&#34;&#34;The x-component of the global position vector [m] (global axis )&#34;&#34;&#34;
    return self.global_position[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.gy"><code class="name">var <span class="ident">gy</span></code></dt>
<dd>
<div class="desc"><p>The y-component of the global position vector [m] (global axis )</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gy(self):
    &#34;&#34;&#34;The y-component of the global position vector [m] (global axis )&#34;&#34;&#34;
    return self.global_position[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.gz"><code class="name">var <span class="ident">gz</span></code></dt>
<dd>
<div class="desc"><p>The z-component of the global position vector [m] (global axis )</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gz(self):
    &#34;&#34;&#34;The z-component of the global position vector [m] (global axis )&#34;&#34;&#34;
    return self.global_position[2]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.heading"><code class="name">var <span class="ident">heading</span></code></dt>
<dd>
<div class="desc"><p>Direction (0..360) [deg] of the local x-axis relative to the global x axis. Measured about the global z axis</p>
<p>heading = atan(u_y,u_x)</p>
<p>typically:
heading 0
&ndash;&gt; local axis align with global axis
heading 90 &ndash;&gt; local x-axis in direction of global y axis</p>
<p>See also: heading_compass</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def heading(self):
    &#34;&#34;&#34;Direction (0..360) [deg] of the local x-axis relative to the global x axis. Measured about the global z axis

    heading = atan(u_y,u_x)

    typically:
        heading 0  --&gt; local axis align with global axis
        heading 90 --&gt; local x-axis in direction of global y axis


    See also: heading_compass
    &#34;&#34;&#34;
    x = (1, 0, 0)
    ux = self.to_glob_direction(x)
    heading = np.rad2deg(np.arctan2(ux[1], ux[0]))
    return np.mod(heading, 360)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.heading_compass"><code class="name">var <span class="ident">heading_compass</span></code></dt>
<dd>
<div class="desc"><p>The heading (0..360)[deg] assuming that the global y-axis is North and global x-axis is East and rotation accoring compass definition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def heading_compass(self):
    &#34;&#34;&#34;The heading (0..360)[deg] assuming that the global y-axis is North and global x-axis is East and rotation accoring compass definition&#34;&#34;&#34;
    return np.mod(90 - self.heading, 360)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.heel"><code class="name">var <span class="ident">heel</span></code></dt>
<dd>
<div class="desc"><p>Heel in degrees. SB down is positive [deg].
This is the inverse sin of the unit y vector(This is the arcsin of the tiltx)</p>
<p>See also: tilt_x</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def heel(self):
    &#34;&#34;&#34;Heel in degrees. SB down is positive [deg].
    This is the inverse sin of the unit y vector(This is the arcsin of the tiltx)

    See also: tilt_x
    &#34;&#34;&#34;
    return np.rad2deg(np.arcsin(self.tilt_x / 100))</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.inertia"><code class="name">var <span class="ident">inertia</span></code></dt>
<dd>
<div class="desc"><p>The linear inertia of the axis in [mT] Aka: "Mass"
- used only for dynamics</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def inertia(self):
    &#34;&#34;&#34;The linear inertia of the axis in [mT] Aka: &#34;Mass&#34;
    - used only for dynamics&#34;&#34;&#34;
    return self._inertia</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.inertia_position"><code class="name">var <span class="ident">inertia_position</span></code></dt>
<dd>
<div class="desc"><p>The position of the center of inertia. Aka: "cog" [m,m,m] (local axis)
- used only for dynamics
- defined in local axis system</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def inertia_position(self):
    &#34;&#34;&#34;The position of the center of inertia. Aka: &#34;cog&#34; [m,m,m] (local axis)
    - used only for dynamics
    - defined in local axis system&#34;&#34;&#34;
    return tuple(self._inertia_position)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.inertia_radii"><code class="name">var <span class="ident">inertia_radii</span></code></dt>
<dd>
<div class="desc"><p>The radii of gyration of the inertia [m,m,m] (local axis)</p>
<p>Used to calculate the mass moments of inertia via</p>
<p>Ixx = rxx^2 * inertia
Iyy = rxx^2 * inertia
Izz = rxx^2 * inertia</p>
<p>Note that DAVE does not directly support cross terms in the interia matrix of an axis system. If you want to
use cross terms then combine multiple axis system to reach the same result. This is because inertia matrices with
diagonal terms can not be translated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def inertia_radii(self):
    &#34;&#34;&#34;The radii of gyration of the inertia [m,m,m] (local axis)

    Used to calculate the mass moments of inertia via

    Ixx = rxx^2 * inertia
    Iyy = rxx^2 * inertia
    Izz = rxx^2 * inertia

    Note that DAVE does not directly support cross terms in the interia matrix of an axis system. If you want to
    use cross terms then combine multiple axis system to reach the same result. This is because inertia matrices with
    diagonal terms can not be translated.
    &#34;&#34;&#34;
    return np.array(self._inertia_radii, dtype=float)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"><p>Determines the parent of the axis. Should either be another axis or 'None'</p>
<p>Other axis may be refered to by reference or by name (str). So the following are identical</p>
<pre><code>p = s.new_axis('parent_axis')
c = s.new_axis('child axis')

c.parent = p
c.parent = 'parent_axis'
</code></pre>
<p>To define that an axis does not have a parent use</p>
<pre><code>c.parent = None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self):
    &#34;&#34;&#34;Determines the parent of the axis. Should either be another axis or &#39;None&#39;

    Other axis may be refered to by reference or by name (str). So the following are identical

        p = s.new_axis(&#39;parent_axis&#39;)
        c = s.new_axis(&#39;child axis&#39;)

        c.parent = p
        c.parent = &#39;parent_axis&#39;

    To define that an axis does not have a parent use

        c.parent = None

    &#34;&#34;&#34;
    return super().parent</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"><p>Position of the axis (parent axis) [m,m,m]</p>
<p>These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def position(self):
    &#34;&#34;&#34;Position of the axis (parent axis) [m,m,m]

    These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)&#34;&#34;&#34;
    return self._vfNode.position</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.rotation"><code class="name">var <span class="ident">rotation</span></code></dt>
<dd>
<div class="desc"><p>Rotation of the axis about its origin (rx,ry,rz).
Defined as a rotation about an axis where the direction of the axis is (rx,ry,rz) and the angle of rotation is |(rx,ry,rz| degrees.
These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rotation(self):
    &#34;&#34;&#34;Rotation of the axis about its origin (rx,ry,rz).
    Defined as a rotation about an axis where the direction of the axis is (rx,ry,rz) and the angle of rotation is |(rx,ry,rz| degrees.
    These are the expressed on the coordinate system of the parent (if any) or the global axis system (if no parent)&#34;&#34;&#34;
    return np.rad2deg(self._vfNode.rotation)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.rx"><code class="name">var <span class="ident">rx</span></code></dt>
<dd>
<div class="desc"><p>The x-component of the rotation vector [degrees] (parent axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rx(self):
    &#34;&#34;&#34;The x-component of the rotation vector [degrees] (parent axis)&#34;&#34;&#34;
    return self.rotation[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.ry"><code class="name">var <span class="ident">ry</span></code></dt>
<dd>
<div class="desc"><p>The y-component of the rotation vector [degrees] (parent axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ry(self):
    &#34;&#34;&#34;The y-component of the rotation vector [degrees] (parent axis)&#34;&#34;&#34;
    return self.rotation[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.rz"><code class="name">var <span class="ident">rz</span></code></dt>
<dd>
<div class="desc"><p>The z-component of the rotation vector [degrees], (parent axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rz(self):
    &#34;&#34;&#34;The z-component of the rotation vector [degrees], (parent axis)&#34;&#34;&#34;
    return self.rotation[2]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.tilt_x"><code class="name">var <span class="ident">tilt_x</span></code></dt>
<dd>
<div class="desc"><p>Tilt percentage. This is the z-component of the unit y vector [%].</p>
<p>See Also: heel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tilt_x(self):
    &#34;&#34;&#34;Tilt percentage. This is the z-component of the unit y vector [%].

    See Also: heel
    &#34;&#34;&#34;
    y = (0, 1, 0)
    uy = self.to_glob_direction(y)
    return float(100 * uy[2])</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.tilt_y"><code class="name">var <span class="ident">tilt_y</span></code></dt>
<dd>
<div class="desc"><p>Tilt percentage. This is the z-component of the unit -x vector [%].
So a positive rotation about the y axis results in a positive tilt_y.</p>
<p>See Also: trim</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tilt_y(self):
    &#34;&#34;&#34;Tilt percentage. This is the z-component of the unit -x vector [%].
    So a positive rotation about the y axis results in a positive tilt_y.

    See Also: trim
    &#34;&#34;&#34;
    x = (-1, 0, 0)
    ux = self.to_glob_direction(x)
    return float(100 * ux[2])</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.trim"><code class="name">var <span class="ident">trim</span></code></dt>
<dd>
<div class="desc"><p>Trim in degrees. Bow-down is positive [deg].</p>
<p>This is the inverse sin of the unit -x vector(This is the arcsin of the tilt_y)</p>
<p>See also: tilt_y</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def trim(self):
    &#34;&#34;&#34;Trim in degrees. Bow-down is positive [deg].

    This is the inverse sin of the unit -x vector(This is the arcsin of the tilt_y)

    See also: tilt_y
    &#34;&#34;&#34;
    return np.rad2deg(np.arcsin(self.tilt_y / 100))</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.ux"><code class="name">var <span class="ident">ux</span></code></dt>
<dd>
<div class="desc"><p>The unit x axis [m,m,m] (Global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ux(self):
    &#34;&#34;&#34;The unit x axis [m,m,m] (Global axis)&#34;&#34;&#34;
    return self.to_glob_direction((1, 0, 0))</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.uy"><code class="name">var <span class="ident">uy</span></code></dt>
<dd>
<div class="desc"><p>The unit y axis [m,m,m] (Global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def uy(self):
    &#34;&#34;&#34;The unit y axis [m,m,m] (Global axis)&#34;&#34;&#34;
    return self.to_glob_direction((0, 1, 0))</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.uz"><code class="name">var <span class="ident">uz</span></code></dt>
<dd>
<div class="desc"><p>The unit z axis [m,m,m] (Global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def uz(self):
    &#34;&#34;&#34;The unit z axis [m,m,m] (Global axis)&#34;&#34;&#34;
    return self.to_glob_direction((0, 0, 1))</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.x"><code class="name">var <span class="ident">x</span></code></dt>
<dd>
<div class="desc"><p>The x-component of the position vector (parent axis) [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x(self):
    &#34;&#34;&#34;The x-component of the position vector (parent axis) [m]&#34;&#34;&#34;
    return self.position[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.y"><code class="name">var <span class="ident">y</span></code></dt>
<dd>
<div class="desc"><p>The y-component of the position vector (parent axis) [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def y(self):
    &#34;&#34;&#34;The y-component of the position vector (parent axis) [m]&#34;&#34;&#34;
    return self.position[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.z"><code class="name">var <span class="ident">z</span></code></dt>
<dd>
<div class="desc"><p>The z-component of the position vector (parent axis) [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z(self):
    &#34;&#34;&#34;The z-component of the position vector (parent axis) [m]&#34;&#34;&#34;
    return self.position[2]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.Axis.give_load_shear_moment_diagram"><code class="name flex">
<span>def <span class="ident">give_load_shear_moment_diagram</span></span>(<span>self, axis_system=None) ->Â <a title="DAVE.scene.LoadShearMomentDiagram" href="#DAVE.scene.LoadShearMomentDiagram">LoadShearMomentDiagram</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a LoadShearMoment diagram</p>
<h2 id="args">Args</h2>
<p>axis_system : optional : coordinate system [axis node] to be used for calculation of the diagram.
Defaults to the local axis system</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def give_load_shear_moment_diagram(
    self, axis_system=None
) -&gt; &#34;LoadShearMomentDiagram&#34;:
    &#34;&#34;&#34;Returns a LoadShearMoment diagram

    Args:
        axis_system : optional : coordinate system [axis node] to be used for calculation of the diagram.
        Defaults to the local axis system
    &#34;&#34;&#34;

    if axis_system is None:
        axis_system = self

    assert isinstance(axis_system, Axis), ValueError(
        f&#34;axis_system shall be an instance of Axis, but it is of type {type(axis_system)}&#34;
    )

    # calculate in the right global direction
    glob_dir = axis_system.to_glob_direction((1, 0, 0))
    self._scene._vfc.calculateBendingMoments(*glob_dir)

    lsm = self._vfNode.getBendingMomentDiagram(axis_system._vfNode)

    return LoadShearMomentDiagram(lsm)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.set_fixed"><code class="name flex">
<span>def <span class="ident">set_fixed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets .fixed to (True,True,True,True,True,True)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fixed(self):
    &#34;&#34;&#34;Sets .fixed to (True,True,True,True,True,True)&#34;&#34;&#34;

    self._vfNode.set_fixed()</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.set_free"><code class="name flex">
<span>def <span class="ident">set_free</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets .fixed to (False,False,False,False,False,False)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_free(self):
    &#34;&#34;&#34;Sets .fixed to (False,False,False,False,False,False)&#34;&#34;&#34;
    self._vfNode.set_free()</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.to_glob_direction"><code class="name flex">
<span>def <span class="ident">to_glob_direction</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the global direction of a point in the local axis system.
This considers only the rotation of the axis system.
See Also: to_glob_position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_glob_direction(self, value):
    &#34;&#34;&#34;Returns the global direction of a point in the local axis system.
    This considers only the rotation of the axis system.
    See Also: to_glob_position&#34;&#34;&#34;
    return self._vfNode.local_to_global_vector(value)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.to_glob_position"><code class="name flex">
<span>def <span class="ident">to_glob_position</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the global position of a point in the local axis system.
This considers the position and the rotation of the axis system.
See Also: to_glob_direction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_glob_position(self, value):
    &#34;&#34;&#34;Returns the global position of a point in the local axis system.
    This considers the position and the rotation of the axis system.
    See Also: to_glob_direction
    &#34;&#34;&#34;
    return self._vfNode.local_to_global_point(value)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.to_glob_rotation"><code class="name flex">
<span>def <span class="ident">to_glob_rotation</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the global rotation. Used for rotating rotations.
See Also: to_loc_position, to_loc_direction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_glob_rotation(self, value):
    &#34;&#34;&#34;Returns the global rotation. Used for rotating rotations.
    See Also: to_loc_position, to_loc_direction
    &#34;&#34;&#34;
    return np.rad2deg(self._vfNode.local_to_global_rotation(np.deg2rad(value)))</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.to_loc_direction"><code class="name flex">
<span>def <span class="ident">to_loc_direction</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the local direction of a point in the global axis system.
This considers only the rotation of the axis system.
See Also: to_loc_position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_loc_direction(self, value):
    &#34;&#34;&#34;Returns the local direction of a point in the global axis system.
    This considers only the rotation of the axis system.
    See Also: to_loc_position
    &#34;&#34;&#34;
    return self._vfNode.global_to_local_vector(value)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.to_loc_position"><code class="name flex">
<span>def <span class="ident">to_loc_position</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the local position of a point in the global axis system.
This considers the position and the rotation of the axis system.
See Also: to_loc_direction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_loc_position(self, value):
    &#34;&#34;&#34;Returns the local position of a point in the global axis system.
    This considers the position and the rotation of the axis system.
    See Also: to_loc_direction
    &#34;&#34;&#34;
    return self._vfNode.global_to_local_point(value)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Axis.to_loc_rotation"><code class="name flex">
<span>def <span class="ident">to_loc_rotation</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the local rotation. Used for rotating rotations.
See Also: to_loc_position, to_loc_direction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_loc_rotation(self, value):
    &#34;&#34;&#34;Returns the local rotation. Used for rotating rotations.
    See Also: to_loc_position, to_loc_direction
    &#34;&#34;&#34;
    return np.rad2deg(self._vfNode.global_to_local_rotation(np.deg2rad(value)))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.NodeWithParentAndFootprint" href="#DAVE.scene.NodeWithParentAndFootprint">NodeWithParentAndFootprint</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.NodeWithParentAndFootprint.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParentAndFootprint.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParentAndFootprint.footprint" href="#DAVE.scene.NodeWithParentAndFootprint.footprint">footprint</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParentAndFootprint.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParentAndFootprint.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParentAndFootprint.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParentAndFootprint.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.BallastSystem"><code class="flex name class">
<span>class <span class="ident">BallastSystem</span></span>
<span>(</span><span>scene, parent)</span>
</code></dt>
<dd>
<div class="desc"><p>A BallastSystem is a group of Tank objects.</p>
<p>The tank objects are created separately and only their references are assigned to this ballast-system object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BallastSystem(Node):
    &#34;&#34;&#34;A BallastSystem is a group of Tank objects.

    The tank objects are created separately and only their references are assigned to this ballast-system object.

    &#34;&#34;&#34;

    def __init__(self, scene, parent):
        super().__init__(scene)

        self.tanks = []
        &#34;&#34;&#34;List of Tank objects&#34;&#34;&#34;

        self.frozen = []
        &#34;&#34;&#34;List of names of frozen tanks - The contents of a frozen tank should not be changed&#34;&#34;&#34;

        self.parent = parent

    def new_tank(
        self, name, position, capacity_kN, rho=1.025, frozen=False, actual_fill=0
    ):
        &#34;&#34;&#34;Adds a new cubic shaped tank with the given volume as derived from capacity and rho

        Warning: provided for backwards compatibility only.
        &#34;&#34;&#34;

        from warnings import warn

        warn(
            &#34;BallastSystem.new_tank is outdated and may be removed in a future version.&#34;
        )

        tnk = self._scene.new_tank(name, parent=self.parent, density=rho)
        volume = capacity_kN / (9.81 * rho)
        side = volume ** (1 / 3)
        tnk.trimesh.load_file(
            &#34;res: cube.obj&#34;,
            scale=(side, side, side),
            rotation=(0.0, 0.0, 0.0),
            offset=position,
        )
        if actual_fill &gt; 0:
            tnk.fill_pct = actual_fill

        if frozen:
            tnk.frozen = frozen

        self.tanks.append(tnk)

        return tnk

    # for gui
    def change_parent_to(self, new_parent):
        if not (isinstance(new_parent, Axis) or new_parent is None):
            raise ValueError(
                &#34;Visuals can only be attached to an axis (or derived) or None&#34;
            )
        self.parent = new_parent

    # for node
    def depends_on(self):
        return [self.parent, *self.tanks]

    def is_frozen(self, name):
        &#34;&#34;&#34;Returns True if the tank with this name if frozen&#34;&#34;&#34;
        return name in self.frozen

    def reorder_tanks(self, names):
        &#34;&#34;&#34;Places tanks with given names at the top of the list. Other tanks are appended afterwards in original order.

        For a complete re-order give all tank names.

        Example:
            let tanks be &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;

            then re_order_tanks([&#39;e&#39;,&#39;b&#39;]) will result in [&#39;e&#39;,&#39;b&#39;,&#39;a&#39;,&#39;c&#39;,&#39;d&#39;]
        &#34;&#34;&#34;
        for name in names:
            if name not in self.tank_names():
                raise ValueError(&#34;No tank with name {}&#34;.format(name))

        old_tanks = self.tanks.copy()
        self.tanks.clear()
        to_be_deleted = list()

        for name in names:
            for tank in old_tanks:
                if tank.name == name:
                    self.tanks.append(tank)
                    to_be_deleted.append(tank)

        for tank in to_be_deleted:
            old_tanks.remove(tank)

        for tank in old_tanks:
            self.tanks.append(tank)

    def order_tanks_by_elevation(self):
        &#34;&#34;&#34;Re-orders the existing tanks such that the lowest tanks are higher in the list&#34;&#34;&#34;

        zs = [tank.cog_when_full[2] for tank in self.tanks]
        inds = np.argsort(zs)
        self.tanks = [self.tanks[i] for i in inds]

    def order_tanks_by_distance_from_point(self, point, reverse=False):
        &#34;&#34;&#34;Re-orders the existing tanks such that the tanks *furthest* from the point are first on the list

        Args:
            point : (x,y,z)  - reference point to determine the distance to
            reverse: (False) - order in reverse order: tanks nearest to the points first on list


        &#34;&#34;&#34;
        pos = [tank.cog_when_full for tank in self.tanks]
        pos = np.array(pos, dtype=float)
        pos -= np.array(point)

        dist = np.apply_along_axis(np.linalg.norm, 1, pos)

        if reverse:
            inds = np.argsort(dist)
        else:
            inds = np.argsort(-dist)

        self.tanks = [self.tanks[i] for i in inds]

    def order_tanks_to_maximize_inertia_moment(self):
        &#34;&#34;&#34;Re-order tanks such that tanks furthest from center of system are first on the list&#34;&#34;&#34;
        self._order_tanks_to_inertia_moment()

    def order_tanks_to_minimize_inertia_moment(self):
        &#34;&#34;&#34;Re-order tanks such that tanks nearest to center of system are first on the list&#34;&#34;&#34;
        self._order_tanks_to_inertia_moment(maximize=False)

    def _order_tanks_to_inertia_moment(self, maximize=True):
        &#34;&#34;&#34;Re-order tanks such that tanks furthest away from center of system are first on the list&#34;&#34;&#34;
        pos = [tank.cog_when_full for tank in self.tanks]
        m = [tank.capacity for tank in self.tanks]
        pos = np.array(pos, dtype=float)
        mxmymz = np.vstack((m, m, m)).transpose() * pos
        total = np.sum(m)
        point = sum(mxmymz) / total

        if maximize:
            self.order_tanks_by_distance_from_point(point)
        else:
            self.order_tanks_by_distance_from_point(point, reverse=True)

    def tank_names(self):
        return [tank.name for tank in self.tanks]

    def fill_tank(self, name, fill):

        assert1f(fill, &#34;tank fill&#34;)

        for tank in self.tanks:
            if tank.name == name:
                tank.pct = fill
                return
        raise ValueError(&#34;No tank with name {}&#34;.format(name))

    def xyzw(self):
        &#34;&#34;&#34;Gets the current ballast cog in GLOBAL axis system weight from the tanks

        Returns:
            (x,y,z), weight [mT]
        &#34;&#34;&#34;
        &#34;&#34;&#34;Calculates the weight and inertia properties of the tanks&#34;&#34;&#34;

        mxmymz = np.array((0.0, 0.0, 0.0))
        wt = 0

        for tank in self.tanks:
            w = tank.volume * tank.density
            p = np.array(tank.cog, dtype=float)
            mxmymz += p * w

            wt += w

        if wt == 0:
            xyz = np.array((0.0, 0.0, 0.0))
        else:
            xyz = mxmymz / wt

        return xyz, wt

    def empty_all_usable_tanks(self):
        &#34;&#34;&#34;Empties all non-frozen tanks.
        Returns a list with tank number and fill percentage of all affected tanks. This can be used to restore the
        ballast situation as it was before emptying.

        See also: restore tank fillings
        &#34;&#34;&#34;
        restore = []

        for i, t in enumerate(self.tanks):
            if not self.is_frozen(t.name):
                restore.append((i, t.fill_pct))
                t.fill_pct = 0

        return restore

    def restore_tank_fillings(self, restore):
        &#34;&#34;&#34;Restores the tank fillings as per restore.

        Restore is typically obtained from the &#34;empty_all_usable_tanks&#34; function.

        See Also: empty_all_usable_tanks
        &#34;&#34;&#34;

        for r in restore:
            i, pct = r
            self.tanks[i].fill_pct = pct

    def tank(self, name):

        for t in self.tanks:
            if t.name == name:
                return t
        raise ValueError(&#34;No tank with name {}&#34;.format(name))

    def __getitem__(self, item):
        return self.tank(item)

    @property
    def cogx(self):
        &#34;&#34;&#34;X position of combined CoG of all tank contents in the ballast-system. (global coordinate) [m]&#34;&#34;&#34;
        return self.cog[0]

    @property
    def cogy(self):
        &#34;&#34;&#34;Y position of combined CoG of all tank contents in the ballast-system. (global coordinate) [m]&#34;&#34;&#34;
        return self.cog[1]

    @property
    def cogz(self):
        &#34;&#34;&#34;Z position of combined CoG of all tank contents in the ballast-system. (global coordinate) [m]&#34;&#34;&#34;
        return self.cog[2]

    @property
    def cog(self):
        &#34;&#34;&#34;Combined CoG of all tank contents in the ballast-system. (global coordinate) [m,m,m]&#34;&#34;&#34;
        cog, wt = self.xyzw()
        return (cog[0], cog[1], cog[2])

    @property
    def weight(self):
        &#34;&#34;&#34;Total weight of all tank fillings in the ballast system [kN]&#34;&#34;&#34;
        cog, wt = self.xyzw()
        return wt * 9.81

    def give_python_code(self):
        code = &#34;\n# code for {} and its tanks&#34;.format(self.name)

        code += &#34;\nbs = s.new_ballastsystem(&#39;{}&#39;, parent = &#39;{}&#39;)&#34;.format(
            self.name, self.parent.name
        )

        for tank in self.tanks:
            code += &#34;\nbs.tanks.append(s[&#39;{}&#39;])&#34;.format(tank.name)

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.BallastSystem.cog"><code class="name">var <span class="ident">cog</span></code></dt>
<dd>
<div class="desc"><p>Combined CoG of all tank contents in the ballast-system. (global coordinate) [m,m,m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cog(self):
    &#34;&#34;&#34;Combined CoG of all tank contents in the ballast-system. (global coordinate) [m,m,m]&#34;&#34;&#34;
    cog, wt = self.xyzw()
    return (cog[0], cog[1], cog[2])</code></pre>
</details>
</dd>
<dt id="DAVE.scene.BallastSystem.cogx"><code class="name">var <span class="ident">cogx</span></code></dt>
<dd>
<div class="desc"><p>X position of combined CoG of all tank contents in the ballast-system. (global coordinate) [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cogx(self):
    &#34;&#34;&#34;X position of combined CoG of all tank contents in the ballast-system. (global coordinate) [m]&#34;&#34;&#34;
    return self.cog[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.BallastSystem.cogy"><code class="name">var <span class="ident">cogy</span></code></dt>
<dd>
<div class="desc"><p>Y position of combined CoG of all tank contents in the ballast-system. (global coordinate) [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cogy(self):
    &#34;&#34;&#34;Y position of combined CoG of all tank contents in the ballast-system. (global coordinate) [m]&#34;&#34;&#34;
    return self.cog[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.BallastSystem.cogz"><code class="name">var <span class="ident">cogz</span></code></dt>
<dd>
<div class="desc"><p>Z position of combined CoG of all tank contents in the ballast-system. (global coordinate) [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cogz(self):
    &#34;&#34;&#34;Z position of combined CoG of all tank contents in the ballast-system. (global coordinate) [m]&#34;&#34;&#34;
    return self.cog[2]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.BallastSystem.frozen"><code class="name">var <span class="ident">frozen</span></code></dt>
<dd>
<div class="desc"><p>List of names of frozen tanks - The contents of a frozen tank should not be changed</p></div>
</dd>
<dt id="DAVE.scene.BallastSystem.tanks"><code class="name">var <span class="ident">tanks</span></code></dt>
<dd>
<div class="desc"><p>List of Tank objects</p></div>
</dd>
<dt id="DAVE.scene.BallastSystem.weight"><code class="name">var <span class="ident">weight</span></code></dt>
<dd>
<div class="desc"><p>Total weight of all tank fillings in the ballast system [kN]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def weight(self):
    &#34;&#34;&#34;Total weight of all tank fillings in the ballast system [kN]&#34;&#34;&#34;
    cog, wt = self.xyzw()
    return wt * 9.81</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.BallastSystem.change_parent_to"><code class="name flex">
<span>def <span class="ident">change_parent_to</span></span>(<span>self, new_parent)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_parent_to(self, new_parent):
    if not (isinstance(new_parent, Axis) or new_parent is None):
        raise ValueError(
            &#34;Visuals can only be attached to an axis (or derived) or None&#34;
        )
    self.parent = new_parent</code></pre>
</details>
</dd>
<dt id="DAVE.scene.BallastSystem.empty_all_usable_tanks"><code class="name flex">
<span>def <span class="ident">empty_all_usable_tanks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Empties all non-frozen tanks.
Returns a list with tank number and fill percentage of all affected tanks. This can be used to restore the
ballast situation as it was before emptying.</p>
<p>See also: restore tank fillings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def empty_all_usable_tanks(self):
    &#34;&#34;&#34;Empties all non-frozen tanks.
    Returns a list with tank number and fill percentage of all affected tanks. This can be used to restore the
    ballast situation as it was before emptying.

    See also: restore tank fillings
    &#34;&#34;&#34;
    restore = []

    for i, t in enumerate(self.tanks):
        if not self.is_frozen(t.name):
            restore.append((i, t.fill_pct))
            t.fill_pct = 0

    return restore</code></pre>
</details>
</dd>
<dt id="DAVE.scene.BallastSystem.fill_tank"><code class="name flex">
<span>def <span class="ident">fill_tank</span></span>(<span>self, name, fill)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill_tank(self, name, fill):

    assert1f(fill, &#34;tank fill&#34;)

    for tank in self.tanks:
        if tank.name == name:
            tank.pct = fill
            return
    raise ValueError(&#34;No tank with name {}&#34;.format(name))</code></pre>
</details>
</dd>
<dt id="DAVE.scene.BallastSystem.is_frozen"><code class="name flex">
<span>def <span class="ident">is_frozen</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the tank with this name if frozen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_frozen(self, name):
    &#34;&#34;&#34;Returns True if the tank with this name if frozen&#34;&#34;&#34;
    return name in self.frozen</code></pre>
</details>
</dd>
<dt id="DAVE.scene.BallastSystem.new_tank"><code class="name flex">
<span>def <span class="ident">new_tank</span></span>(<span>self, name, position, capacity_kN, rho=1.025, frozen=False, actual_fill=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new cubic shaped tank with the given volume as derived from capacity and rho</p>
<p>Warning: provided for backwards compatibility only.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_tank(
    self, name, position, capacity_kN, rho=1.025, frozen=False, actual_fill=0
):
    &#34;&#34;&#34;Adds a new cubic shaped tank with the given volume as derived from capacity and rho

    Warning: provided for backwards compatibility only.
    &#34;&#34;&#34;

    from warnings import warn

    warn(
        &#34;BallastSystem.new_tank is outdated and may be removed in a future version.&#34;
    )

    tnk = self._scene.new_tank(name, parent=self.parent, density=rho)
    volume = capacity_kN / (9.81 * rho)
    side = volume ** (1 / 3)
    tnk.trimesh.load_file(
        &#34;res: cube.obj&#34;,
        scale=(side, side, side),
        rotation=(0.0, 0.0, 0.0),
        offset=position,
    )
    if actual_fill &gt; 0:
        tnk.fill_pct = actual_fill

    if frozen:
        tnk.frozen = frozen

    self.tanks.append(tnk)

    return tnk</code></pre>
</details>
</dd>
<dt id="DAVE.scene.BallastSystem.order_tanks_by_distance_from_point"><code class="name flex">
<span>def <span class="ident">order_tanks_by_distance_from_point</span></span>(<span>self, point, reverse=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Re-orders the existing tanks such that the tanks <em>furthest</em> from the point are first on the list</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>(x,y,z)
- reference point to determine the distance to</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>reverse</code></strong></dt>
<dd>(False) - order in reverse order: tanks nearest to the points first on list</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order_tanks_by_distance_from_point(self, point, reverse=False):
    &#34;&#34;&#34;Re-orders the existing tanks such that the tanks *furthest* from the point are first on the list

    Args:
        point : (x,y,z)  - reference point to determine the distance to
        reverse: (False) - order in reverse order: tanks nearest to the points first on list


    &#34;&#34;&#34;
    pos = [tank.cog_when_full for tank in self.tanks]
    pos = np.array(pos, dtype=float)
    pos -= np.array(point)

    dist = np.apply_along_axis(np.linalg.norm, 1, pos)

    if reverse:
        inds = np.argsort(dist)
    else:
        inds = np.argsort(-dist)

    self.tanks = [self.tanks[i] for i in inds]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.BallastSystem.order_tanks_by_elevation"><code class="name flex">
<span>def <span class="ident">order_tanks_by_elevation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Re-orders the existing tanks such that the lowest tanks are higher in the list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order_tanks_by_elevation(self):
    &#34;&#34;&#34;Re-orders the existing tanks such that the lowest tanks are higher in the list&#34;&#34;&#34;

    zs = [tank.cog_when_full[2] for tank in self.tanks]
    inds = np.argsort(zs)
    self.tanks = [self.tanks[i] for i in inds]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.BallastSystem.order_tanks_to_maximize_inertia_moment"><code class="name flex">
<span>def <span class="ident">order_tanks_to_maximize_inertia_moment</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Re-order tanks such that tanks furthest from center of system are first on the list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order_tanks_to_maximize_inertia_moment(self):
    &#34;&#34;&#34;Re-order tanks such that tanks furthest from center of system are first on the list&#34;&#34;&#34;
    self._order_tanks_to_inertia_moment()</code></pre>
</details>
</dd>
<dt id="DAVE.scene.BallastSystem.order_tanks_to_minimize_inertia_moment"><code class="name flex">
<span>def <span class="ident">order_tanks_to_minimize_inertia_moment</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Re-order tanks such that tanks nearest to center of system are first on the list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order_tanks_to_minimize_inertia_moment(self):
    &#34;&#34;&#34;Re-order tanks such that tanks nearest to center of system are first on the list&#34;&#34;&#34;
    self._order_tanks_to_inertia_moment(maximize=False)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.BallastSystem.reorder_tanks"><code class="name flex">
<span>def <span class="ident">reorder_tanks</span></span>(<span>self, names)</span>
</code></dt>
<dd>
<div class="desc"><p>Places tanks with given names at the top of the list. Other tanks are appended afterwards in original order.</p>
<p>For a complete re-order give all tank names.</p>
<h2 id="example">Example</h2>
<p>let tanks be 'a','b','c','d','e'</p>
<p>then re_order_tanks(['e','b']) will result in ['e','b','a','c','d']</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reorder_tanks(self, names):
    &#34;&#34;&#34;Places tanks with given names at the top of the list. Other tanks are appended afterwards in original order.

    For a complete re-order give all tank names.

    Example:
        let tanks be &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;

        then re_order_tanks([&#39;e&#39;,&#39;b&#39;]) will result in [&#39;e&#39;,&#39;b&#39;,&#39;a&#39;,&#39;c&#39;,&#39;d&#39;]
    &#34;&#34;&#34;
    for name in names:
        if name not in self.tank_names():
            raise ValueError(&#34;No tank with name {}&#34;.format(name))

    old_tanks = self.tanks.copy()
    self.tanks.clear()
    to_be_deleted = list()

    for name in names:
        for tank in old_tanks:
            if tank.name == name:
                self.tanks.append(tank)
                to_be_deleted.append(tank)

    for tank in to_be_deleted:
        old_tanks.remove(tank)

    for tank in old_tanks:
        self.tanks.append(tank)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.BallastSystem.restore_tank_fillings"><code class="name flex">
<span>def <span class="ident">restore_tank_fillings</span></span>(<span>self, restore)</span>
</code></dt>
<dd>
<div class="desc"><p>Restores the tank fillings as per restore.</p>
<p>Restore is typically obtained from the "empty_all_usable_tanks" function.</p>
<p>See Also: empty_all_usable_tanks</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restore_tank_fillings(self, restore):
    &#34;&#34;&#34;Restores the tank fillings as per restore.

    Restore is typically obtained from the &#34;empty_all_usable_tanks&#34; function.

    See Also: empty_all_usable_tanks
    &#34;&#34;&#34;

    for r in restore:
        i, pct = r
        self.tanks[i].fill_pct = pct</code></pre>
</details>
</dd>
<dt id="DAVE.scene.BallastSystem.tank"><code class="name flex">
<span>def <span class="ident">tank</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tank(self, name):

    for t in self.tanks:
        if t.name == name:
            return t
    raise ValueError(&#34;No tank with name {}&#34;.format(name))</code></pre>
</details>
</dd>
<dt id="DAVE.scene.BallastSystem.tank_names"><code class="name flex">
<span>def <span class="ident">tank_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tank_names(self):
    return [tank.name for tank in self.tanks]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.BallastSystem.xyzw"><code class="name flex">
<span>def <span class="ident">xyzw</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the current ballast cog in GLOBAL axis system weight from the tanks</p>
<h2 id="returns">Returns</h2>
<p>(x,y,z), weight [mT]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xyzw(self):
    &#34;&#34;&#34;Gets the current ballast cog in GLOBAL axis system weight from the tanks

    Returns:
        (x,y,z), weight [mT]
    &#34;&#34;&#34;
    &#34;&#34;&#34;Calculates the weight and inertia properties of the tanks&#34;&#34;&#34;

    mxmymz = np.array((0.0, 0.0, 0.0))
    wt = 0

    for tank in self.tanks:
        w = tank.volume * tank.density
        p = np.array(tank.cog, dtype=float)
        mxmymz += p * w

        wt += w

    if wt == 0:
        xyz = np.array((0.0, 0.0, 0.0))
    else:
        xyz = mxmymz / wt

    return xyz, wt</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.Node.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.Node.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.Node.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.Node.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.Node.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.Beam"><code class="flex name class">
<span>class <span class="ident">Beam</span></span>
<span>(</span><span>scene, node)</span>
</code></dt>
<dd>
<div class="desc"><p>A LinearBeam models a FEM-like linear beam element.</p>
<p>A LinearBeam node connects two Axis elements</p>
<p>By definition the beam runs in the X-direction of the nodeA axis system. So it may be needed to create a
dedicated Axis element for the beam to control the orientation.</p>
<p>The beam is defined using the following properties:</p>
<ul>
<li>EIy
- bending stiffness about y-axis</li>
<li>EIz
- bending stiffness about z-axis</li>
<li>GIp
- torsional stiffness about x-axis</li>
<li>EA
- axis stiffness in x-direction</li>
<li>L
- the un-stretched length of the beam</li>
<li>mass - mass of the beam in [mT]</li>
</ul>
<p>The beam element is in rest if the nodeB axis system</p>
<ol>
<li>has the same global orientation as the nodeA system</li>
<li>is at global position equal to the global position of local point (L,0,0) of the nodeA axis. (aka: the end of the beam)</li>
</ol>
<p>The scene.new_linearbeam automatically creates a dedicated axis system for each end of the beam. The orientation of this axis-system
is determined as follows:</p>
<p>First the direction from nodeA to nodeB is determined: D
The axis of rotation is the cross-product of the unit x-axis and D
AXIS = ux x D
The angle of rotation is the angle between the nodeA x-axis and D
The rotation about the rotated X-axis is undefined.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Beam(CoreConnectedNode):
    &#34;&#34;&#34;A LinearBeam models a FEM-like linear beam element.

    A LinearBeam node connects two Axis elements

    By definition the beam runs in the X-direction of the nodeA axis system. So it may be needed to create a
    dedicated Axis element for the beam to control the orientation.

    The beam is defined using the following properties:

    *  EIy  - bending stiffness about y-axis
    *  EIz  - bending stiffness about z-axis
    *  GIp  - torsional stiffness about x-axis
    *  EA   - axis stiffness in x-direction
    *  L    - the un-stretched length of the beam
    *  mass - mass of the beam in [mT]

    The beam element is in rest if the nodeB axis system

    1. has the same global orientation as the nodeA system
    2. is at global position equal to the global position of local point (L,0,0) of the nodeA axis. (aka: the end of the beam)

    The scene.new_linearbeam automatically creates a dedicated axis system for each end of the beam. The orientation of this axis-system
    is determined as follows:

    First the direction from nodeA to nodeB is determined: D
    The axis of rotation is the cross-product of the unit x-axis and D    AXIS = ux x D
    The angle of rotation is the angle between the nodeA x-axis and D
    The rotation about the rotated X-axis is undefined.

    &#34;&#34;&#34;

    def __init__(self, scene, node):
        super().__init__(scene, node)
        self._nodeA = None
        self._nodeB = None

    def depends_on(self):
        return [self._nodeA, self._nodeB]

    @property
    def n_segments(self):
        return self._vfNode.nSegments

    @n_segments.setter
    @node_setter_manageable
    @node_setter_observable
    def n_segments(self, value):
        if value &lt; 1:
            raise ValueError(&#34;Number of segments in beam should be 1 or more&#34;)
        self._vfNode.nSegments = int(value)

    @property
    def EIy(self):
        &#34;&#34;&#34;E * Iyy : bending stiffness in the XZ plane [kN m2]

        E is the modulus of elasticity; for steel 190-210 GPa (10^6 kN/m2)
        Iyy is the cross section moment of inertia [m4]
        &#34;&#34;&#34;
        return self._vfNode.EIy

    @EIy.setter
    @node_setter_manageable
    @node_setter_observable
    def EIy(self, value):

        self._vfNode.EIy = value

    @property
    def EIz(self):
        &#34;&#34;&#34;E * Izz : bending stiffness in the XY plane [kN m2]

        E is the modulus of elasticity; for steel 190-210 GPa (10^6 kN/m2)
        Iyy is the cross section moment of inertia [m4]
        &#34;&#34;&#34;
        return self._vfNode.EIz

    @EIz.setter
    @node_setter_manageable
    @node_setter_observable
    def EIz(self, value):

        self._vfNode.EIz = value

    @property
    def GIp(self):
        &#34;&#34;&#34;G * Ipp : torsional stiffness about the X (length) axis [kN m2]

        G is the shear-modulus of elasticity; for steel 75-80 GPa (10^6 kN/m2)
        Ip is the cross section polar moment of inertia [m4]
        &#34;&#34;&#34;
        return self._vfNode.GIp

    @GIp.setter
    @node_setter_manageable
    @node_setter_observable
    def GIp(self, value):

        self._vfNode.GIp = value

    @property
    def EA(self):
        &#34;&#34;&#34;E * A : stiffness in the length direction [kN]

        E is the modulus of elasticity; for steel 190-210 GPa (10^6 kN/m2)
        A is the cross-section area in [m2]
        &#34;&#34;&#34;
        return self._vfNode.EA

    @EA.setter
    @node_setter_manageable
    @node_setter_observable
    def EA(self, value):

        self._vfNode.EA = value

    @property
    def tension_only(self):
        &#34;&#34;&#34;axial stiffness (EA) only applicable to tension [True/False]&#34;&#34;&#34;
        return self._vfNode.tensionOnly

    @tension_only.setter
    @node_setter_manageable
    @node_setter_observable
    def tension_only(self, value):
        assert isinstance(value, bool), ValueError(
            &#34;Value for tension_only shall be True or False&#34;
        )
        self._vfNode.tensionOnly = value

    @property
    def mass(self):
        &#34;&#34;&#34;Mass of the beam in [mT]&#34;&#34;&#34;
        return self._vfNode.Mass

    @mass.setter
    @node_setter_manageable
    @node_setter_observable
    def mass(self, value):

        assert1f(value, &#34;Mass shall be a number&#34;)
        self._vfNode.Mass = value
        pass

    @property
    def L(self):
        &#34;&#34;&#34;Length of the beam in unloaded condition [m]&#34;&#34;&#34;
        return self._vfNode.L

    @L.setter
    @node_setter_manageable
    @node_setter_observable
    def L(self, value):

        self._vfNode.L = value

    @property
    def nodeA(self):
        &#34;&#34;&#34;The axis system that the A-end of the beam is connected to. The beam leaves this axis system along the X-axis&#34;&#34;&#34;
        return self._nodeA

    @nodeA.setter
    @node_setter_manageable
    @node_setter_observable
    def nodeA(self, val):

        val = self._scene._node_from_node_or_str(val)

        if not isinstance(val, Axis):
            raise TypeError(&#34;Provided nodeA should be a Axis&#34;)

        self._nodeA = val
        self._vfNode.master = val._vfNode

    @property
    def nodeB(self):
        &#34;&#34;&#34;The axis system that the B-end of the beam is connected to. The beam arrives at this axis system along the X-axis&#34;&#34;&#34;
        return self._nodeB

    @nodeB.setter
    @node_setter_manageable
    @node_setter_observable
    def nodeB(self, val):

        val = self._scene._node_from_node_or_str(val)
        if not isinstance(val, Axis):
            raise TypeError(&#34;Provided nodeA should be a Axis&#34;)

        self._nodeB = val
        self._vfNode.slave = val._vfNode

    # read-only
    @property
    def moment_A(self):
        &#34;&#34;&#34;Moment on beam at node A (kNm, kNm, kNm) , axis system of node A&#34;&#34;&#34;
        return self._vfNode.moment_on_master

    @property
    def moment_B(self):
        &#34;&#34;&#34;Moment on beam at node B (kNm, kNm, kNm) , axis system of node B&#34;&#34;&#34;
        return self._vfNode.moment_on_slave

    @property
    def tension(self):
        &#34;&#34;&#34;Tension in the beam [kN], negative for compression

        tension is calculated at the midpoints of the beam segments.
        &#34;&#34;&#34;
        return self._vfNode.tension

    @property
    def torsion(self):
        &#34;&#34;&#34;Torsion moment [kNm]. Positive if end B has a positive rotation about the x-axis of end A

        torsion is calculated at the midpoints of the beam segments.
        &#34;&#34;&#34;
        return self._vfNode.torsion

    @property
    def X_nodes(self):
        &#34;&#34;&#34;Returns the x-positions of the end nodes and internal nodes along the length of the beam [m]&#34;&#34;&#34;
        return self._vfNode.x

    @property
    def X_midpoints(self):
        &#34;&#34;&#34;X-positions of the beam centers measured along the length of the beam [m]&#34;&#34;&#34;
        return tuple(
            0.5 * (np.array(self._vfNode.x[:-1]) + np.array(self._vfNode.x[1:]))
        )

    @property
    def global_positions(self):
        &#34;&#34;&#34;Global-positions of the end nodes and internal nodes [m,m,m]&#34;&#34;&#34;
        return np.array(self._vfNode.global_position, dtype=float)

    @property
    def global_orientations(self):
        &#34;&#34;&#34;Global-orientations of the end nodes and internal nodes [deg,deg,deg]&#34;&#34;&#34;
        return np.rad2deg(self._vfNode.global_orientation)

    @property
    def bending(self):
        &#34;&#34;&#34;Bending forces of the end nodes and internal nodes [0, kNm, kNm]&#34;&#34;&#34;
        return np.array(self._vfNode.bending)

    def give_python_code(self):
        code = &#34;# code for beam {}&#34;.format(self.name)
        code += &#34;\ns.new_beam(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            nodeA=&#39;{}&#39;,&#34;.format(self.nodeA.name)
        code += &#34;\n            nodeB=&#39;{}&#39;,&#34;.format(self.nodeB.name)
        code += &#34;\n            n_segments={},&#34;.format(self.n_segments)
        code += &#34;\n            tension_only={},&#34;.format(self.tension_only)
        code += &#34;\n            EIy ={},&#34;.format(self.EIy)
        code += &#34;\n            EIz ={},&#34;.format(self.EIz)
        code += &#34;\n            GIp ={},&#34;.format(self.GIp)
        code += &#34;\n            EA ={},&#34;.format(self.EA)
        code += &#34;\n            mass ={},&#34;.format(self.mass)
        code += &#34;\n            L ={}) # L can possibly be omitted&#34;.format(self.L)

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Beam.EA"><code class="name">var <span class="ident">EA</span></code></dt>
<dd>
<div class="desc"><p>E * A : stiffness in the length direction [kN]</p>
<p>E is the modulus of elasticity; for steel 190-210 GPa (10^6 kN/m2)
A is the cross-section area in [m2]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def EA(self):
    &#34;&#34;&#34;E * A : stiffness in the length direction [kN]

    E is the modulus of elasticity; for steel 190-210 GPa (10^6 kN/m2)
    A is the cross-section area in [m2]
    &#34;&#34;&#34;
    return self._vfNode.EA</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Beam.EIy"><code class="name">var <span class="ident">EIy</span></code></dt>
<dd>
<div class="desc"><p>E * Iyy : bending stiffness in the XZ plane [kN m2]</p>
<p>E is the modulus of elasticity; for steel 190-210 GPa (10^6 kN/m2)
Iyy is the cross section moment of inertia [m4]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def EIy(self):
    &#34;&#34;&#34;E * Iyy : bending stiffness in the XZ plane [kN m2]

    E is the modulus of elasticity; for steel 190-210 GPa (10^6 kN/m2)
    Iyy is the cross section moment of inertia [m4]
    &#34;&#34;&#34;
    return self._vfNode.EIy</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Beam.EIz"><code class="name">var <span class="ident">EIz</span></code></dt>
<dd>
<div class="desc"><p>E * Izz : bending stiffness in the XY plane [kN m2]</p>
<p>E is the modulus of elasticity; for steel 190-210 GPa (10^6 kN/m2)
Iyy is the cross section moment of inertia [m4]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def EIz(self):
    &#34;&#34;&#34;E * Izz : bending stiffness in the XY plane [kN m2]

    E is the modulus of elasticity; for steel 190-210 GPa (10^6 kN/m2)
    Iyy is the cross section moment of inertia [m4]
    &#34;&#34;&#34;
    return self._vfNode.EIz</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Beam.GIp"><code class="name">var <span class="ident">GIp</span></code></dt>
<dd>
<div class="desc"><p>G * Ipp : torsional stiffness about the X (length) axis [kN m2]</p>
<p>G is the shear-modulus of elasticity; for steel 75-80 GPa (10^6 kN/m2)
Ip is the cross section polar moment of inertia [m4]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def GIp(self):
    &#34;&#34;&#34;G * Ipp : torsional stiffness about the X (length) axis [kN m2]

    G is the shear-modulus of elasticity; for steel 75-80 GPa (10^6 kN/m2)
    Ip is the cross section polar moment of inertia [m4]
    &#34;&#34;&#34;
    return self._vfNode.GIp</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Beam.L"><code class="name">var <span class="ident">L</span></code></dt>
<dd>
<div class="desc"><p>Length of the beam in unloaded condition [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def L(self):
    &#34;&#34;&#34;Length of the beam in unloaded condition [m]&#34;&#34;&#34;
    return self._vfNode.L</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Beam.X_midpoints"><code class="name">var <span class="ident">X_midpoints</span></code></dt>
<dd>
<div class="desc"><p>X-positions of the beam centers measured along the length of the beam [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def X_midpoints(self):
    &#34;&#34;&#34;X-positions of the beam centers measured along the length of the beam [m]&#34;&#34;&#34;
    return tuple(
        0.5 * (np.array(self._vfNode.x[:-1]) + np.array(self._vfNode.x[1:]))
    )</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Beam.X_nodes"><code class="name">var <span class="ident">X_nodes</span></code></dt>
<dd>
<div class="desc"><p>Returns the x-positions of the end nodes and internal nodes along the length of the beam [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def X_nodes(self):
    &#34;&#34;&#34;Returns the x-positions of the end nodes and internal nodes along the length of the beam [m]&#34;&#34;&#34;
    return self._vfNode.x</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Beam.bending"><code class="name">var <span class="ident">bending</span></code></dt>
<dd>
<div class="desc"><p>Bending forces of the end nodes and internal nodes [0, kNm, kNm]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bending(self):
    &#34;&#34;&#34;Bending forces of the end nodes and internal nodes [0, kNm, kNm]&#34;&#34;&#34;
    return np.array(self._vfNode.bending)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Beam.global_orientations"><code class="name">var <span class="ident">global_orientations</span></code></dt>
<dd>
<div class="desc"><p>Global-orientations of the end nodes and internal nodes [deg,deg,deg]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def global_orientations(self):
    &#34;&#34;&#34;Global-orientations of the end nodes and internal nodes [deg,deg,deg]&#34;&#34;&#34;
    return np.rad2deg(self._vfNode.global_orientation)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Beam.global_positions"><code class="name">var <span class="ident">global_positions</span></code></dt>
<dd>
<div class="desc"><p>Global-positions of the end nodes and internal nodes [m,m,m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def global_positions(self):
    &#34;&#34;&#34;Global-positions of the end nodes and internal nodes [m,m,m]&#34;&#34;&#34;
    return np.array(self._vfNode.global_position, dtype=float)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Beam.mass"><code class="name">var <span class="ident">mass</span></code></dt>
<dd>
<div class="desc"><p>Mass of the beam in [mT]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mass(self):
    &#34;&#34;&#34;Mass of the beam in [mT]&#34;&#34;&#34;
    return self._vfNode.Mass</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Beam.moment_A"><code class="name">var <span class="ident">moment_A</span></code></dt>
<dd>
<div class="desc"><p>Moment on beam at node A (kNm, kNm, kNm) , axis system of node A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def moment_A(self):
    &#34;&#34;&#34;Moment on beam at node A (kNm, kNm, kNm) , axis system of node A&#34;&#34;&#34;
    return self._vfNode.moment_on_master</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Beam.moment_B"><code class="name">var <span class="ident">moment_B</span></code></dt>
<dd>
<div class="desc"><p>Moment on beam at node B (kNm, kNm, kNm) , axis system of node B</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def moment_B(self):
    &#34;&#34;&#34;Moment on beam at node B (kNm, kNm, kNm) , axis system of node B&#34;&#34;&#34;
    return self._vfNode.moment_on_slave</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Beam.n_segments"><code class="name">var <span class="ident">n_segments</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_segments(self):
    return self._vfNode.nSegments</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Beam.nodeA"><code class="name">var <span class="ident">nodeA</span></code></dt>
<dd>
<div class="desc"><p>The axis system that the A-end of the beam is connected to. The beam leaves this axis system along the X-axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nodeA(self):
    &#34;&#34;&#34;The axis system that the A-end of the beam is connected to. The beam leaves this axis system along the X-axis&#34;&#34;&#34;
    return self._nodeA</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Beam.nodeB"><code class="name">var <span class="ident">nodeB</span></code></dt>
<dd>
<div class="desc"><p>The axis system that the B-end of the beam is connected to. The beam arrives at this axis system along the X-axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nodeB(self):
    &#34;&#34;&#34;The axis system that the B-end of the beam is connected to. The beam arrives at this axis system along the X-axis&#34;&#34;&#34;
    return self._nodeB</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Beam.tension"><code class="name">var <span class="ident">tension</span></code></dt>
<dd>
<div class="desc"><p>Tension in the beam [kN], negative for compression</p>
<p>tension is calculated at the midpoints of the beam segments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tension(self):
    &#34;&#34;&#34;Tension in the beam [kN], negative for compression

    tension is calculated at the midpoints of the beam segments.
    &#34;&#34;&#34;
    return self._vfNode.tension</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Beam.tension_only"><code class="name">var <span class="ident">tension_only</span></code></dt>
<dd>
<div class="desc"><p>axial stiffness (EA) only applicable to tension [True/False]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tension_only(self):
    &#34;&#34;&#34;axial stiffness (EA) only applicable to tension [True/False]&#34;&#34;&#34;
    return self._vfNode.tensionOnly</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Beam.torsion"><code class="name">var <span class="ident">torsion</span></code></dt>
<dd>
<div class="desc"><p>Torsion moment [kNm]. Positive if end B has a positive rotation about the x-axis of end A</p>
<p>torsion is calculated at the midpoints of the beam segments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def torsion(self):
    &#34;&#34;&#34;Torsion moment [kNm]. Positive if end B has a positive rotation about the x-axis of end A

    torsion is calculated at the midpoints of the beam segments.
    &#34;&#34;&#34;
    return self._vfNode.torsion</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.CoreConnectedNode.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.Buoyancy"><code class="flex name class">
<span>class <span class="ident">Buoyancy</span></span>
<span>(</span><span>scene, vfBuoyancy)</span>
</code></dt>
<dd>
<div class="desc"><p>Buoyancy provides a buoyancy force based on a buoyancy mesh. The mesh is triangulated and chopped at the instantaneous flat water surface. Buoyancy is applied as an upwards force that the center of buoyancy.
The calculation of buoyancy is as accurate as the provided geometry.</p>
<p>There as no restrictions to the size or aspect ratio of the panels. It is excellent to model as box using 6 faces. Using smaller panels has a negative effect on performance.</p>
<p>The normals of the panels should point towards to water.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Buoyancy(NodeWithParent):
    &#34;&#34;&#34;Buoyancy provides a buoyancy force based on a buoyancy mesh. The mesh is triangulated and chopped at the instantaneous flat water surface. Buoyancy is applied as an upwards force that the center of buoyancy.
    The calculation of buoyancy is as accurate as the provided geometry.

    There as no restrictions to the size or aspect ratio of the panels. It is excellent to model as box using 6 faces. Using smaller panels has a negative effect on performance.

    The normals of the panels should point towards to water.
    &#34;&#34;&#34;

    # init parent and name are fully derived from NodeWithParent
    # _vfNode is a buoyancy
    def __init__(self, scene, vfBuoyancy):
        super().__init__(scene, vfBuoyancy)
        self._None_parent_acceptable = False
        self._trimesh = TriMeshSource(
            self._scene, self._vfNode.trimesh
        )  # the tri-mesh is wrapped in a custom object

    def update(self):
        self._vfNode.reloadTrimesh()

    @property
    def trimesh(self) -&gt; TriMeshSource:
        return self._trimesh

    @property
    def cob(self):
        &#34;&#34;&#34;GLOBAL position of the center of buoyancy [m,m,m] (global axis)&#34;&#34;&#34;
        return self._vfNode.cob

    @property
    def cob_local(self):
        &#34;&#34;&#34;Position of the center of buoyancy [m,m,m] (local axis)&#34;&#34;&#34;

        return self.parent.to_loc_position(self.cob)

    @property
    def displacement(self):
        &#34;&#34;&#34;Displaced volume of fluid [m^3]&#34;&#34;&#34;
        return self._vfNode.displacement

    @property
    def density(self):
        &#34;&#34;&#34;Density of surrounding fluid [mT/m3].
        Typical values: Seawater = 1.025, fresh water = 1.00
        &#34;&#34;&#34;
        return self._vfNode.density

    @density.setter
    @node_setter_manageable
    @node_setter_observable
    def density(self, value):
        assert1f_positive_or_zero(value, &#34;density&#34;)
        self._vfNode.density = value

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\nmesh = s.new_buoyancy(name=&#39;{}&#39;,&#34;.format(self.name)

        if self.density != 1.025:
            code += f&#34;\n          density={self.density},&#34;

        code += &#34;\n          parent=&#39;{}&#39;)&#34;.format(self.parent_for_export.name)

        if self.trimesh._invert_normals:
            code += &#34;\nmesh.trimesh.load_file(r&#39;{}&#39;, scale = ({},{},{}), rotation = ({},{},{}), offset = ({},{},{}), invert_normals=True)&#34;.format(
                self.trimesh._path,
                *self.trimesh._scale,
                *self.trimesh._rotation,
                *self.trimesh._offset,
            )
        else:
            code += &#34;\nmesh.trimesh.load_file(r&#39;{}&#39;, scale = ({},{},{}), rotation = ({},{},{}), offset = ({},{},{}))&#34;.format(
                self.trimesh._path,
                *self.trimesh._scale,
                *self.trimesh._rotation,
                *self.trimesh._offset,
            )

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Buoyancy.cob"><code class="name">var <span class="ident">cob</span></code></dt>
<dd>
<div class="desc"><p>GLOBAL position of the center of buoyancy [m,m,m] (global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cob(self):
    &#34;&#34;&#34;GLOBAL position of the center of buoyancy [m,m,m] (global axis)&#34;&#34;&#34;
    return self._vfNode.cob</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Buoyancy.cob_local"><code class="name">var <span class="ident">cob_local</span></code></dt>
<dd>
<div class="desc"><p>Position of the center of buoyancy [m,m,m] (local axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cob_local(self):
    &#34;&#34;&#34;Position of the center of buoyancy [m,m,m] (local axis)&#34;&#34;&#34;

    return self.parent.to_loc_position(self.cob)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Buoyancy.density"><code class="name">var <span class="ident">density</span></code></dt>
<dd>
<div class="desc"><p>Density of surrounding fluid [mT/m3].
Typical values: Seawater = 1.025, fresh water = 1.00</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def density(self):
    &#34;&#34;&#34;Density of surrounding fluid [mT/m3].
    Typical values: Seawater = 1.025, fresh water = 1.00
    &#34;&#34;&#34;
    return self._vfNode.density</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Buoyancy.displacement"><code class="name">var <span class="ident">displacement</span></code></dt>
<dd>
<div class="desc"><p>Displaced volume of fluid [m^3]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def displacement(self):
    &#34;&#34;&#34;Displaced volume of fluid [m^3]&#34;&#34;&#34;
    return self._vfNode.displacement</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Buoyancy.trimesh"><code class="name">var <span class="ident">trimesh</span> :Â <a title="DAVE.scene.TriMeshSource" href="#DAVE.scene.TriMeshSource">TriMeshSource</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def trimesh(self) -&gt; TriMeshSource:
    return self._trimesh</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.NodeWithParent.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.parent" href="#DAVE.scene.NodeWithParent.parent">parent</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.Cable"><code class="flex name class">
<span>class <span class="ident">Cable</span></span>
<span>(</span><span>scene, node)</span>
</code></dt>
<dd>
<div class="desc"><p>A Cable represents a linear elastic wire running from a Poi or sheave to another Poi of sheave.</p>
<p>A cable has a un-stretched length [length] and a stiffness [EA] and may have a diameter [m]. The tension in the cable is calculated.</p>
<p>Intermediate pois or sheaves may be added.</p>
<ul>
<li>Pois are considered as sheaves with a zero diameter.</li>
<li>Sheaves are considered sheaves with the given geometry. If defined then the diameter of the cable is considered when calculating the geometry. The cable runs over the sheave in the positive direction (right hand rule) as defined by the axis of the sheave.</li>
</ul>
<p>For cables running over a sheave the friction in sideways direction is considered to be infinite. The geometry is calculated such that the
cable section between sheaves is perpendicular to the vector from the axis of the sheave to the point where the cable leaves the sheave.</p>
<p>This assumption results in undefined behaviour when the axis of the sheave is parallel to the cable direction.</p>
<h2 id="notes">Notes</h2>
<p>If pois or sheaves on a cable come too close together (&lt;1mm) then they will be pushed away from eachother.
This prevents the unwanted situation where multiple pois end up at the same location. In that case it can not be determined which amount of force should be applied to each of the pois.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cable(CoreConnectedNode):
    &#34;&#34;&#34;A Cable represents a linear elastic wire running from a Poi or sheave to another Poi of sheave.

    A cable has a un-stretched length [length] and a stiffness [EA] and may have a diameter [m]. The tension in the cable is calculated.

    Intermediate pois or sheaves may be added.

    - Pois are considered as sheaves with a zero diameter.
    - Sheaves are considered sheaves with the given geometry. If defined then the diameter of the cable is considered when calculating the geometry. The cable runs over the sheave in the positive direction (right hand rule) as defined by the axis of the sheave.

    For cables running over a sheave the friction in sideways direction is considered to be infinite. The geometry is calculated such that the
    cable section between sheaves is perpendicular to the vector from the axis of the sheave to the point where the cable leaves the sheave.

    This assumption results in undefined behaviour when the axis of the sheave is parallel to the cable direction.

    Notes:
        If pois or sheaves on a cable come too close together (&lt;1mm) then they will be pushed away from eachother.
        This prevents the unwanted situation where multiple pois end up at the same location. In that case it can not be determined which amount of force should be applied to each of the pois.


    &#34;&#34;&#34;

    def __init__(self, scene, node):
        super().__init__(scene, node)
        self._pois = list()

    def depends_on(self):
        return [*self._pois]

    @property
    def tension(self):
        &#34;&#34;&#34;Tension in the cable [kN]&#34;&#34;&#34;
        return self._vfNode.tension

    @property
    def stretch(self):
        &#34;&#34;&#34;Stretch of the cable [m]

        Tension [kN] = EA [kN] * stretch [m] / length [m]
        &#34;&#34;&#34;
        return self._vfNode.stretch

    @property
    def length(self):
        &#34;&#34;&#34;Length of the cable when in rest [m]

        Tension [kN] = EA [kN] * stretch [m] / length [m]
        &#34;&#34;&#34;
        return self._vfNode.Length

    @length.setter
    @node_setter_manageable
    @node_setter_observable
    def length(self, val):

        if val &lt; 1e-9:
            raise Exception(
                &#34;Length shall be more than 0 (otherwise stiffness EA/L becomes infinite)&#34;
            )
        self._vfNode.Length = val

    @property
    def EA(self):
        &#34;&#34;&#34;Stiffness of the cable [kN]

        Tension [kN] = EA [kN] * stretch [m] / length [m]
        &#34;&#34;&#34;
        return self._vfNode.EA

    @EA.setter
    @node_setter_manageable
    @node_setter_observable
    def EA(self, ea):

        self._vfNode.EA = ea

    @property
    def diameter(self):
        &#34;&#34;&#34;Diameter of the cable. Used when a cable runs over a circle. [m]&#34;&#34;&#34;
        return self._vfNode.diameter

    @diameter.setter
    @node_setter_manageable
    @node_setter_observable
    def diameter(self, diameter):

        self._vfNode.diameter = diameter

    @property
    def connections(self):
        &#34;&#34;&#34;List or Tuple of nodes that this cable is connected to. Nodes may be passed by name (string) or by reference.

        Example:
            p1 = s.new_point(&#39;point 1&#39;)
            p2 = s.new_point(&#39;point 2&#39;, position = (0,0,10)
            p3 = s.new_point(&#39;point 3&#39;, position = (10,0,10)
            c1 = s.new_circle(&#39;circle 1&#39;,parent = p3, axis = (0,1,0), radius = 1)
            c = s.new_cable(&#34;cable_1&#34;, endA=&#34;Point&#34;, endB = &#34;Circle&#34;, length = 1.2, EA = 10000)

            c.connections = (&#39;point 1&#39;, &#39;point 2&#39;, &#39;point 3&#39;)
            # or
            c.connections = (p1, p2,p3)
            # or
            c.connections = [p1, &#39;point 2&#39;, p3]  # all the same

        Notes:
            1. Circles can not be used as endpoins. If one of the endpoints is a Circle then the Point that that circle
            is located on is used instead.
            2. Points should not be repeated directly.

        The following will fail:
        c.connections = (&#39;point 1&#39;, &#39;point 3&#39;, &#39;circle 1&#39;)

        because the last point is a circle. So circle 1 will be replaced with the point that the circle is on: point 3.

        so this becomes
        (&#39;point 1&#39;,&#39;point 3&#39;,&#39;point 3&#39;)

        this is invalid because point 3 is repeated.

        &#34;&#34;&#34;
        return tuple(self._pois)

    @connections.setter
    @node_setter_manageable
    @node_setter_observable
    def connections(self, value):

        if len(value) &lt; 2:
            raise ValueError(&#34;At least two connections required&#34;)

        nodes = []
        for p in value:
            n = self._scene._node_from_node_or_str(p)

            if not (isinstance(n, Point) or isinstance(n, Circle)):
                raise ValueError(
                    f&#34;Only Sheaves and Pois can be used as connection, but {n.name} is a {type(n)}&#34;
                )
            nodes.append(n)

        # check for repeated nodes
        n = len(nodes)
        for i in range(n - 1):
            node1 = nodes[i]
            node2 = nodes[i + 1]

            # # if first or last node is a sheave, the this will be replaced by the poi of the sheave
            # if i == 0 and isinstance(node1, Circle):
            #     node1 = node1.parent
            # if i == n - 2 and isinstance(node2, Circle):
            #     node2 = node2.parent

            if node1 == node2:
                raise ValueError(
                    f&#34;It is not allowed to have the same node repeated - you have {node1.name} and {node2.name}&#34;
                )

        self._pois.clear()
        self._pois.extend(nodes)
        self._update_pois()

    def get_points_for_visual(self):
        &#34;&#34;&#34;A list of 3D locations which can be used for visualization&#34;&#34;&#34;
        return self._vfNode.global_points

    def _add_connection_to_core(self, connection):
        if isinstance(connection, Point):
            self._vfNode.add_connection_poi(connection._vfNode)
        if isinstance(connection, Circle):
            self._vfNode.add_connection_sheave(connection._vfNode)

    def _update_pois(self):
        self._vfNode.clear_connections()
        for point in self._pois:
            self._add_connection_to_core(point)

    def _give_poi_names(self):
        &#34;&#34;&#34;Returns a list with the names of all the pois&#34;&#34;&#34;
        r = list()
        for p in self._pois:
            r.append(p.name)
        return r

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        poi_names = self._give_poi_names()
        n_sheaves = len(poi_names) - 2

        code += &#34;\ns.new_cable(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            endA=&#39;{}&#39;,&#34;.format(poi_names[0])
        code += &#34;\n            endB=&#39;{}&#39;,&#34;.format(poi_names[-1])
        code += &#34;\n            length={},&#34;.format(self.length)

        if self.diameter != 0:
            code += &#34;\n            diameter={},&#34;.format(self.diameter)

        if len(poi_names) &lt;= 2:
            code += &#34;\n            EA={})&#34;.format(self.EA)
        else:
            code += &#34;\n            EA={},&#34;.format(self.EA)

            if n_sheaves == 1:
                code += &#34;\n            sheaves = [&#39;{}&#39;])&#34;.format(poi_names[1])
            else:
                code += &#34;\n            sheaves = [&#39;{}&#39;,&#34;.format(poi_names[1])
                for i in range(n_sheaves - 2):
                    code += &#34;\n                       &#39;{}&#39;,&#34;.format(poi_names[2 + i])
                code += &#34;\n                       &#39;{}&#39;]),&#34;.format(poi_names[-2])

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Cable.EA"><code class="name">var <span class="ident">EA</span></code></dt>
<dd>
<div class="desc"><p>Stiffness of the cable [kN]</p>
<p>Tension [kN] = EA [kN] * stretch [m] / length [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def EA(self):
    &#34;&#34;&#34;Stiffness of the cable [kN]

    Tension [kN] = EA [kN] * stretch [m] / length [m]
    &#34;&#34;&#34;
    return self._vfNode.EA</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Cable.connections"><code class="name">var <span class="ident">connections</span></code></dt>
<dd>
<div class="desc"><p>List or Tuple of nodes that this cable is connected to. Nodes may be passed by name (string) or by reference.</p>
<h2 id="example">Example</h2>
<p>p1 = s.new_point('point 1')
p2 = s.new_point('point 2', position = (0,0,10)
p3 = s.new_point('point 3', position = (10,0,10)
c1 = s.new_circle('circle 1',parent = p3, axis = (0,1,0), radius = 1)
c = s.new_cable("cable_1", endA="Point", endB = "Circle", length = 1.2, EA = 10000)</p>
<p>c.connections = ('point 1', 'point 2', 'point 3')</p>
<h1 id="or">or</h1>
<p>c.connections = (p1, p2,p3)</p>
<h1 id="or_1">or</h1>
<p>c.connections = [p1, 'point 2', p3]
# all the same</p>
<h2 id="notes">Notes</h2>
<ol>
<li>Circles can not be used as endpoins. If one of the endpoints is a Circle then the Point that that circle
is located on is used instead.</li>
<li>Points should not be repeated directly.</li>
</ol>
<p>The following will fail:
c.connections = ('point 1', 'point 3', 'circle 1')</p>
<p>because the last point is a circle. So circle 1 will be replaced with the point that the circle is on: point 3.</p>
<p>so this becomes
('point 1','point 3','point 3')</p>
<p>this is invalid because point 3 is repeated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connections(self):
    &#34;&#34;&#34;List or Tuple of nodes that this cable is connected to. Nodes may be passed by name (string) or by reference.

    Example:
        p1 = s.new_point(&#39;point 1&#39;)
        p2 = s.new_point(&#39;point 2&#39;, position = (0,0,10)
        p3 = s.new_point(&#39;point 3&#39;, position = (10,0,10)
        c1 = s.new_circle(&#39;circle 1&#39;,parent = p3, axis = (0,1,0), radius = 1)
        c = s.new_cable(&#34;cable_1&#34;, endA=&#34;Point&#34;, endB = &#34;Circle&#34;, length = 1.2, EA = 10000)

        c.connections = (&#39;point 1&#39;, &#39;point 2&#39;, &#39;point 3&#39;)
        # or
        c.connections = (p1, p2,p3)
        # or
        c.connections = [p1, &#39;point 2&#39;, p3]  # all the same

    Notes:
        1. Circles can not be used as endpoins. If one of the endpoints is a Circle then the Point that that circle
        is located on is used instead.
        2. Points should not be repeated directly.

    The following will fail:
    c.connections = (&#39;point 1&#39;, &#39;point 3&#39;, &#39;circle 1&#39;)

    because the last point is a circle. So circle 1 will be replaced with the point that the circle is on: point 3.

    so this becomes
    (&#39;point 1&#39;,&#39;point 3&#39;,&#39;point 3&#39;)

    this is invalid because point 3 is repeated.

    &#34;&#34;&#34;
    return tuple(self._pois)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Cable.diameter"><code class="name">var <span class="ident">diameter</span></code></dt>
<dd>
<div class="desc"><p>Diameter of the cable. Used when a cable runs over a circle. [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def diameter(self):
    &#34;&#34;&#34;Diameter of the cable. Used when a cable runs over a circle. [m]&#34;&#34;&#34;
    return self._vfNode.diameter</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Cable.length"><code class="name">var <span class="ident">length</span></code></dt>
<dd>
<div class="desc"><p>Length of the cable when in rest [m]</p>
<p>Tension [kN] = EA [kN] * stretch [m] / length [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def length(self):
    &#34;&#34;&#34;Length of the cable when in rest [m]

    Tension [kN] = EA [kN] * stretch [m] / length [m]
    &#34;&#34;&#34;
    return self._vfNode.Length</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Cable.stretch"><code class="name">var <span class="ident">stretch</span></code></dt>
<dd>
<div class="desc"><p>Stretch of the cable [m]</p>
<p>Tension [kN] = EA [kN] * stretch [m] / length [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stretch(self):
    &#34;&#34;&#34;Stretch of the cable [m]

    Tension [kN] = EA [kN] * stretch [m] / length [m]
    &#34;&#34;&#34;
    return self._vfNode.stretch</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Cable.tension"><code class="name">var <span class="ident">tension</span></code></dt>
<dd>
<div class="desc"><p>Tension in the cable [kN]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tension(self):
    &#34;&#34;&#34;Tension in the cable [kN]&#34;&#34;&#34;
    return self._vfNode.tension</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.Cable.get_points_for_visual"><code class="name flex">
<span>def <span class="ident">get_points_for_visual</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A list of 3D locations which can be used for visualization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_points_for_visual(self):
    &#34;&#34;&#34;A list of 3D locations which can be used for visualization&#34;&#34;&#34;
    return self._vfNode.global_points</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.CoreConnectedNode.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.Circle"><code class="flex name class">
<span>class <span class="ident">Circle</span></span>
<span>(</span><span>scene, vfNode)</span>
</code></dt>
<dd>
<div class="desc"><p>A Circle models a circle shape based on a diameter and an axis direction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Circle(NodeWithParent):
    &#34;&#34;&#34;A Circle models a circle shape based on a diameter and an axis direction&#34;&#34;&#34;

    @property
    def axis(self) -&gt; tuple:
        &#34;&#34;&#34;Direction of the sheave axis (x,y,z) in parent axis system.

        Note:
            The direction of the axis is also used to determine the positive direction over the circumference of the
            circle. This is then used when cables run over the circle or the circle is used for geometric contacts. So
            if a cable runs over the circle in the wrong direction then a solution is to change the axis direction to
            its opposite:  circle.axis =- circle.axis. (another solution in that case is to define the connections of
            the cable in the reverse order)
        &#34;&#34;&#34;
        return self._vfNode.axis_direction

    @axis.setter
    @node_setter_manageable
    @node_setter_observable
    def axis(self, val):

        assert3f(val)
        if np.linalg.norm(val) == 0:
            raise ValueError(&#34;Axis can not be 0,0,0&#34;)
        self._vfNode.axis_direction = val

    @property
    def radius(self):
        &#34;&#34;&#34;Radius of the circle [m]&#34;&#34;&#34;
        return self._vfNode.radius

    @radius.setter
    @node_setter_manageable
    @node_setter_observable
    def radius(self, val):

        assert1f(val)
        self._vfNode.radius = val

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\ns.new_circle(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            parent=&#39;{}&#39;,&#34;.format(self.parent_for_export.name)
        code += &#34;\n            axis=({}, {}, {}),&#34;.format(*self.axis)
        code += &#34;\n            radius={} )&#34;.format(self.radius)
        return code

    @property
    def global_position(self):
        &#34;&#34;&#34;Returns the global position of the center of the sheave.

        Note: this is the same as the global position of the parent point.
        &#34;&#34;&#34;
        return self.parent.global_position</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Circle.axis"><code class="name">var <span class="ident">axis</span> :Â tuple</code></dt>
<dd>
<div class="desc"><p>Direction of the sheave axis (x,y,z) in parent axis system.</p>
<h2 id="note">Note</h2>
<p>The direction of the axis is also used to determine the positive direction over the circumference of the
circle. This is then used when cables run over the circle or the circle is used for geometric contacts. So
if a cable runs over the circle in the wrong direction then a solution is to change the axis direction to
its opposite:
circle.axis =- circle.axis. (another solution in that case is to define the connections of
the cable in the reverse order)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def axis(self) -&gt; tuple:
    &#34;&#34;&#34;Direction of the sheave axis (x,y,z) in parent axis system.

    Note:
        The direction of the axis is also used to determine the positive direction over the circumference of the
        circle. This is then used when cables run over the circle or the circle is used for geometric contacts. So
        if a cable runs over the circle in the wrong direction then a solution is to change the axis direction to
        its opposite:  circle.axis =- circle.axis. (another solution in that case is to define the connections of
        the cable in the reverse order)
    &#34;&#34;&#34;
    return self._vfNode.axis_direction</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Circle.global_position"><code class="name">var <span class="ident">global_position</span></code></dt>
<dd>
<div class="desc"><p>Returns the global position of the center of the sheave.</p>
<p>Note: this is the same as the global position of the parent point.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def global_position(self):
    &#34;&#34;&#34;Returns the global position of the center of the sheave.

    Note: this is the same as the global position of the parent point.
    &#34;&#34;&#34;
    return self.parent.global_position</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Circle.radius"><code class="name">var <span class="ident">radius</span></code></dt>
<dd>
<div class="desc"><p>Radius of the circle [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def radius(self):
    &#34;&#34;&#34;Radius of the circle [m]&#34;&#34;&#34;
    return self._vfNode.radius</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.NodeWithParent.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.parent" href="#DAVE.scene.NodeWithParent.parent">parent</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.ClaimManagement"><code class="flex name class">
<span>class <span class="ident">ClaimManagement</span></span>
<span>(</span><span>scene, manager)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class for doing:</p>
<p>with ClaimManagement(scene, manager):
change nodes that belong to manager</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ClaimManagement():
    &#34;&#34;&#34;Helper class for doing:

    with ClaimManagement(scene, manager):
        change nodes that belong to manager

    &#34;&#34;&#34;
    def __init__(self, scene, manager):
        assert isinstance(scene, Scene)
        assert isinstance(manager, Manager)
        self.scene = scene
        self.manager= manager


    def __enter__(self):
        self._old_manager = self.scene.current_manager
        self.scene.current_manager = self.manager

    def __exit__(self, *args, **kwargs):
        self.scene.current_manager = self._old_manager</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Connector2d"><code class="flex name class">
<span>class <span class="ident">Connector2d</span></span>
<span>(</span><span>scene, node)</span>
</code></dt>
<dd>
<div class="desc"><p>A Connector2d linear connector with acts both on linear displacement and angular displacement.</p>
<ul>
<li>the linear stiffness is defined by k_linear and is defined over the actual shortest direction between nodeA and nodeB.</li>
<li>the angular stiffness is defined by k_angular and is defined over the actual smallest angle between the two systems.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Connector2d(CoreConnectedNode):
    &#34;&#34;&#34;A Connector2d linear connector with acts both on linear displacement and angular displacement.

    * the linear stiffness is defined by k_linear and is defined over the actual shortest direction between nodeA and nodeB.
    * the angular stiffness is defined by k_angular and is defined over the actual smallest angle between the two systems.
    &#34;&#34;&#34;

    def __init__(self, scene, node):
        super().__init__(scene, node)
        self._nodeA = None
        self._nodeB = None

    def depends_on(self):
        return [self._nodeA, self._nodeB]

    @property
    def angle(self):
        &#34;&#34;&#34;Actual angle between nodeA and nodeB [deg] (read-only)&#34;&#34;&#34;
        return np.rad2deg(self._vfNode.angle)

    @property
    def force(self):
        &#34;&#34;&#34;Actual force between nodeA and nodeB [kN] (read-only)&#34;&#34;&#34;
        return self._vfNode.force

    @property
    def moment(self):
        &#34;&#34;&#34;Actual moment between nodeA and nodeB [kNm] (read-only)&#34;&#34;&#34;
        return self._vfNode.moment

    @property
    def axis(self):
        &#34;&#34;&#34;Actual rotation axis between nodeA and nodeB (read-only)&#34;&#34;&#34;
        return self._vfNode.axis

    @property
    def ax(self):
        &#34;&#34;&#34;X component of actual rotation axis between nodeA and nodeB (read-only)&#34;&#34;&#34;
        return self._vfNode.axis[0]

    @property
    def ay(self):
        &#34;&#34;&#34;Y component of actual rotation axis between nodeA and nodeB (read-only)&#34;&#34;&#34;
        return self._vfNode.axis[1]

    @property
    def az(self):
        &#34;&#34;&#34;Z component of actual rotation axis between nodeA and nodeB (read-only)&#34;&#34;&#34;
        return self._vfNode.axis[2]

    @property
    def k_linear(self):
        &#34;&#34;&#34;Linear stiffness [kN/m]&#34;&#34;&#34;
        return self._vfNode.k_linear

    @k_linear.setter
    @node_setter_manageable
    @node_setter_observable
    def k_linear(self, value):

        self._vfNode.k_linear = value

    @property
    def k_angular(self):
        &#34;&#34;&#34;Angular stiffness [kNm/rad]&#34;&#34;&#34;
        return self._vfNode.k_angular

    @k_angular.setter
    @node_setter_manageable
    @node_setter_observable
    def k_angular(self, value):

        self._vfNode.k_angular = value

    @property
    def nodeA(self) -&gt; Axis:
        &#34;&#34;&#34;Connected axis system A&#34;&#34;&#34;
        return self._nodeA

    @nodeA.setter
    @node_setter_manageable
    @node_setter_observable
    def nodeA(self, val):

        val = self._scene._node_from_node_or_str(val)
        if not isinstance(val, Axis):
            raise TypeError(&#34;Provided nodeA should be a Axis&#34;)

        self._nodeA = val
        self._vfNode.master = val._vfNode

    @property
    def nodeB(self) -&gt; Axis:
        &#34;&#34;&#34;Connected axis system B&#34;&#34;&#34;
        return self._nodeB

    @nodeB.setter
    @node_setter_manageable
    @node_setter_observable
    def nodeB(self, val):

        val = self._scene._node_from_node_or_str(val)
        if not isinstance(val, Axis):
            raise TypeError(&#34;Provided nodeA should be a Axis&#34;)

        self._nodeB = val
        self._vfNode.slave = val._vfNode

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        code += &#34;\ns.new_connector2d(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            nodeA=&#39;{}&#39;,&#34;.format(self.nodeA.name)
        code += &#34;\n            nodeB=&#39;{}&#39;,&#34;.format(self.nodeB.name)
        code += &#34;\n            k_linear ={},&#34;.format(self.k_linear)
        code += &#34;\n            k_angular ={})&#34;.format(self.k_angular)

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Connector2d.angle"><code class="name">var <span class="ident">angle</span></code></dt>
<dd>
<div class="desc"><p>Actual angle between nodeA and nodeB [deg] (read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def angle(self):
    &#34;&#34;&#34;Actual angle between nodeA and nodeB [deg] (read-only)&#34;&#34;&#34;
    return np.rad2deg(self._vfNode.angle)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Connector2d.ax"><code class="name">var <span class="ident">ax</span></code></dt>
<dd>
<div class="desc"><p>X component of actual rotation axis between nodeA and nodeB (read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ax(self):
    &#34;&#34;&#34;X component of actual rotation axis between nodeA and nodeB (read-only)&#34;&#34;&#34;
    return self._vfNode.axis[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Connector2d.axis"><code class="name">var <span class="ident">axis</span></code></dt>
<dd>
<div class="desc"><p>Actual rotation axis between nodeA and nodeB (read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def axis(self):
    &#34;&#34;&#34;Actual rotation axis between nodeA and nodeB (read-only)&#34;&#34;&#34;
    return self._vfNode.axis</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Connector2d.ay"><code class="name">var <span class="ident">ay</span></code></dt>
<dd>
<div class="desc"><p>Y component of actual rotation axis between nodeA and nodeB (read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ay(self):
    &#34;&#34;&#34;Y component of actual rotation axis between nodeA and nodeB (read-only)&#34;&#34;&#34;
    return self._vfNode.axis[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Connector2d.az"><code class="name">var <span class="ident">az</span></code></dt>
<dd>
<div class="desc"><p>Z component of actual rotation axis between nodeA and nodeB (read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def az(self):
    &#34;&#34;&#34;Z component of actual rotation axis between nodeA and nodeB (read-only)&#34;&#34;&#34;
    return self._vfNode.axis[2]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Connector2d.force"><code class="name">var <span class="ident">force</span></code></dt>
<dd>
<div class="desc"><p>Actual force between nodeA and nodeB [kN] (read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def force(self):
    &#34;&#34;&#34;Actual force between nodeA and nodeB [kN] (read-only)&#34;&#34;&#34;
    return self._vfNode.force</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Connector2d.k_angular"><code class="name">var <span class="ident">k_angular</span></code></dt>
<dd>
<div class="desc"><p>Angular stiffness [kNm/rad]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def k_angular(self):
    &#34;&#34;&#34;Angular stiffness [kNm/rad]&#34;&#34;&#34;
    return self._vfNode.k_angular</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Connector2d.k_linear"><code class="name">var <span class="ident">k_linear</span></code></dt>
<dd>
<div class="desc"><p>Linear stiffness [kN/m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def k_linear(self):
    &#34;&#34;&#34;Linear stiffness [kN/m]&#34;&#34;&#34;
    return self._vfNode.k_linear</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Connector2d.moment"><code class="name">var <span class="ident">moment</span></code></dt>
<dd>
<div class="desc"><p>Actual moment between nodeA and nodeB [kNm] (read-only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def moment(self):
    &#34;&#34;&#34;Actual moment between nodeA and nodeB [kNm] (read-only)&#34;&#34;&#34;
    return self._vfNode.moment</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Connector2d.nodeA"><code class="name">var <span class="ident">nodeA</span> :Â <a title="DAVE.scene.Axis" href="#DAVE.scene.Axis">Axis</a></code></dt>
<dd>
<div class="desc"><p>Connected axis system A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nodeA(self) -&gt; Axis:
    &#34;&#34;&#34;Connected axis system A&#34;&#34;&#34;
    return self._nodeA</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Connector2d.nodeB"><code class="name">var <span class="ident">nodeB</span> :Â <a title="DAVE.scene.Axis" href="#DAVE.scene.Axis">Axis</a></code></dt>
<dd>
<div class="desc"><p>Connected axis system B</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nodeB(self) -&gt; Axis:
    &#34;&#34;&#34;Connected axis system B&#34;&#34;&#34;
    return self._nodeB</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.CoreConnectedNode.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.ContactBall"><code class="flex name class">
<span>class <span class="ident">ContactBall</span></span>
<span>(</span><span>scene, node)</span>
</code></dt>
<dd>
<div class="desc"><p>A ContactBall is a linear elastic ball which can contact with ContactMeshes.</p>
<p>It is modelled as a sphere around a Poi. Radius and stiffness can be controlled using radius and k.</p>
<p>The force is applied on the Poi and it not registered separately.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContactBall(NodeWithParent):
    &#34;&#34;&#34;A ContactBall is a linear elastic ball which can contact with ContactMeshes.

    It is modelled as a sphere around a Poi. Radius and stiffness can be controlled using radius and k.

    The force is applied on the Poi and it not registered separately.
    &#34;&#34;&#34;

    def __init__(self, scene, node):
        super().__init__(scene, node)
        self._meshes = list()

    @property
    def can_contact(self) -&gt; bool:
        &#34;&#34;&#34;True if the ball ball is perpendicular to at least one of the faces of one of the meshes. So when contact is possible. To check if there is contact use &#34;force&#34;
        See Also: Force
        &#34;&#34;&#34;
        return self._vfNode.has_contact

    @property
    def contact_force(self) -&gt; tuple:
        &#34;&#34;&#34;Returns the force on the ball [kN, kN, kN] (global axis)

        The force is applied at the center of the ball

        See Also: contact_force_magnitude
        &#34;&#34;&#34;
        return self._vfNode.force

    @property
    def contact_force_magnitude(self) -&gt; float:
        &#34;&#34;&#34;Returns the absolute force on the ball, if any [kN]

        The force is applied on the center of the ball

        See Also: contact_force
        &#34;&#34;&#34;
        return np.linalg.norm(self._vfNode.force)

    @property
    def compression(self) -&gt; float:
        &#34;&#34;&#34;Returns the absolute compression of the ball, if any [m]&#34;&#34;&#34;
        return self._vfNode.force

    @property
    def contactpoint(self):
        &#34;&#34;&#34;The nearest point on the nearest mesh. Only defined&#34;&#34;&#34;
        return self._vfNode.contact_point

    def update(self):
        &#34;&#34;&#34;Updates the contact-points and applies forces on mesh and point&#34;&#34;&#34;
        self._vfNode.update()

    @property
    def meshes(self) -&gt; tuple:
        &#34;&#34;&#34;List of contact-mesh nodes.
        When getting this will yield a list of node references.
        When setting node references and node-names may be used.

        eg: ball.meshes = [mesh1, &#39;mesh2&#39;]
        &#34;&#34;&#34;
        return tuple(self._meshes)

    @meshes.setter
    @node_setter_manageable
    @node_setter_observable
    def meshes(self, value):

        meshes = []

        for m in value:
            cm = self._scene._node_from_node_or_str(m)

            if not isinstance(cm, ContactMesh):
                raise ValueError(
                    f&#34;Only ContactMesh nodes can be used as mesh, but {cm.name} is a {type(cm)}&#34;
                )
            if cm in meshes:
                raise ValueError(f&#34;Can not add {cm.name} twice&#34;)

            meshes.append(cm)

        # copy to meshes
        self._meshes.clear()
        self._vfNode.clear_contactmeshes()
        for mesh in meshes:
            self._meshes.append(mesh)
            self._vfNode.add_contactmesh(mesh._vfNode)

    @property
    def meshes_names(self) -&gt; list:
        &#34;&#34;&#34;List with the names of the meshes&#34;&#34;&#34;
        return [m.name for m in self._meshes]

    @property
    def radius(self):
        &#34;&#34;&#34;Radius of the contact-ball [m]&#34;&#34;&#34;
        return self._vfNode.radius

    @radius.setter
    @node_setter_manageable
    @node_setter_observable
    def radius(self, value):

        assert1f_positive_or_zero(value, &#34;radius&#34;)
        self._vfNode.radius = value
        pass

    @property
    def k(self):
        &#34;&#34;&#34;Compression stiffness of the ball in force per meter of compression [kN/m]&#34;&#34;&#34;
        return self._vfNode.k

    @k.setter
    @node_setter_manageable
    @node_setter_observable
    def k(self, value):

        assert1f_positive_or_zero(value, &#34;k&#34;)
        self._vfNode.k = value
        pass

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        code += &#34;\ns.new_contactball(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n                  parent=&#39;{}&#39;,&#34;.format(self.parent_for_export.name)
        code += &#34;\n                  radius={},&#34;.format(self.radius)
        code += &#34;\n                  k={},&#34;.format(self.k)
        code += &#34;\n                  meshes = [ &#34;

        for m in self._meshes:
            code += &#39;&#34;&#39; + m.name + &#39;&#34;,&#39;
        code = code[:-1] + &#34;])&#34;

        return code

    # =======================================================================</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.ContactBall.can_contact"><code class="name">var <span class="ident">can_contact</span> :Â bool</code></dt>
<dd>
<div class="desc"><p>True if the ball ball is perpendicular to at least one of the faces of one of the meshes. So when contact is possible. To check if there is contact use "force"
See Also: Force</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def can_contact(self) -&gt; bool:
    &#34;&#34;&#34;True if the ball ball is perpendicular to at least one of the faces of one of the meshes. So when contact is possible. To check if there is contact use &#34;force&#34;
    See Also: Force
    &#34;&#34;&#34;
    return self._vfNode.has_contact</code></pre>
</details>
</dd>
<dt id="DAVE.scene.ContactBall.compression"><code class="name">var <span class="ident">compression</span> :Â float</code></dt>
<dd>
<div class="desc"><p>Returns the absolute compression of the ball, if any [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def compression(self) -&gt; float:
    &#34;&#34;&#34;Returns the absolute compression of the ball, if any [m]&#34;&#34;&#34;
    return self._vfNode.force</code></pre>
</details>
</dd>
<dt id="DAVE.scene.ContactBall.contact_force"><code class="name">var <span class="ident">contact_force</span> :Â tuple</code></dt>
<dd>
<div class="desc"><p>Returns the force on the ball [kN, kN, kN] (global axis)</p>
<p>The force is applied at the center of the ball</p>
<p>See Also: contact_force_magnitude</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def contact_force(self) -&gt; tuple:
    &#34;&#34;&#34;Returns the force on the ball [kN, kN, kN] (global axis)

    The force is applied at the center of the ball

    See Also: contact_force_magnitude
    &#34;&#34;&#34;
    return self._vfNode.force</code></pre>
</details>
</dd>
<dt id="DAVE.scene.ContactBall.contact_force_magnitude"><code class="name">var <span class="ident">contact_force_magnitude</span> :Â float</code></dt>
<dd>
<div class="desc"><p>Returns the absolute force on the ball, if any [kN]</p>
<p>The force is applied on the center of the ball</p>
<p>See Also: contact_force</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def contact_force_magnitude(self) -&gt; float:
    &#34;&#34;&#34;Returns the absolute force on the ball, if any [kN]

    The force is applied on the center of the ball

    See Also: contact_force
    &#34;&#34;&#34;
    return np.linalg.norm(self._vfNode.force)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.ContactBall.contactpoint"><code class="name">var <span class="ident">contactpoint</span></code></dt>
<dd>
<div class="desc"><p>The nearest point on the nearest mesh. Only defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def contactpoint(self):
    &#34;&#34;&#34;The nearest point on the nearest mesh. Only defined&#34;&#34;&#34;
    return self._vfNode.contact_point</code></pre>
</details>
</dd>
<dt id="DAVE.scene.ContactBall.k"><code class="name">var <span class="ident">k</span></code></dt>
<dd>
<div class="desc"><p>Compression stiffness of the ball in force per meter of compression [kN/m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def k(self):
    &#34;&#34;&#34;Compression stiffness of the ball in force per meter of compression [kN/m]&#34;&#34;&#34;
    return self._vfNode.k</code></pre>
</details>
</dd>
<dt id="DAVE.scene.ContactBall.meshes"><code class="name">var <span class="ident">meshes</span> :Â tuple</code></dt>
<dd>
<div class="desc"><p>List of contact-mesh nodes.
When getting this will yield a list of node references.
When setting node references and node-names may be used.</p>
<p>eg: ball.meshes = [mesh1, 'mesh2']</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def meshes(self) -&gt; tuple:
    &#34;&#34;&#34;List of contact-mesh nodes.
    When getting this will yield a list of node references.
    When setting node references and node-names may be used.

    eg: ball.meshes = [mesh1, &#39;mesh2&#39;]
    &#34;&#34;&#34;
    return tuple(self._meshes)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.ContactBall.meshes_names"><code class="name">var <span class="ident">meshes_names</span> :Â list</code></dt>
<dd>
<div class="desc"><p>List with the names of the meshes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def meshes_names(self) -&gt; list:
    &#34;&#34;&#34;List with the names of the meshes&#34;&#34;&#34;
    return [m.name for m in self._meshes]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.ContactBall.radius"><code class="name">var <span class="ident">radius</span></code></dt>
<dd>
<div class="desc"><p>Radius of the contact-ball [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def radius(self):
    &#34;&#34;&#34;Radius of the contact-ball [m]&#34;&#34;&#34;
    return self._vfNode.radius</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.ContactBall.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the contact-points and applies forces on mesh and point</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#34;&#34;&#34;Updates the contact-points and applies forces on mesh and point&#34;&#34;&#34;
    self._vfNode.update()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.NodeWithParent.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.parent" href="#DAVE.scene.NodeWithParent.parent">parent</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.ContactMesh"><code class="flex name class">
<span>class <span class="ident">ContactMesh</span></span>
<span>(</span><span>scene, vfContactMesh)</span>
</code></dt>
<dd>
<div class="desc"><p>A ContactMesh is a tri-mesh with an axis parent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContactMesh(NodeWithParent):
    &#34;&#34;&#34;A ContactMesh is a tri-mesh with an axis parent&#34;&#34;&#34;

    def __init__(self, scene, vfContactMesh):
        super().__init__(scene, vfContactMesh)
        self._None_parent_acceptable = True
        self._trimesh = TriMeshSource(
            self._scene, self._vfNode.trimesh
        )  # the tri-mesh is wrapped in a custom object

    @property
    def trimesh(self):
        &#34;&#34;&#34;The TriMeshSource object which can be used to change the mesh

        Example:
            s[&#39;Contactmesh&#39;].trimesh.load_file(&#39;cube.obj&#39;, scale = (1.0,1.0,1.0), rotation = (0.0,0.0,0.0), offset = (0.0,0.0,0.0))
        &#34;&#34;&#34;
        return self._trimesh

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\nmesh = s.new_contactmesh(name=&#39;{}&#39;&#34;.format(self.name)
        if self.parent_for_export:
            code += &#34;, parent=&#39;{}&#39;)&#34;.format(self.parent_for_export.name)
        else:
            code += &#34;)&#34;
        code += &#34;\nmesh.trimesh.load_file(r&#39;{}&#39;, scale = ({},{},{}), rotation = ({},{},{}), offset = ({},{},{}))&#34;.format(
            self.trimesh._path,
            *self.trimesh._scale,
            *self.trimesh._rotation,
            *self.trimesh._offset,
        )

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.ContactMesh.trimesh"><code class="name">var <span class="ident">trimesh</span></code></dt>
<dd>
<div class="desc"><p>The TriMeshSource object which can be used to change the mesh</p>
<h2 id="example">Example</h2>
<p>s['Contactmesh'].trimesh.load_file('cube.obj', scale = (1.0,1.0,1.0), rotation = (0.0,0.0,0.0), offset = (0.0,0.0,0.0))</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def trimesh(self):
    &#34;&#34;&#34;The TriMeshSource object which can be used to change the mesh

    Example:
        s[&#39;Contactmesh&#39;].trimesh.load_file(&#39;cube.obj&#39;, scale = (1.0,1.0,1.0), rotation = (0.0,0.0,0.0), offset = (0.0,0.0,0.0))
    &#34;&#34;&#34;
    return self._trimesh</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.NodeWithParent.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.parent" href="#DAVE.scene.NodeWithParent.parent">parent</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.CoreConnectedNode"><code class="flex name class">
<span>class <span class="ident">CoreConnectedNode</span></span>
<span>(</span><span>scene, vfNode)</span>
</code></dt>
<dd>
<div class="desc"><p>ABSTRACT CLASS - Properties defined here are applicable to all derived classes
Master class for all nodes with a connected eqCore element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CoreConnectedNode(Node):
    &#34;&#34;&#34;ABSTRACT CLASS - Properties defined here are applicable to all derived classes
    Master class for all nodes with a connected eqCore element&#34;&#34;&#34;

    def __init__(self, scene, vfNode):
        super().__init__(scene)
        self._vfNode = vfNode

    @property
    def name(self):
        &#34;&#34;&#34;Name of the node (str), must be unique&#34;&#34;&#34;
        return self._vfNode.name

    @name.setter
    @node_setter_manageable
    @node_setter_observable
    def name(self, name):

        if not name == self._vfNode.name:
            self._scene._verify_name_available(name)
            self._vfNode.name = name

    def _delete_vfc(self):
        self._scene._vfc.delete(self._vfNode.name)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="DAVE.scene.Beam" href="#DAVE.scene.Beam">Beam</a></li>
<li><a title="DAVE.scene.Cable" href="#DAVE.scene.Cable">Cable</a></li>
<li><a title="DAVE.scene.Connector2d" href="#DAVE.scene.Connector2d">Connector2d</a></li>
<li><a title="DAVE.scene.LC6d" href="#DAVE.scene.LC6d">LC6d</a></li>
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.Node.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.Node.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.Node.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.Node.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.Node.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.Force"><code class="flex name class">
<span>class <span class="ident">Force</span></span>
<span>(</span><span>scene, vfNode)</span>
</code></dt>
<dd>
<div class="desc"><p>A Force models a force and moment on a poi.</p>
<p>Both are expressed in the global axis system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Force(NodeWithParent):
    &#34;&#34;&#34;A Force models a force and moment on a poi.

    Both are expressed in the global axis system.

    &#34;&#34;&#34;

    @property
    def force(self):
        &#34;&#34;&#34;The x,y and z components of the force [kN,kN,kN] (global axis)

        Example s[&#39;wind&#39;].force = (12,34,56)
        &#34;&#34;&#34;
        return self._vfNode.force

    @force.setter
    @node_setter_manageable
    @node_setter_observable
    def force(self, val):

        assert3f(val)
        self._vfNode.force = val

    @property
    def fx(self):
        &#34;&#34;&#34;The global x-component of the force [kN] (global axis)&#34;&#34;&#34;
        return self.force[0]

    @fx.setter
    @node_setter_manageable
    @node_setter_observable
    def fx(self, var):

        a = self.force
        self.force = (var, a[1], a[2])

    @property
    def fy(self):
        &#34;&#34;&#34;The global y-component of the force [kN]  (global axis)&#34;&#34;&#34;
        return self.force[1]

    @fy.setter
    @node_setter_manageable
    @node_setter_observable
    def fy(self, var):

        a = self.force
        self.force = (a[0], var, a[2])

    @property
    def fz(self):
        &#34;&#34;&#34;The global z-component of the force [kN]  (global axis)&#34;&#34;&#34;

        return self.force[2]

    @fz.setter
    @node_setter_manageable
    @node_setter_observable
    def fz(self, var):

        a = self.force
        self.force = (a[0], a[1], var)

    @property
    def moment(self):
        &#34;&#34;&#34;The x,y and z components of the moment (kNm,kNm,kNm) in the global axis system.

        Example s[&#39;wind&#39;].moment = (12,34,56)
        &#34;&#34;&#34;
        return self._vfNode.moment

    @moment.setter
    @node_setter_manageable
    @node_setter_observable
    def moment(self, val):

        assert3f(val)
        self._vfNode.moment = val

    @property
    def mx(self):
        &#34;&#34;&#34;The global x-component of the moment [kNm]  (global axis)&#34;&#34;&#34;
        return self.moment[0]

    @mx.setter
    @node_setter_manageable
    @node_setter_observable
    def mx(self, var):

        a = self.moment
        self.moment = (var, a[1], a[2])

    @property
    def my(self):
        &#34;&#34;&#34;The global y-component of the moment [kNm]  (global axis)&#34;&#34;&#34;
        return self.moment[1]

    @my.setter
    @node_setter_manageable
    @node_setter_observable
    def my(self, var):

        a = self.moment
        self.moment = (a[0], var, a[2])

    @property
    def mz(self):
        &#34;&#34;&#34;The global z-component of the moment [kNm]  (global axis)&#34;&#34;&#34;
        return self.moment[2]

    @mz.setter
    @node_setter_manageable
    @node_setter_observable
    def mz(self, var):

        a = self.moment
        self.moment = (a[0], a[1], var)

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        # new_force(self, name, parent=None, force=None, moment=None):

        code += &#34;\ns.new_force(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            parent=&#39;{}&#39;,&#34;.format(self.parent_for_export.name)
        code += &#34;\n            force=({}, {}, {}),&#34;.format(*self.force)
        code += &#34;\n            moment=({}, {}, {}) )&#34;.format(*self.moment)
        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Force.force"><code class="name">var <span class="ident">force</span></code></dt>
<dd>
<div class="desc"><p>The x,y and z components of the force [kN,kN,kN] (global axis)</p>
<p>Example s['wind'].force = (12,34,56)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def force(self):
    &#34;&#34;&#34;The x,y and z components of the force [kN,kN,kN] (global axis)

    Example s[&#39;wind&#39;].force = (12,34,56)
    &#34;&#34;&#34;
    return self._vfNode.force</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Force.fx"><code class="name">var <span class="ident">fx</span></code></dt>
<dd>
<div class="desc"><p>The global x-component of the force [kN] (global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fx(self):
    &#34;&#34;&#34;The global x-component of the force [kN] (global axis)&#34;&#34;&#34;
    return self.force[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Force.fy"><code class="name">var <span class="ident">fy</span></code></dt>
<dd>
<div class="desc"><p>The global y-component of the force [kN]
(global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fy(self):
    &#34;&#34;&#34;The global y-component of the force [kN]  (global axis)&#34;&#34;&#34;
    return self.force[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Force.fz"><code class="name">var <span class="ident">fz</span></code></dt>
<dd>
<div class="desc"><p>The global z-component of the force [kN]
(global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fz(self):
    &#34;&#34;&#34;The global z-component of the force [kN]  (global axis)&#34;&#34;&#34;

    return self.force[2]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Force.moment"><code class="name">var <span class="ident">moment</span></code></dt>
<dd>
<div class="desc"><p>The x,y and z components of the moment (kNm,kNm,kNm) in the global axis system.</p>
<p>Example s['wind'].moment = (12,34,56)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def moment(self):
    &#34;&#34;&#34;The x,y and z components of the moment (kNm,kNm,kNm) in the global axis system.

    Example s[&#39;wind&#39;].moment = (12,34,56)
    &#34;&#34;&#34;
    return self._vfNode.moment</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Force.mx"><code class="name">var <span class="ident">mx</span></code></dt>
<dd>
<div class="desc"><p>The global x-component of the moment [kNm]
(global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mx(self):
    &#34;&#34;&#34;The global x-component of the moment [kNm]  (global axis)&#34;&#34;&#34;
    return self.moment[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Force.my"><code class="name">var <span class="ident">my</span></code></dt>
<dd>
<div class="desc"><p>The global y-component of the moment [kNm]
(global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def my(self):
    &#34;&#34;&#34;The global y-component of the moment [kNm]  (global axis)&#34;&#34;&#34;
    return self.moment[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Force.mz"><code class="name">var <span class="ident">mz</span></code></dt>
<dd>
<div class="desc"><p>The global z-component of the moment [kNm]
(global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mz(self):
    &#34;&#34;&#34;The global z-component of the moment [kNm]  (global axis)&#34;&#34;&#34;
    return self.moment[2]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.NodeWithParent.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.parent" href="#DAVE.scene.NodeWithParent.parent">parent</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.GeometricContact"><code class="flex name class">
<span>class <span class="ident">GeometricContact</span></span>
<span>(</span><span>scene, child_circle, parent_circle, name, inside=True)</span>
</code></dt>
<dd>
<div class="desc"><p>GeometricContact</p>
<p>A GeometricContact can be used to construct geometric connections between circular members:
-
steel bars and holes, such as a shackle pin in a padeye (pin-hole)
-
steel bars and steel bars, such as a shackle-shackle connection</p>
<p>Situation before creation of geometric contact:</p>
<p>Axis1
Point1
Circle1
Axis2
Point2
Circle2</p>
<p>Create a geometric contact with Circle1 and parent and Circle2 as child</p>
<p>Axis1
Point1
: observed, referenced as parent_circle_parent
Circle1
: observed, referenced as parent_circle</p>
<pre><code>_axis_on_parent                 : managed
    _pin_hole_connection        : managed
        _connection_axial_rotation : managed
            _axis_on_child      : managed
                Axis2           : managed    , referenced as child_circle_parent_parent
                    Point2      : observed   , referenced as child_circle_parent
                        Circle2 : observed   , referenced as child_circle
</code></pre>
<p>circle1 becomes the nodeB
circle2 becomes the nodeA</p>
<p>(attach circle 1 to circle 2)</p>
<h2 id="args">Args</h2>
<p>scene:
vfAxis:
parent_circle:
child_circle:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeometricContact(Manager):
    &#34;&#34;&#34;
    GeometricContact

    A GeometricContact can be used to construct geometric connections between circular members:
        -       steel bars and holes, such as a shackle pin in a padeye (pin-hole)
        -       steel bars and steel bars, such as a shackle-shackle connection


    Situation before creation of geometric contact:

    Axis1
        Point1
            Circle1
    Axis2
        Point2
            Circle2

    Create a geometric contact with Circle1 and parent and Circle2 as child

    Axis1
        Point1              : observed, referenced as parent_circle_parent
            Circle1         : observed, referenced as parent_circle

        _axis_on_parent                 : managed
            _pin_hole_connection        : managed
                _connection_axial_rotation : managed
                    _axis_on_child      : managed
                        Axis2           : managed    , referenced as child_circle_parent_parent
                            Point2      : observed   , referenced as child_circle_parent
                                Circle2 : observed   , referenced as child_circle







    &#34;&#34;&#34;

    def __init__(self, scene, child_circle, parent_circle, name, inside=True):
        &#34;&#34;&#34;
        circle1 becomes the nodeB
        circle2 becomes the nodeA

        (attach circle 1 to circle 2)
        Args:
            scene:
            vfAxis:
            parent_circle:
            child_circle:
        &#34;&#34;&#34;

        if parent_circle.parent.parent is None:
            raise ValueError(
                &#34;The slaved pin is not located on an axis. Can not create the connection because there is no axis to nodeB&#34;
            )

        super().__init__(scene)
        self.name = name

        name_prefix = self.name + vfc.MANAGED_NODE_IDENTIFIER

        self._parent_circle = parent_circle
        self._parent_circle_parent = parent_circle.parent  # point

        self._child_circle = child_circle
        self._child_circle_parent = child_circle.parent  # point
        self._child_circle_parent_parent = child_circle.parent.parent  # axis

        self._flipped = False
        self._inside_connection = inside

        self._axis_on_parent = self._scene.new_axis(
            scene.available_name_like(name_prefix + &#34;_axis_on_parent&#34;)
        )
        &#34;&#34;&#34;Axis on the nodeA axis at the location of the center of hole or pin&#34;&#34;&#34;

        self._pin_hole_connection = self._scene.new_axis(
            scene.available_name_like(name_prefix + &#34;_pin_hole_connection&#34;)
        )
        &#34;&#34;&#34;axis between the center of the hole and the center of the pin. Free to rotate about the center of the hole as well as the pin&#34;&#34;&#34;

        self._axis_on_child = self._scene.new_axis(
            scene.available_name_like(name_prefix + &#34;_axis_on_child&#34;)
        )
        &#34;&#34;&#34;axis to which the slaved body is connected. Either the center of the hole or the center of the pin &#34;&#34;&#34;

        self._connection_axial_rotation = self._scene.new_axis(
            scene.available_name_like(name_prefix + &#34;_connection_axial_rotation&#34;)
        )

        # prohibit changes to nodes that were used in the creation of this connection
        for node in self.managed_nodes():
            node.manager = self

        # observe circles and their points
        self._parent_circle.observers.append(self)
        self._parent_circle_parent.observers.append(self)

        self._child_circle.observers.append(self)
        self._child_circle_parent.observers.append(self)

        self._child_circle_parent_parent._parent_for_code_export = None

        self._update_connection()

    def on_observed_node_changed(self, changed_node):
        self._update_connection()

    @staticmethod
    def _assert_parent_child_possible(parent, child):
        if parent.parent.parent == child.parent.parent:
            raise ValueError(
                f&#34;A GeometricContact can not be created between two circles on the same axis or body. Both circles are located on {parent.parent.parent}&#34;
            )

    @property
    def child(self):
        &#34;&#34;&#34;The Circle that is connected to the GeometricContact [Node]

        See Also: parent
        &#34;&#34;&#34;
        return self._child_circle

    @child.setter
    def child(self, value):
        new_child = self._scene._node_from_node_or_str(value)
        if not isinstance(new_child, Circle):
            raise ValueError(
                f&#34;Child of a geometric contact should be a Circle, but {new_child.name} is a {type(new_child)}&#34;
            )

        if new_child.parent.parent is None:
            raise ValueError(
                f&#34;Child circle {new_child.name} is not located on an axis or body and can thus not be used as child&#34;
            )

        self._assert_parent_child_possible(self.parent, new_child)

        store = self._scene.current_manager
        self._scene.current_manager = self

        # release old child
        self._child_circle.observers.remove(self)
        self._child_circle_parent.observers.remove(self)

        # release the slaved axis system
        self._child_circle_parent_parent._parent_for_code_export = True
        self._child_circle_parent_parent.manager = None

        # set new parent
        self._child_circle = new_child
        self._child_circle_parent = new_child.parent
        self._child_circle_parent_parent = new_child.parent.parent

        # and observe
        self._child_circle.observers.append(self)
        self._child_circle_parent.observers.append(self)

        # and manage
        self._child_circle_parent_parent._parent_for_code_export = None
        self._child_circle_parent_parent.manager = self

        self._scene.current_manager = store

        self._update_connection()

    @property
    def parent(self):
        &#34;&#34;&#34;The Circle that the GeometricConnection is connected to [Node]

        See Also: child
        &#34;&#34;&#34;
        return self._parent_circle

    @parent.setter
    @node_setter_manageable
    @node_setter_observable
    def parent(self, var):
        if var is None:
            raise ValueError(
                &#34;Parent of a geometric contact should be a Circle, not None&#34;
            )

        new_parent = self._scene._node_from_node_or_str(var)
        if not isinstance(new_parent, Circle):
            raise ValueError(
                f&#34;Parent of a geometric contact should be a Circle, but {new_parent.name} is a {type(new_parent)}&#34;
            )

        self._assert_parent_child_possible(new_parent, self.child)

        # release old parent
        self._parent_circle.observers.remove(self)
        self._parent_circle_parent.observers.remove(self)

        # set new parent
        self._parent_circle = new_parent
        self._parent_circle_parent = new_parent.parent

        # and observe
        self._parent_circle.observers.append(self)
        self._parent_circle_parent.observers.append(self)

        self._update_connection()

    def change_parent_to(self, new_parent):
        self.parent = new_parent

    def delete(self):

        # release management
        for node in self.managed_nodes():
            node._manager = None

        self._child_circle_parent_parent.change_parent_to(None)

        self._scene.delete(self._axis_on_child)
        self._scene.delete(self._pin_hole_connection)
        self._scene.delete(self._axis_on_parent)

        # release observers
        self._parent_circle.observers.remove(self)
        self._parent_circle_parent.observers.remove(self)

        self._child_circle.observers.remove(self)
        self._child_circle_parent.observers.remove(self)

    def _update_connection(self):

        remember = self._scene.current_manager
        self._scene.current_manager = self  # claim management

        # get current properties

        c_swivel = self.swivel
        c_swivel_fixed = self.swivel_fixed
        c_rotation_on_parent = self.rotation_on_parent
        c_fixed_to_parent = self.fixed_to_parent
        c_child_rotation = self.child_rotation
        c_child_fixed = self.child_fixed

        pin1 = self._child_circle  # nodeB
        pin2 = self._parent_circle  # nodeA

        if pin1.parent.parent is None:
            raise ValueError(
                &#34;The slaved pin is not located on an axis. Can not create the connection because there is no axis to nodeB&#34;
            )

        # --------- prepare hole

        if pin2.parent.parent is not None:
            self._axis_on_parent.parent = pin2.parent.parent
        self._axis_on_parent.position = pin2.parent.position
        self._axis_on_parent.fixed = (True, True, True, True, True, True)

        self._axis_on_parent.rotation = rotation_from_y_axis_direction(pin2.axis)

        # Position connection axis at the center of the nodeA axis (pin2)
        # and allow it to rotate about the pin
        self._pin_hole_connection.position = (0, 0, 0)
        self._pin_hole_connection.parent = self._axis_on_parent
        self._pin_hole_connection.fixed = (True, True, True, True, False, True)

        self._connection_axial_rotation.parent = self._pin_hole_connection
        self._connection_axial_rotation.position = (0, 0, 0)

        # Position the connection pin (self) on the target pin and
        # place the parent of the parent of the pin (the axis) on the connection axis
        # and fix it
        slaved_axis = pin1.parent.parent

        slaved_axis.parent = self._axis_on_child
        slaved_axis.position = -np.array(pin1.parent.position)
        slaved_axis.rotation = rotation_from_y_axis_direction(-1 * np.array(pin1.axis))

        slaved_axis.fixed = True

        self._axis_on_child.parent = self._connection_axial_rotation
        self._axis_on_child.rotation = (0, 0, 0)
        self._axis_on_child.fixed = (True, True, True, True, False, True)

        if self._inside_connection:

            # Place the pin in the hole
            self._connection_axial_rotation.rotation = (0, 0, 0)
            self._axis_on_child.position = (pin2.radius - pin1.radius, 0, 0)

        else:

            # pin-pin connection
            self._axis_on_child.position = (pin1.radius + pin2.radius, 0, 0)
            self._connection_axial_rotation.rotation = (90, 0, 0)

        # restore settings
        self.swivel = c_swivel
        self.swivel_fixed = c_swivel_fixed
        self.rotation_on_parent = c_rotation_on_parent
        self.fixed_to_parent = c_fixed_to_parent
        self.child_rotation = c_child_rotation
        self.child_fixed = c_child_fixed

        self._scene.current_manager = remember

    def set_pin_pin_connection(self):
        &#34;&#34;&#34;Sets the connection to be of type pin-pin&#34;&#34;&#34;

        self._inside_connection = False
        if self.swivel == 0:
            self.swivel = 90
        elif self.swivel == 180:
            self.swivel = 270

        self._update_connection()

    def set_pin_in_hole_connection(self):
        &#34;&#34;&#34;Sets the connection to be of type pin-in-hole

        The axes of the two sheaves are aligned by rotating the slaved body
        The axes of the two sheaves are placed at a distance hole_dia - pin_dia apart, perpendicular to the axis direction
        An axes is created at the centers of the two sheaves
        These axes are connected with a shore axis which is allowed to rotate relative to the nodeA axis
        the nodeB axis is fixed to this rotating axis
        &#34;&#34;&#34;
        self._inside_connection = True

        if self.swivel == 90:
            self.swivel = 0
        elif self.swivel == 270:
            self.swivel = 180

        self._update_connection()

    def managed_nodes(self):
        &#34;&#34;&#34;Returns a list of managed nodes&#34;&#34;&#34;

        return [
            self._child_circle_parent_parent,
            self._axis_on_parent,
            self._axis_on_child,
            self._pin_hole_connection,
            self._connection_axial_rotation,
        ]

    def depends_on(self):
        return [self._parent_circle, self._child_circle]

    def creates(self, node: Node):
        return node in [
            self._axis_on_parent,
            self._axis_on_child,
            self._pin_hole_connection,
            self._connection_axial_rotation,
        ]

    def flip(self):
        &#34;&#34;&#34;Changes the swivel angle by 180 degrees&#34;&#34;&#34;
        self.swivel = np.mod(self.swivel + 180, 360)

    def change_side(self):
        self.rotation_on_parent = np.mod(self.rotation_on_parent + 180, 360)
        self.child_rotation = np.mod(self.child_rotation + 180, 360)

    @property
    def swivel(self):
        &#34;&#34;&#34;Swivel angle between parent and child objects [degrees]&#34;&#34;&#34;
        return self._connection_axial_rotation.rotation[0]

    @swivel.setter
    @node_setter_manageable
    @node_setter_observable
    def swivel(self, value):
        remember = self._scene.current_manager  # claim management
        self._scene.current_manager = self
        self._connection_axial_rotation.rx = value
        self._scene.current_manager = remember  # restore old manager

    @property
    def swivel_fixed(self):
        &#34;&#34;&#34;Allow parent and child to swivel relative to eachother [boolean]&#34;&#34;&#34;
        return self._connection_axial_rotation.fixed[3]

    @swivel_fixed.setter
    @node_setter_manageable
    @node_setter_observable
    def swivel_fixed(self, value):
        remember = self._scene.current_manager  # claim management
        self._scene.current_manager = self
        self._connection_axial_rotation.fixed = [True, True, True, value, True, True]
        self._scene.current_manager = remember  # restore old manager

    @property
    def rotation_on_parent(self):
        &#34;&#34;&#34;Angle between the line connecting the centers of the circles and the axis system of the parent node [degrees]&#34;&#34;&#34;
        return self._pin_hole_connection.ry

    @rotation_on_parent.setter
    @node_setter_manageable
    @node_setter_observable
    def rotation_on_parent(self, value):
        remember = self._scene.current_manager  # claim management
        self._scene.current_manager = self
        self._pin_hole_connection.ry = value
        self._scene.current_manager = remember  # restore old manager

    @property
    def fixed_to_parent(self):
        &#34;&#34;&#34;Allow rotation around parent [boolean]

        see also: rotation_on_parent&#34;&#34;&#34;
        return self._pin_hole_connection.fixed[4]

    @fixed_to_parent.setter
    @node_setter_manageable
    @node_setter_observable
    def fixed_to_parent(self, value):
        remember = self._scene.current_manager  # claim management
        self._scene.current_manager = self
        self._pin_hole_connection.fixed = [True, True, True, True, value, True]
        self._scene.current_manager = remember  # restore old manager

    @property
    def child_rotation(self):
        &#34;&#34;&#34;Angle between the line connecting the centers of the circles and the axis system of the child node [degrees]&#34;&#34;&#34;
        return self._axis_on_child.ry

    @child_rotation.setter
    @node_setter_manageable
    @node_setter_observable
    def child_rotation(self, value):
        remember = self._scene.current_manager  # claim management
        self._scene.current_manager = self
        self._axis_on_child.ry = value
        self._scene.current_manager = remember  # restore old manager

    @property
    def child_fixed(self):
        &#34;&#34;&#34;Allow rotation of child relative to connection, see also: child_rotation [boolean]&#34;&#34;&#34;
        return self._axis_on_child.fixed[4]

    @child_fixed.setter
    @node_setter_manageable
    @node_setter_observable
    def child_fixed(self, value):
        remember = self._scene.current_manager  # claim management
        self._scene.current_manager = self
        self._axis_on_child.fixed = [True, True, True, True, value, True]
        self._scene.current_manager = remember  # restore old manager

    @property
    def inside(self):
        &#34;&#34;&#34;Type of connection: True means child circle is inside parent circle, False means the child circle is outside but the circumferences contact [boolean]&#34;&#34;&#34;
        return self._inside_connection

    @inside.setter
    @node_setter_manageable
    @node_setter_observable
    def inside(self, value):
        if value == self._inside_connection:
            return

        if value:
            self.set_pin_in_hole_connection()
        else:
            self.set_pin_pin_connection()

    def give_python_code(self):

        old_manger = self._scene.current_manager
        self._scene.current_manager = self

        code = []

        # code.append(&#39;#  create the connection&#39;)
        code.append(f&#34;s.new_geometriccontact(name = &#39;{self.name}&#39;,&#34;)
        code.append(f&#34;                       child = &#39;{self._child_circle.name}&#39;,&#34;)
        code.append(f&#34;                       parent = &#39;{self._parent_circle.name}&#39;,&#34;)
        code.append(f&#34;                       inside={self.inside},&#34;)

        if self.inside and self.swivel == 0:
            pass  # default for inside
        else:
            if not self.inside and self.swivel == 90:
                pass  # default for outside
            else:
                code.append(f&#34;                       swivel={self.swivel},&#34;)

        if not self.swivel_fixed:
            code.append(f&#34;                       swivel_fixed={self.swivel_fixed},&#34;)
        if self.fixed_to_parent:
            code.append(
                f&#34;                       parent_rotation={self.rotation_on_parent},&#34;
            )
            code.append(
                f&#34;                       fixed_to_parent={self.fixed_to_parent},&#34;
            )
        else:
            code.append(
                f&#34;                       fixed_to_parent=solved({self.fixed_to_parent}),&#34;
            )
        if self.child_fixed:
            code.append(f&#34;                       child_fixed={self.child_fixed},&#34;)
            code.append(f&#34;                       child_rotation={self.child_rotation},&#34;)
        else:
            code.append(
                f&#34;                       child_rotation=solved({self.child_rotation}),&#34;
            )

        code = [
            *code[:-1],
            code[-1][:-1] + &#34; )&#34;,
        ]  # remove the , from the last entry [should be a quicker way to do this]

        self._scene.current_manager = old_manger

        return &#34;\n&#34;.join(code)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.Manager" href="#DAVE.scene.Manager">Manager</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.GeometricContact.child"><code class="name">var <span class="ident">child</span></code></dt>
<dd>
<div class="desc"><p>The Circle that is connected to the GeometricContact [Node]</p>
<p>See Also: parent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def child(self):
    &#34;&#34;&#34;The Circle that is connected to the GeometricContact [Node]

    See Also: parent
    &#34;&#34;&#34;
    return self._child_circle</code></pre>
</details>
</dd>
<dt id="DAVE.scene.GeometricContact.child_fixed"><code class="name">var <span class="ident">child_fixed</span></code></dt>
<dd>
<div class="desc"><p>Allow rotation of child relative to connection, see also: child_rotation [boolean]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def child_fixed(self):
    &#34;&#34;&#34;Allow rotation of child relative to connection, see also: child_rotation [boolean]&#34;&#34;&#34;
    return self._axis_on_child.fixed[4]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.GeometricContact.child_rotation"><code class="name">var <span class="ident">child_rotation</span></code></dt>
<dd>
<div class="desc"><p>Angle between the line connecting the centers of the circles and the axis system of the child node [degrees]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def child_rotation(self):
    &#34;&#34;&#34;Angle between the line connecting the centers of the circles and the axis system of the child node [degrees]&#34;&#34;&#34;
    return self._axis_on_child.ry</code></pre>
</details>
</dd>
<dt id="DAVE.scene.GeometricContact.fixed_to_parent"><code class="name">var <span class="ident">fixed_to_parent</span></code></dt>
<dd>
<div class="desc"><p>Allow rotation around parent [boolean]</p>
<p>see also: rotation_on_parent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fixed_to_parent(self):
    &#34;&#34;&#34;Allow rotation around parent [boolean]

    see also: rotation_on_parent&#34;&#34;&#34;
    return self._pin_hole_connection.fixed[4]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.GeometricContact.inside"><code class="name">var <span class="ident">inside</span></code></dt>
<dd>
<div class="desc"><p>Type of connection: True means child circle is inside parent circle, False means the child circle is outside but the circumferences contact [boolean]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def inside(self):
    &#34;&#34;&#34;Type of connection: True means child circle is inside parent circle, False means the child circle is outside but the circumferences contact [boolean]&#34;&#34;&#34;
    return self._inside_connection</code></pre>
</details>
</dd>
<dt id="DAVE.scene.GeometricContact.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"><p>The Circle that the GeometricConnection is connected to [Node]</p>
<p>See Also: child</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self):
    &#34;&#34;&#34;The Circle that the GeometricConnection is connected to [Node]

    See Also: child
    &#34;&#34;&#34;
    return self._parent_circle</code></pre>
</details>
</dd>
<dt id="DAVE.scene.GeometricContact.rotation_on_parent"><code class="name">var <span class="ident">rotation_on_parent</span></code></dt>
<dd>
<div class="desc"><p>Angle between the line connecting the centers of the circles and the axis system of the parent node [degrees]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rotation_on_parent(self):
    &#34;&#34;&#34;Angle between the line connecting the centers of the circles and the axis system of the parent node [degrees]&#34;&#34;&#34;
    return self._pin_hole_connection.ry</code></pre>
</details>
</dd>
<dt id="DAVE.scene.GeometricContact.swivel"><code class="name">var <span class="ident">swivel</span></code></dt>
<dd>
<div class="desc"><p>Swivel angle between parent and child objects [degrees]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def swivel(self):
    &#34;&#34;&#34;Swivel angle between parent and child objects [degrees]&#34;&#34;&#34;
    return self._connection_axial_rotation.rotation[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.GeometricContact.swivel_fixed"><code class="name">var <span class="ident">swivel_fixed</span></code></dt>
<dd>
<div class="desc"><p>Allow parent and child to swivel relative to eachother [boolean]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def swivel_fixed(self):
    &#34;&#34;&#34;Allow parent and child to swivel relative to eachother [boolean]&#34;&#34;&#34;
    return self._connection_axial_rotation.fixed[3]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.GeometricContact.change_parent_to"><code class="name flex">
<span>def <span class="ident">change_parent_to</span></span>(<span>self, new_parent)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_parent_to(self, new_parent):
    self.parent = new_parent</code></pre>
</details>
</dd>
<dt id="DAVE.scene.GeometricContact.change_side"><code class="name flex">
<span>def <span class="ident">change_side</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_side(self):
    self.rotation_on_parent = np.mod(self.rotation_on_parent + 180, 360)
    self.child_rotation = np.mod(self.child_rotation + 180, 360)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.GeometricContact.flip"><code class="name flex">
<span>def <span class="ident">flip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes the swivel angle by 180 degrees</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flip(self):
    &#34;&#34;&#34;Changes the swivel angle by 180 degrees&#34;&#34;&#34;
    self.swivel = np.mod(self.swivel + 180, 360)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.GeometricContact.managed_nodes"><code class="name flex">
<span>def <span class="ident">managed_nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of managed nodes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def managed_nodes(self):
    &#34;&#34;&#34;Returns a list of managed nodes&#34;&#34;&#34;

    return [
        self._child_circle_parent_parent,
        self._axis_on_parent,
        self._axis_on_child,
        self._pin_hole_connection,
        self._connection_axial_rotation,
    ]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.GeometricContact.on_observed_node_changed"><code class="name flex">
<span>def <span class="ident">on_observed_node_changed</span></span>(<span>self, changed_node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_observed_node_changed(self, changed_node):
    self._update_connection()</code></pre>
</details>
</dd>
<dt id="DAVE.scene.GeometricContact.set_pin_in_hole_connection"><code class="name flex">
<span>def <span class="ident">set_pin_in_hole_connection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the connection to be of type pin-in-hole</p>
<p>The axes of the two sheaves are aligned by rotating the slaved body
The axes of the two sheaves are placed at a distance hole_dia - pin_dia apart, perpendicular to the axis direction
An axes is created at the centers of the two sheaves
These axes are connected with a shore axis which is allowed to rotate relative to the nodeA axis
the nodeB axis is fixed to this rotating axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_in_hole_connection(self):
    &#34;&#34;&#34;Sets the connection to be of type pin-in-hole

    The axes of the two sheaves are aligned by rotating the slaved body
    The axes of the two sheaves are placed at a distance hole_dia - pin_dia apart, perpendicular to the axis direction
    An axes is created at the centers of the two sheaves
    These axes are connected with a shore axis which is allowed to rotate relative to the nodeA axis
    the nodeB axis is fixed to this rotating axis
    &#34;&#34;&#34;
    self._inside_connection = True

    if self.swivel == 90:
        self.swivel = 0
    elif self.swivel == 270:
        self.swivel = 180

    self._update_connection()</code></pre>
</details>
</dd>
<dt id="DAVE.scene.GeometricContact.set_pin_pin_connection"><code class="name flex">
<span>def <span class="ident">set_pin_pin_connection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the connection to be of type pin-pin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_pin_connection(self):
    &#34;&#34;&#34;Sets the connection to be of type pin-pin&#34;&#34;&#34;

    self._inside_connection = False
    if self.swivel == 0:
        self.swivel = 90
    elif self.swivel == 180:
        self.swivel = 270

    self._update_connection()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.Manager" href="#DAVE.scene.Manager">Manager</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.Manager.creates" href="#DAVE.scene.Manager.creates">creates</a></code></li>
<li><code><a title="DAVE.scene.Manager.delete" href="#DAVE.scene.Manager.delete">delete</a></code></li>
<li><code><a title="DAVE.scene.Manager.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.Manager.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.Manager.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.Manager.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.Manager.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.HydSpring"><code class="flex name class">
<span>class <span class="ident">HydSpring</span></span>
<span>(</span><span>scene, vfNode)</span>
</code></dt>
<dd>
<div class="desc"><p>A HydSpring models a linearized hydrostatic spring.</p>
<p>The cob (center of buoyancy) is defined in the parent axis system.
All other properties are defined relative to the cob.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HydSpring(NodeWithParent):
    &#34;&#34;&#34;A HydSpring models a linearized hydrostatic spring.

    The cob (center of buoyancy) is defined in the parent axis system.
    All other properties are defined relative to the cob.

    &#34;&#34;&#34;

    @property
    def cob(self):
        &#34;&#34;&#34;Center of buoyancy in parent axis system (m,m,m)&#34;&#34;&#34;
        return self._vfNode.position

    @cob.setter
    @node_setter_manageable
    @node_setter_observable
    def cob(self, val):

        assert3f(val)
        self._vfNode.position = val

    @property
    def BMT(self):
        &#34;&#34;&#34;Vertical distance between cob and metacenter for roll [m]&#34;&#34;&#34;
        return self._vfNode.BMT

    @BMT.setter
    @node_setter_manageable
    @node_setter_observable
    def BMT(self, val):

        self._vfNode.BMT = val

    @property
    def BML(self):
        &#34;&#34;&#34;Vertical distance between cob and metacenter for pitch [m]&#34;&#34;&#34;
        return self._vfNode.BML

    @BML.setter
    @node_setter_manageable
    @node_setter_observable
    def BML(self, val):

        self._vfNode.BML = val

    @property
    def COFX(self):
        &#34;&#34;&#34;Horizontal x-position Center of Floatation (center of waterplane area), relative to cob [m]&#34;&#34;&#34;
        return self._vfNode.COFX

    @COFX.setter
    @node_setter_manageable
    @node_setter_observable
    def COFX(self, val):

        self._vfNode.COFX = val

    @property
    def COFY(self):
        &#34;&#34;&#34;Horizontal y-position Center of Floatation (center of waterplane area), relative to cob [m]&#34;&#34;&#34;
        return self._vfNode.COFY

    @COFY.setter
    @node_setter_manageable
    @node_setter_observable
    def COFY(self, val):

        self._vfNode.COFY = val

    @property
    def kHeave(self):
        &#34;&#34;&#34;Heave stiffness [kN/m]&#34;&#34;&#34;
        return self._vfNode.kHeave

    @kHeave.setter
    @node_setter_manageable
    @node_setter_observable
    def kHeave(self, val):

        self._vfNode.kHeave = val

    @property
    def waterline(self):
        &#34;&#34;&#34;Waterline-elevation relative to cob for un-stretched heave-spring. Positive if cob is below the waterline (which is where is normally is) [m]&#34;&#34;&#34;
        return self._vfNode.waterline

    @waterline.setter
    @node_setter_manageable
    @node_setter_observable
    def waterline(self, val):

        self._vfNode.waterline = val

    @property
    def displacement_kN(self):
        &#34;&#34;&#34;Displacement when waterline is at waterline-elevation [kN]&#34;&#34;&#34;
        return self._vfNode.displacement_kN

    @displacement_kN.setter
    @node_setter_manageable
    @node_setter_observable
    def displacement_kN(self, val):

        self._vfNode.displacement_kN = val

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        # new_force(self, name, parent=None, force=None, moment=None):

        code += &#34;\ns.new_hydspring(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            parent=&#39;{}&#39;,&#34;.format(self.parent_for_export.name)
        code += &#34;\n            cob=({}, {}, {}),&#34;.format(*self.cob)
        code += &#34;\n            BMT={},&#34;.format(self.BMT)
        code += &#34;\n            BML={},&#34;.format(self.BML)
        code += &#34;\n            COFX={},&#34;.format(self.COFX)
        code += &#34;\n            COFY={},&#34;.format(self.COFY)
        code += &#34;\n            kHeave={},&#34;.format(self.kHeave)
        code += &#34;\n            waterline={},&#34;.format(self.waterline)
        code += &#34;\n            displacement_kN={} )&#34;.format(self.displacement_kN)

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.HydSpring.BML"><code class="name">var <span class="ident">BML</span></code></dt>
<dd>
<div class="desc"><p>Vertical distance between cob and metacenter for pitch [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def BML(self):
    &#34;&#34;&#34;Vertical distance between cob and metacenter for pitch [m]&#34;&#34;&#34;
    return self._vfNode.BML</code></pre>
</details>
</dd>
<dt id="DAVE.scene.HydSpring.BMT"><code class="name">var <span class="ident">BMT</span></code></dt>
<dd>
<div class="desc"><p>Vertical distance between cob and metacenter for roll [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def BMT(self):
    &#34;&#34;&#34;Vertical distance between cob and metacenter for roll [m]&#34;&#34;&#34;
    return self._vfNode.BMT</code></pre>
</details>
</dd>
<dt id="DAVE.scene.HydSpring.COFX"><code class="name">var <span class="ident">COFX</span></code></dt>
<dd>
<div class="desc"><p>Horizontal x-position Center of Floatation (center of waterplane area), relative to cob [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def COFX(self):
    &#34;&#34;&#34;Horizontal x-position Center of Floatation (center of waterplane area), relative to cob [m]&#34;&#34;&#34;
    return self._vfNode.COFX</code></pre>
</details>
</dd>
<dt id="DAVE.scene.HydSpring.COFY"><code class="name">var <span class="ident">COFY</span></code></dt>
<dd>
<div class="desc"><p>Horizontal y-position Center of Floatation (center of waterplane area), relative to cob [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def COFY(self):
    &#34;&#34;&#34;Horizontal y-position Center of Floatation (center of waterplane area), relative to cob [m]&#34;&#34;&#34;
    return self._vfNode.COFY</code></pre>
</details>
</dd>
<dt id="DAVE.scene.HydSpring.cob"><code class="name">var <span class="ident">cob</span></code></dt>
<dd>
<div class="desc"><p>Center of buoyancy in parent axis system (m,m,m)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cob(self):
    &#34;&#34;&#34;Center of buoyancy in parent axis system (m,m,m)&#34;&#34;&#34;
    return self._vfNode.position</code></pre>
</details>
</dd>
<dt id="DAVE.scene.HydSpring.displacement_kN"><code class="name">var <span class="ident">displacement_kN</span></code></dt>
<dd>
<div class="desc"><p>Displacement when waterline is at waterline-elevation [kN]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def displacement_kN(self):
    &#34;&#34;&#34;Displacement when waterline is at waterline-elevation [kN]&#34;&#34;&#34;
    return self._vfNode.displacement_kN</code></pre>
</details>
</dd>
<dt id="DAVE.scene.HydSpring.kHeave"><code class="name">var <span class="ident">kHeave</span></code></dt>
<dd>
<div class="desc"><p>Heave stiffness [kN/m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def kHeave(self):
    &#34;&#34;&#34;Heave stiffness [kN/m]&#34;&#34;&#34;
    return self._vfNode.kHeave</code></pre>
</details>
</dd>
<dt id="DAVE.scene.HydSpring.waterline"><code class="name">var <span class="ident">waterline</span></code></dt>
<dd>
<div class="desc"><p>Waterline-elevation relative to cob for un-stretched heave-spring. Positive if cob is below the waterline (which is where is normally is) [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def waterline(self):
    &#34;&#34;&#34;Waterline-elevation relative to cob for un-stretched heave-spring. Positive if cob is below the waterline (which is where is normally is) [m]&#34;&#34;&#34;
    return self._vfNode.waterline</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.NodeWithParent.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.parent" href="#DAVE.scene.NodeWithParent.parent">parent</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.LC6d"><code class="flex name class">
<span>class <span class="ident">LC6d</span></span>
<span>(</span><span>scene, node)</span>
</code></dt>
<dd>
<div class="desc"><p>A LC6d models a Linear Connector with 6 dofs.</p>
<p>It connects two Axis elements with six linear springs.</p>
<p>The first axis system is called "main", the second is called "secondary". The difference is that
the "main" axis system is used for the definition of the stiffness values.</p>
<p>The translational-springs are easy. The rotational springs may not be as intuitive. They are defined as:</p>
<ul>
<li>rotation_x = arc-tan ( uy[0] / uy[1] )</li>
<li>rotation_y = arc-tan ( -ux[0] / ux[2] )</li>
<li>rotation_z = arc-tan ( ux[0] / ux [1] )</li>
</ul>
<p>which works fine for small rotations and rotations about only a single axis.</p>
<p>Tip:
It is better to use use the "fixed" property of axis systems to create joints.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LC6d(CoreConnectedNode):
    &#34;&#34;&#34;A LC6d models a Linear Connector with 6 dofs.

    It connects two Axis elements with six linear springs.

    The first axis system is called &#34;main&#34;, the second is called &#34;secondary&#34;. The difference is that
    the &#34;main&#34; axis system is used for the definition of the stiffness values.

    The translational-springs are easy. The rotational springs may not be as intuitive. They are defined as:

      - rotation_x = arc-tan ( uy[0] / uy[1] )
      - rotation_y = arc-tan ( -ux[0] / ux[2] )
      - rotation_z = arc-tan ( ux[0] / ux [1] )

    which works fine for small rotations and rotations about only a single axis.

    Tip:
    It is better to use use the &#34;fixed&#34; property of axis systems to create joints.

    &#34;&#34;&#34;

    def __init__(self, scene, node):
        super().__init__(scene, node)
        self._main = None
        self._secondary = None

    def depends_on(self):
        return [self._main, self._secondary]

    @property
    def stiffness(self):
        &#34;&#34;&#34;Stiffness of the connector: kx, ky, kz, krx, kry, krz in [kN/m and kNm/rad] (axis system of the main axis)&#34;&#34;&#34;
        return self._vfNode.stiffness

    @stiffness.setter
    @node_setter_manageable
    @node_setter_observable
    def stiffness(self, val):

        self._vfNode.stiffness = val

    @property
    def main(self):
        &#34;&#34;&#34;Main axis system. This axis system dictates the axis system that the stiffness is expressed in&#34;&#34;&#34;
        return self._main

    @main.setter
    @node_setter_manageable
    @node_setter_observable
    def main(self, val):

        val = self._scene._node_from_node_or_str(val)
        if not isinstance(val, Axis):
            raise TypeError(&#34;Provided nodeA should be a Axis&#34;)

        self._main = val
        self._vfNode.master = val._vfNode

    @property
    def secondary(self):
        &#34;&#34;&#34;Secondary (connected) axis system&#34;&#34;&#34;
        return self._secondary

    @secondary.setter
    @node_setter_manageable
    @node_setter_observable
    def secondary(self, val):

        val = self._scene._node_from_node_or_str(val)
        if not isinstance(val, Axis):
            raise TypeError(&#34;Provided nodeA should be a Axis&#34;)

        self._secondary = val
        self._vfNode.slave = val._vfNode

    @property
    def fgx(self):
        &#34;&#34;&#34;Force on main in global coordinate frame [kN]&#34;&#34;&#34;
        return self._vfNode.global_force[0]

    @property
    def fgy(self):
        &#34;&#34;&#34;Force on main in global coordinate frame [kN]&#34;&#34;&#34;
        return self._vfNode.global_force[1]

    @property
    def fgz(self):
        &#34;&#34;&#34;Force on main in global coordinate frame [kN]&#34;&#34;&#34;
        return self._vfNode.global_force[2]

    @property
    def force_global(self):
        &#34;&#34;&#34;Force on main in global coordinate frame [kN]&#34;&#34;&#34;
        return self._vfNode.global_force

    @property
    def mgx(self):
        &#34;&#34;&#34;Moment on main in global coordinate frame [kNm]&#34;&#34;&#34;
        return self._vfNode.global_moment[0]

    @property
    def mgy(self):
        &#34;&#34;&#34;Moment on main in global coordinate frame [kNm]&#34;&#34;&#34;
        return self._vfNode.global_moment[1]

    @property
    def mgz(self):
        &#34;&#34;&#34;Moment on main in global coordinate frame [kNm]&#34;&#34;&#34;
        return self._vfNode.global_moment[2]

    @property
    def moment_global(self):
        &#34;&#34;&#34;Moment on main in global coordinate frame [kNm]&#34;&#34;&#34;
        return self._vfNode.global_moment

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        code += &#34;\ns.new_linear_connector_6d(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            main=&#39;{}&#39;,&#34;.format(self.main.name)
        code += &#34;\n            secondary=&#39;{}&#39;,&#34;.format(self.secondary.name)
        code += &#34;\n            stiffness=({}, {}, {}, &#34;.format(*self.stiffness[:3])
        code += &#34;\n                       {}, {}, {}) )&#34;.format(*self.stiffness[3:])

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.LC6d.fgx"><code class="name">var <span class="ident">fgx</span></code></dt>
<dd>
<div class="desc"><p>Force on main in global coordinate frame [kN]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fgx(self):
    &#34;&#34;&#34;Force on main in global coordinate frame [kN]&#34;&#34;&#34;
    return self._vfNode.global_force[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.LC6d.fgy"><code class="name">var <span class="ident">fgy</span></code></dt>
<dd>
<div class="desc"><p>Force on main in global coordinate frame [kN]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fgy(self):
    &#34;&#34;&#34;Force on main in global coordinate frame [kN]&#34;&#34;&#34;
    return self._vfNode.global_force[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.LC6d.fgz"><code class="name">var <span class="ident">fgz</span></code></dt>
<dd>
<div class="desc"><p>Force on main in global coordinate frame [kN]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fgz(self):
    &#34;&#34;&#34;Force on main in global coordinate frame [kN]&#34;&#34;&#34;
    return self._vfNode.global_force[2]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.LC6d.force_global"><code class="name">var <span class="ident">force_global</span></code></dt>
<dd>
<div class="desc"><p>Force on main in global coordinate frame [kN]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def force_global(self):
    &#34;&#34;&#34;Force on main in global coordinate frame [kN]&#34;&#34;&#34;
    return self._vfNode.global_force</code></pre>
</details>
</dd>
<dt id="DAVE.scene.LC6d.main"><code class="name">var <span class="ident">main</span></code></dt>
<dd>
<div class="desc"><p>Main axis system. This axis system dictates the axis system that the stiffness is expressed in</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def main(self):
    &#34;&#34;&#34;Main axis system. This axis system dictates the axis system that the stiffness is expressed in&#34;&#34;&#34;
    return self._main</code></pre>
</details>
</dd>
<dt id="DAVE.scene.LC6d.mgx"><code class="name">var <span class="ident">mgx</span></code></dt>
<dd>
<div class="desc"><p>Moment on main in global coordinate frame [kNm]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mgx(self):
    &#34;&#34;&#34;Moment on main in global coordinate frame [kNm]&#34;&#34;&#34;
    return self._vfNode.global_moment[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.LC6d.mgy"><code class="name">var <span class="ident">mgy</span></code></dt>
<dd>
<div class="desc"><p>Moment on main in global coordinate frame [kNm]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mgy(self):
    &#34;&#34;&#34;Moment on main in global coordinate frame [kNm]&#34;&#34;&#34;
    return self._vfNode.global_moment[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.LC6d.mgz"><code class="name">var <span class="ident">mgz</span></code></dt>
<dd>
<div class="desc"><p>Moment on main in global coordinate frame [kNm]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mgz(self):
    &#34;&#34;&#34;Moment on main in global coordinate frame [kNm]&#34;&#34;&#34;
    return self._vfNode.global_moment[2]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.LC6d.moment_global"><code class="name">var <span class="ident">moment_global</span></code></dt>
<dd>
<div class="desc"><p>Moment on main in global coordinate frame [kNm]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def moment_global(self):
    &#34;&#34;&#34;Moment on main in global coordinate frame [kNm]&#34;&#34;&#34;
    return self._vfNode.global_moment</code></pre>
</details>
</dd>
<dt id="DAVE.scene.LC6d.secondary"><code class="name">var <span class="ident">secondary</span></code></dt>
<dd>
<div class="desc"><p>Secondary (connected) axis system</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def secondary(self):
    &#34;&#34;&#34;Secondary (connected) axis system&#34;&#34;&#34;
    return self._secondary</code></pre>
</details>
</dd>
<dt id="DAVE.scene.LC6d.stiffness"><code class="name">var <span class="ident">stiffness</span></code></dt>
<dd>
<div class="desc"><p>Stiffness of the connector: kx, ky, kz, krx, kry, krz in [kN/m and kNm/rad] (axis system of the main axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stiffness(self):
    &#34;&#34;&#34;Stiffness of the connector: kx, ky, kz, krx, kry, krz in [kN/m and kNm/rad] (axis system of the main axis)&#34;&#34;&#34;
    return self._vfNode.stiffness</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.CoreConnectedNode.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.LoadShearMomentDiagram"><code class="flex name class">
<span>class <span class="ident">LoadShearMomentDiagram</span></span>
<span>(</span><span>datasource)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>datasource</code></strong></dt>
<dd>pyo3d.MomentDiagram object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LoadShearMomentDiagram:
    def __init__(self, datasource):
        &#34;&#34;&#34;

        Args:
            datasource: pyo3d.MomentDiagram object
        &#34;&#34;&#34;

        self.datasource = datasource

    def give_shear_and_moment(self, grid_n=100):
        &#34;&#34;&#34;Returns (position, shear, moment)&#34;&#34;&#34;
        x = self.datasource.grid(grid_n)
        return x, self.datasource.Vz, self.datasource.My

    def plot_simple(self, **kwargs):
        &#34;&#34;&#34;Plots the bending moment and shear in a single yy-plot.
        Creates a new figure

        any keyword arguments are passed to plt.figure(), so for example dpi=150 will increase the dpi

        Returns: figure
        &#34;&#34;&#34;
        x, Vz, My = self.give_shear_and_moment()
        import matplotlib.pyplot as plt
        plt.rcParams.update({&#34;font.family&#34;: &#34;sans-serif&#34;})
        plt.rcParams.update({&#34;font.sans-serif&#34;: &#34;consolas&#34;})
        plt.rcParams.update({&#34;font.size&#34;: 10})

        fig, ax1 = plt.subplots(1,1,**kwargs)
        ax2 = ax1.twinx()

        ax1.plot(x, My, &#34;g&#34;, lw=1, label=&#34;Bending Moment&#34;)
        ax2.plot(x, Vz, &#34;b&#34;, lw=1, label=&#34;Shear Force&#34;)

        from DAVE.gui.helpers.align_zeros_of_yyplots import align_y0_axis

        align_y0_axis(ax1, ax2)

        ax1.set_xlabel(&#34;Position [m]&#34;)
        ax1.set_ylabel(&#34;Bending Moment [kNm]&#34;)
        ax2.set_ylabel(&#34;Shear Force [kN]&#34;)

        ax1.tick_params(axis=&#34;y&#34;, colors=&#34;g&#34;)
        ax2.tick_params(axis=&#34;y&#34;, colors=&#34;b&#34;)

        # fig.legend()  - obvious from the axis

        ext = 0.1 * (np.max(x) - np.min(x))
        xx = [np.min(x) - ext, np.max(x) + ext]
        ax1.plot(xx, [0, 0], c=[0.5, 0.5, 0.5], lw=1, linestyle=&#34;:&#34;)
        ax1.set_xlim(xx)

        return fig

    def plot(self, grid_n=100, merge_adjacent_loads=True, filename=None):
        m = self.datasource  # alias

        x = m.grid(grid_n)
        linewidth = 1

        n = m.nLoads

        import matplotlib.pyplot as plt

        #
        plt.rcParams.update({&#34;font.family&#34;: &#34;sans-serif&#34;})
        plt.rcParams.update({&#34;font.sans-serif&#34;: &#34;consolas&#34;})
        plt.rcParams.update({&#34;font.size&#34;: 6})

        fig, (ax0, ax1, ax2) = plt.subplots(3, 1, figsize=(8.27, 11.69), dpi=100)
        textsize = 6

        # get loads

        loads = [m.load(i) for i in range(n)]

        texts = []  # for label placement
        texts_second = []  # for label placement

        # merge loads with same source and matching endpoints

        if merge_adjacent_loads:

            to_be_plotted = [loads[0]]

            for load in loads[1:]:
                name = load[2]

                # if the previous load is a continuous load from the same source
                # and the current load is also a continuous load
                # then merge the two.
                prev_load = to_be_plotted[-1]

                if len(prev_load[0]) != 2:  # not a point-load
                    if len(load[0]) != 2:  # not a point-load
                        if prev_load[2] == load[2]:  # same name

                            # merge the two
                            # remove the last (zero) entry of the previous lds
                            # as well as the first entry of these

                            # smoothed
                            xx = [*prev_load[0][:-1], *load[0][2:]]
                            yy = [
                                *prev_load[1][:-2],
                                0.5 * (prev_load[1][-2] + load[1][1]),
                                *load[1][2:],
                            ]

                            to_be_plotted[-1] = (xx, yy, load[2])

                            continue
                # else
                if np.max(np.abs(load[1])) &gt; 1e-6:
                    to_be_plotted.append(load)

        else:
            to_be_plotted = loads

        #
        from matplotlib import cm

        colors = cm.get_cmap(&#34;hsv&#34;, lut=len(to_be_plotted))

        from matplotlib.patches import Polygon

        ax0_second = ax0.twinx()

        for icol, ld in enumerate(to_be_plotted):

            xx = ld[0]
            yy = ld[1]
            name = ld[2]

            if np.max(np.abs(yy)) &lt; 1e-6:
                continue

            is_concentrated = len(xx) == 2

            # determine the name, default to Force / q-load if no name is present
            if name == &#34;&#34;:
                if is_concentrated:
                    name = &#34;Force &#34;
                else:
                    name = &#34;q-load &#34;

            col = [0.8 * c for c in colors(icol)]
            col[3] = 1.0  # alpha

            if is_concentrated:  # concentrated loads on left axis
                lbl = f&#34; {name} {ld[1][1]:.2f}&#34;
                texts.append(
                    ax0.text(
                        xx[0], yy[1], lbl, fontsize=textsize, horizontalalignment=&#34;left&#34;
                    )
                )
                ax0.plot(xx, yy, label=lbl, color=col, linewidth=linewidth)
                if yy[1] &gt; 0:
                    ax0.plot(xx[1], yy[1], marker=&#34;^&#34;, color=col, linewidth=linewidth)
                else:
                    ax0.plot(xx[1], yy[1], marker=&#34;v&#34;, color=col, linewidth=linewidth)

            else:  # distributed loads on right axis
                lbl = f&#34;{name}&#34;  # {yy[1]:.2f} kN/m at {xx[0]:.3f}m .. {yy[-2]:.2f} kN/m at {xx[-1]:.3f}m&#34;

                vertices = [(xx[i], yy[i]) for i in range(len(xx))]

                ax0_second.add_patch(
                    Polygon(vertices, facecolor=[col[0], col[1], col[2], 0.2])
                )
                ax0_second.plot(xx, yy, label=lbl, color=col, linewidth=linewidth)

                lx = np.mean(xx)
                ly = np.interp(lx, xx, yy)

                texts_second.append(
                    ax0_second.text(
                        lx,
                        ly,
                        lbl,
                        color=[0, 0, 0],
                        horizontalalignment=&#34;center&#34;,
                        fontsize=textsize,
                    )
                )

        ax0.grid()
        ax0.set_title(&#34;Loads&#34;)
        ax0.set_ylabel(&#34;Load [kN]&#34;)
        ax0_second.set_ylabel(&#34;Load [kN/m]&#34;)

        # plot moments
        # each concentrated load may have a moment as well
        for i in range(m.nLoads):
            mom = m.moment(i)
            if np.linalg.norm(mom) &gt; 1e-6:
                load = m.load(i)
                xx = load[0][0]
                lbl = f&#34;{load[2]}, m = {mom[1]:.2f} kNm&#34;
                ax0.plot(xx, 0, marker=&#34;x&#34;, label=lbl, color=(0, 0, 0, 1))
                texts.append(
                    ax0.text(
                        xx, 0, lbl, horizontalalignment=&#34;center&#34;, fontsize=textsize
                    )
                )

        fig.legend(loc=&#34;upper right&#34;)

        # add a zero-line
        xx = [np.min(x), np.max(x)]
        ax0.plot(xx, (0, 0), &#34;k-&#34;)

        from DAVE.gui.helpers.align_zeros_of_yyplots import align_y0_axis

        align_y0_axis(ax0, ax0_second)

        from DAVE.reporting.utils.TextAvoidOverlap import minimizeTextOverlap

        minimizeTextOverlap(
            texts_second,
            fig=fig,
            ax=ax0_second,
            vertical_only=True,
            optimize_initial_positions=False,
            annotate=False,
        )
        minimizeTextOverlap(
            texts,
            fig=fig,
            ax=ax0,
            vertical_only=True,
            optimize_initial_positions=False,
            annotate=False,
        )

        ax0.spines[&#34;top&#34;].set_visible(False)
        ax0.spines[&#34;bottom&#34;].set_visible(False)

        ax0_second.spines[&#34;top&#34;].set_visible(False)
        ax0_second.spines[&#34;bottom&#34;].set_visible(False)

        ax1.plot(x, m.Vz, &#34;k-&#34;, linewidth=linewidth)

        i = np.argmax(np.abs(m.Vz))
        ax1.plot(x[i], m.Vz[i], &#34;b*&#34;)
        ax1.text(x[i], m.Vz[i], f&#34;{m.Vz[i]:.2f}&#34;)

        ax1.grid()
        ax1.set_title(&#34;Shear&#34;)
        ax1.set_ylabel(&#34;[kN]&#34;)

        ax2.plot(x, m.My, &#34;k-&#34;, linewidth=linewidth)
        i = np.argmax(np.abs(m.My))
        ax2.plot(x[i], m.My[i], &#34;b*&#34;)
        ax2.text(x[i], m.My[i], f&#34;{m.My[i]:.2f}&#34;)

        ax2.grid()
        ax2.set_title(&#34;Moment&#34;)
        ax2.set_ylabel(&#34;[kN*m]&#34;)

        if filename is None:
            plt.show()
        else:
            fig.savefig(filename)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.LoadShearMomentDiagram.give_shear_and_moment"><code class="name flex">
<span>def <span class="ident">give_shear_and_moment</span></span>(<span>self, grid_n=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns (position, shear, moment)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def give_shear_and_moment(self, grid_n=100):
    &#34;&#34;&#34;Returns (position, shear, moment)&#34;&#34;&#34;
    x = self.datasource.grid(grid_n)
    return x, self.datasource.Vz, self.datasource.My</code></pre>
</details>
</dd>
<dt id="DAVE.scene.LoadShearMomentDiagram.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, grid_n=100, merge_adjacent_loads=True, filename=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, grid_n=100, merge_adjacent_loads=True, filename=None):
    m = self.datasource  # alias

    x = m.grid(grid_n)
    linewidth = 1

    n = m.nLoads

    import matplotlib.pyplot as plt

    #
    plt.rcParams.update({&#34;font.family&#34;: &#34;sans-serif&#34;})
    plt.rcParams.update({&#34;font.sans-serif&#34;: &#34;consolas&#34;})
    plt.rcParams.update({&#34;font.size&#34;: 6})

    fig, (ax0, ax1, ax2) = plt.subplots(3, 1, figsize=(8.27, 11.69), dpi=100)
    textsize = 6

    # get loads

    loads = [m.load(i) for i in range(n)]

    texts = []  # for label placement
    texts_second = []  # for label placement

    # merge loads with same source and matching endpoints

    if merge_adjacent_loads:

        to_be_plotted = [loads[0]]

        for load in loads[1:]:
            name = load[2]

            # if the previous load is a continuous load from the same source
            # and the current load is also a continuous load
            # then merge the two.
            prev_load = to_be_plotted[-1]

            if len(prev_load[0]) != 2:  # not a point-load
                if len(load[0]) != 2:  # not a point-load
                    if prev_load[2] == load[2]:  # same name

                        # merge the two
                        # remove the last (zero) entry of the previous lds
                        # as well as the first entry of these

                        # smoothed
                        xx = [*prev_load[0][:-1], *load[0][2:]]
                        yy = [
                            *prev_load[1][:-2],
                            0.5 * (prev_load[1][-2] + load[1][1]),
                            *load[1][2:],
                        ]

                        to_be_plotted[-1] = (xx, yy, load[2])

                        continue
            # else
            if np.max(np.abs(load[1])) &gt; 1e-6:
                to_be_plotted.append(load)

    else:
        to_be_plotted = loads

    #
    from matplotlib import cm

    colors = cm.get_cmap(&#34;hsv&#34;, lut=len(to_be_plotted))

    from matplotlib.patches import Polygon

    ax0_second = ax0.twinx()

    for icol, ld in enumerate(to_be_plotted):

        xx = ld[0]
        yy = ld[1]
        name = ld[2]

        if np.max(np.abs(yy)) &lt; 1e-6:
            continue

        is_concentrated = len(xx) == 2

        # determine the name, default to Force / q-load if no name is present
        if name == &#34;&#34;:
            if is_concentrated:
                name = &#34;Force &#34;
            else:
                name = &#34;q-load &#34;

        col = [0.8 * c for c in colors(icol)]
        col[3] = 1.0  # alpha

        if is_concentrated:  # concentrated loads on left axis
            lbl = f&#34; {name} {ld[1][1]:.2f}&#34;
            texts.append(
                ax0.text(
                    xx[0], yy[1], lbl, fontsize=textsize, horizontalalignment=&#34;left&#34;
                )
            )
            ax0.plot(xx, yy, label=lbl, color=col, linewidth=linewidth)
            if yy[1] &gt; 0:
                ax0.plot(xx[1], yy[1], marker=&#34;^&#34;, color=col, linewidth=linewidth)
            else:
                ax0.plot(xx[1], yy[1], marker=&#34;v&#34;, color=col, linewidth=linewidth)

        else:  # distributed loads on right axis
            lbl = f&#34;{name}&#34;  # {yy[1]:.2f} kN/m at {xx[0]:.3f}m .. {yy[-2]:.2f} kN/m at {xx[-1]:.3f}m&#34;

            vertices = [(xx[i], yy[i]) for i in range(len(xx))]

            ax0_second.add_patch(
                Polygon(vertices, facecolor=[col[0], col[1], col[2], 0.2])
            )
            ax0_second.plot(xx, yy, label=lbl, color=col, linewidth=linewidth)

            lx = np.mean(xx)
            ly = np.interp(lx, xx, yy)

            texts_second.append(
                ax0_second.text(
                    lx,
                    ly,
                    lbl,
                    color=[0, 0, 0],
                    horizontalalignment=&#34;center&#34;,
                    fontsize=textsize,
                )
            )

    ax0.grid()
    ax0.set_title(&#34;Loads&#34;)
    ax0.set_ylabel(&#34;Load [kN]&#34;)
    ax0_second.set_ylabel(&#34;Load [kN/m]&#34;)

    # plot moments
    # each concentrated load may have a moment as well
    for i in range(m.nLoads):
        mom = m.moment(i)
        if np.linalg.norm(mom) &gt; 1e-6:
            load = m.load(i)
            xx = load[0][0]
            lbl = f&#34;{load[2]}, m = {mom[1]:.2f} kNm&#34;
            ax0.plot(xx, 0, marker=&#34;x&#34;, label=lbl, color=(0, 0, 0, 1))
            texts.append(
                ax0.text(
                    xx, 0, lbl, horizontalalignment=&#34;center&#34;, fontsize=textsize
                )
            )

    fig.legend(loc=&#34;upper right&#34;)

    # add a zero-line
    xx = [np.min(x), np.max(x)]
    ax0.plot(xx, (0, 0), &#34;k-&#34;)

    from DAVE.gui.helpers.align_zeros_of_yyplots import align_y0_axis

    align_y0_axis(ax0, ax0_second)

    from DAVE.reporting.utils.TextAvoidOverlap import minimizeTextOverlap

    minimizeTextOverlap(
        texts_second,
        fig=fig,
        ax=ax0_second,
        vertical_only=True,
        optimize_initial_positions=False,
        annotate=False,
    )
    minimizeTextOverlap(
        texts,
        fig=fig,
        ax=ax0,
        vertical_only=True,
        optimize_initial_positions=False,
        annotate=False,
    )

    ax0.spines[&#34;top&#34;].set_visible(False)
    ax0.spines[&#34;bottom&#34;].set_visible(False)

    ax0_second.spines[&#34;top&#34;].set_visible(False)
    ax0_second.spines[&#34;bottom&#34;].set_visible(False)

    ax1.plot(x, m.Vz, &#34;k-&#34;, linewidth=linewidth)

    i = np.argmax(np.abs(m.Vz))
    ax1.plot(x[i], m.Vz[i], &#34;b*&#34;)
    ax1.text(x[i], m.Vz[i], f&#34;{m.Vz[i]:.2f}&#34;)

    ax1.grid()
    ax1.set_title(&#34;Shear&#34;)
    ax1.set_ylabel(&#34;[kN]&#34;)

    ax2.plot(x, m.My, &#34;k-&#34;, linewidth=linewidth)
    i = np.argmax(np.abs(m.My))
    ax2.plot(x[i], m.My[i], &#34;b*&#34;)
    ax2.text(x[i], m.My[i], f&#34;{m.My[i]:.2f}&#34;)

    ax2.grid()
    ax2.set_title(&#34;Moment&#34;)
    ax2.set_ylabel(&#34;[kN*m]&#34;)

    if filename is None:
        plt.show()
    else:
        fig.savefig(filename)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.LoadShearMomentDiagram.plot_simple"><code class="name flex">
<span>def <span class="ident">plot_simple</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the bending moment and shear in a single yy-plot.
Creates a new figure</p>
<p>any keyword arguments are passed to plt.figure(), so for example dpi=150 will increase the dpi</p>
<p>Returns: figure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_simple(self, **kwargs):
    &#34;&#34;&#34;Plots the bending moment and shear in a single yy-plot.
    Creates a new figure

    any keyword arguments are passed to plt.figure(), so for example dpi=150 will increase the dpi

    Returns: figure
    &#34;&#34;&#34;
    x, Vz, My = self.give_shear_and_moment()
    import matplotlib.pyplot as plt
    plt.rcParams.update({&#34;font.family&#34;: &#34;sans-serif&#34;})
    plt.rcParams.update({&#34;font.sans-serif&#34;: &#34;consolas&#34;})
    plt.rcParams.update({&#34;font.size&#34;: 10})

    fig, ax1 = plt.subplots(1,1,**kwargs)
    ax2 = ax1.twinx()

    ax1.plot(x, My, &#34;g&#34;, lw=1, label=&#34;Bending Moment&#34;)
    ax2.plot(x, Vz, &#34;b&#34;, lw=1, label=&#34;Shear Force&#34;)

    from DAVE.gui.helpers.align_zeros_of_yyplots import align_y0_axis

    align_y0_axis(ax1, ax2)

    ax1.set_xlabel(&#34;Position [m]&#34;)
    ax1.set_ylabel(&#34;Bending Moment [kNm]&#34;)
    ax2.set_ylabel(&#34;Shear Force [kN]&#34;)

    ax1.tick_params(axis=&#34;y&#34;, colors=&#34;g&#34;)
    ax2.tick_params(axis=&#34;y&#34;, colors=&#34;b&#34;)

    # fig.legend()  - obvious from the axis

    ext = 0.1 * (np.max(x) - np.min(x))
    xx = [np.min(x) - ext, np.max(x) + ext]
    ax1.plot(xx, [0, 0], c=[0.5, 0.5, 0.5], lw=1, linestyle=&#34;:&#34;)
    ax1.set_xlim(xx)

    return fig</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="DAVE.scene.Manager"><code class="flex name class">
<span>class <span class="ident">Manager</span></span>
<span>(</span><span>scene)</span>
</code></dt>
<dd>
<div class="desc"><p>ABSTRACT CLASS - Properties defined here are applicable to all derived classes
Master class for all nodes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Manager(Node, ABC):


    # @abstractmethod                   not used anywhere outside the manager classes, so no requirement
    # def managed_nodes(self):
    #     &#34;&#34;&#34;Returns a list of managed nodes&#34;&#34;&#34;
    #     raise Exception(&#34;derived class shall override this method&#34;)

    @abstractmethod
    def delete(self):
        &#34;&#34;&#34;Carefully remove the manager, reinstate situation as before. Do not delete the manager itself but do
        delete all the nodes it created.&#34;&#34;&#34;
        raise Exception(&#34;derived class shall override this method&#34;)

    @abstractmethod
    def creates(self, node: Node):
        &#34;&#34;&#34;Returns True if node is created by this manager&#34;&#34;&#34;

        raise Exception(&#34;derived class shall override this method&#34;)
        # hint: return node in self.managed_nodes() # would be a good option, just not good enough as default</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="DAVE.scene.GeometricContact" href="#DAVE.scene.GeometricContact">GeometricContact</a></li>
<li><a title="DAVE.scene.Shackle" href="#DAVE.scene.Shackle">Shackle</a></li>
<li><a title="DAVE.scene.Sling" href="#DAVE.scene.Sling">Sling</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.Manager.creates"><code class="name flex">
<span>def <span class="ident">creates</span></span>(<span>self, node:Â <a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if node is created by this manager</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def creates(self, node: Node):
    &#34;&#34;&#34;Returns True if node is created by this manager&#34;&#34;&#34;

    raise Exception(&#34;derived class shall override this method&#34;)
    # hint: return node in self.managed_nodes() # would be a good option, just not good enough as default</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Manager.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Carefully remove the manager, reinstate situation as before. Do not delete the manager itself but do
delete all the nodes it created.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def delete(self):
    &#34;&#34;&#34;Carefully remove the manager, reinstate situation as before. Do not delete the manager itself but do
    delete all the nodes it created.&#34;&#34;&#34;
    raise Exception(&#34;derived class shall override this method&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.Node.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.Node.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.Node.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.Node.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.Node.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.Node"><code class="flex name class">
<span>class <span class="ident">Node</span></span>
<span>(</span><span>scene)</span>
</code></dt>
<dd>
<div class="desc"><p>ABSTRACT CLASS - Properties defined here are applicable to all derived classes
Master class for all nodes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Node(ABC):
    &#34;&#34;&#34;ABSTRACT CLASS - Properties defined here are applicable to all derived classes
    Master class for all nodes&#34;&#34;&#34;

    def __init__(self, scene):
        self._scene: Scene = scene
        &#34;&#34;&#34;reference to the scene that the node lives is&#34;&#34;&#34;

        self._name: str = &#34;A manager without a name&#34;
        &#34;&#34;&#34;Unique name of the node&#34;&#34;&#34;

        self._manager: Node or None = None
        &#34;&#34;&#34;Reference to a node that controls this node&#34;&#34;&#34;

        self.observers = list()
        &#34;&#34;&#34;List of nodes observing this node.&#34;&#34;&#34;

        self._visible: bool = True
        &#34;&#34;&#34;Determines if the visual for of this node (if any) should be visible&#34;&#34;&#34;

    def __repr__(self):
        return f&#34;{self.name} &lt;{self.__class__.__name__}&gt;&#34;

    def __str__(self):
        return self.name

    @property
    def class_name(self):
        return self.__class__.__name__

    @abstractmethod
    def depends_on(self) -&gt; list:
        &#34;&#34;&#34;Returns a list of nodes that need to be available present for this node to exist&#34;&#34;&#34;
        raise ValueError(
            f&#34;Derived class should implement this method, but {type(self)} does not&#34;
        )

    def give_python_code(self):
        &#34;&#34;&#34;Returns the python code that can be executed to re-create this node&#34;&#34;&#34;
        return &#34;# No python code generated for element {}&#34;.format(self.name)

    @property
    def visible(self):
        if self.manager:
            return self.manager.visible
        return self._visible

    @visible.setter
    @node_setter_manageable
    @node_setter_observable
    def visible(self, value):
        self._visible = value

    @property
    def manager(self):
        return self._manager

    @manager.setter
    @node_setter_manageable
    @node_setter_observable
    def manager(self, value):

        self._manager = value
        pass

    def _verify_change_allowed(self):
        &#34;&#34;&#34;Changing the state of a node is only allowed if either:
        1. the node is not manages (node._manager is None)
        2. the manager of the node is identical to scene.current_manager
        &#34;&#34;&#34;
        if self._scene._godmode:
            return True

        if self._manager is not None:
            if self._manager != self._scene.current_manager:
                if self._scene.current_manager is None:
                    name = None
                else:
                    name = self._scene.current_manager.name
                raise Exception(
                    f&#34;Node {self.name} may not be changed because it is managed by {self._manager.name} and the current manager of the scene is {name}&#34;
                )

    @property
    def name(self):
        &#34;&#34;&#34;Name of the node (str), must be unique&#34;&#34;&#34;
        return self._name

    @name.setter
    @node_setter_manageable
    @node_setter_observable
    def name(self, name):

        self._name = name

    def _delete_vfc(self):
        &#34;&#34;&#34;Removes any internally created core objects&#34;&#34;&#34;
        pass

    def update(self):
        &#34;&#34;&#34;Performs internal updates relevant for physics. Called before solving statics or getting results such as
        forces or inertia&#34;&#34;&#34;
        pass

    def _notify_observers(self):
        for obs in self.observers:
            obs.on_observed_node_changed(self)

    def on_observed_node_changed(self, changed_node):
        &#34;&#34;&#34; &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="DAVE.scene.BallastSystem" href="#DAVE.scene.BallastSystem">BallastSystem</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Manager" href="#DAVE.scene.Manager">Manager</a></li>
<li><a title="DAVE.scene.TriMeshSource" href="#DAVE.scene.TriMeshSource">TriMeshSource</a></li>
<li><a title="DAVE.scene.Visual" href="#DAVE.scene.Visual">Visual</a></li>
<li><a title="DAVE.scene.WaveInteraction1" href="#DAVE.scene.WaveInteraction1">WaveInteraction1</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Node.class_name"><code class="name">var <span class="ident">class_name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def class_name(self):
    return self.__class__.__name__</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Node.manager"><code class="name">var <span class="ident">manager</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def manager(self):
    return self._manager</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Node.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Name of the node (str), must be unique</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;Name of the node (str), must be unique&#34;&#34;&#34;
    return self._name</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Node.observers"><code class="name">var <span class="ident">observers</span></code></dt>
<dd>
<div class="desc"><p>List of nodes observing this node.</p></div>
</dd>
<dt id="DAVE.scene.Node.visible"><code class="name">var <span class="ident">visible</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def visible(self):
    if self.manager:
        return self.manager.visible
    return self._visible</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.Node.depends_on"><code class="name flex">
<span>def <span class="ident">depends_on</span></span>(<span>self) ->Â list</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of nodes that need to be available present for this node to exist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def depends_on(self) -&gt; list:
    &#34;&#34;&#34;Returns a list of nodes that need to be available present for this node to exist&#34;&#34;&#34;
    raise ValueError(
        f&#34;Derived class should implement this method, but {type(self)} does not&#34;
    )</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Node.give_python_code"><code class="name flex">
<span>def <span class="ident">give_python_code</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the python code that can be executed to re-create this node</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def give_python_code(self):
    &#34;&#34;&#34;Returns the python code that can be executed to re-create this node&#34;&#34;&#34;
    return &#34;# No python code generated for element {}&#34;.format(self.name)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Node.on_observed_node_changed"><code class="name flex">
<span>def <span class="ident">on_observed_node_changed</span></span>(<span>self, changed_node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_observed_node_changed(self, changed_node):
    &#34;&#34;&#34; &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Node.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs internal updates relevant for physics. Called before solving statics or getting results such as
forces or inertia</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#34;&#34;&#34;Performs internal updates relevant for physics. Called before solving statics or getting results such as
    forces or inertia&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="DAVE.scene.NodeWithParent"><code class="flex name class">
<span>class <span class="ident">NodeWithParent</span></span>
<span>(</span><span>scene, vfNode)</span>
</code></dt>
<dd>
<div class="desc"><p>NodeWithParent</p>
<p>Do not use this class directly.
This is a base-class for all nodes that have a "parent" property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeWithParent(CoreConnectedNode):
    &#34;&#34;&#34;
    NodeWithParent

    Do not use this class directly.
    This is a base-class for all nodes that have a &#34;parent&#34; property.
    &#34;&#34;&#34;

    def __init__(self, scene, vfNode):
        super().__init__(scene, vfNode)
        self._parent = None
        self._None_parent_acceptable = False
        self._parent_for_code_export = True
        &#34;&#34;&#34;True : use parent, 
        None : use None, 
        Node : use that Node
        Used to prevent circular references, see groups section in documentation&#34;&#34;&#34;

    def depends_on(self):
        if self.parent_for_export is not None:
            return [self.parent_for_export]
        else:
            return []

    @property
    def parent_for_export(self):
        if self._parent_for_code_export == True:
            return self._parent
        else:
            return self._parent_for_code_export

    @property
    def parent(self):
        &#34;&#34;&#34;Determines the parent of the node. Should be an axis or None&#34;&#34;&#34;
        if self._vfNode.parent is None:
            return None
        else:
            return self._parent
            # return Axis(self._scene, self._vfNode.parent)

    @parent.setter
    @node_setter_manageable
    @node_setter_observable
    def parent(self, var):
        &#34;&#34;&#34;Assigns a new parent. Keeps the local position and rotations the same

        See also: change_parent_to
        &#34;&#34;&#34;

        if var is None:

            if not self._None_parent_acceptable:
                raise ValueError(
                    &#34;None is not an acceptable parent for {} of {}&#34;.format(
                        self.name, type(self)
                    )
                )

            self._parent = None
            self._vfNode.parent = None
        else:

            var = self._scene._node_from_node_or_str(var)

            if isinstance(var, Axis) or isinstance(var, GeometricContact):
                self._parent = var
                self._vfNode.parent = var._vfNode
            elif isinstance(var, Point):
                self._parent = var
                self._vfNode.parent = var._vfNode
            else:
                raise Exception(
                    &#34;Parent can only be set to an instance of Axis or Poi, not to a {}&#34;.format(
                        type(var)
                    )
                )

    def change_parent_to(self, new_parent):
        &#34;&#34;&#34;Assigns a new parent to the node but keeps the global position and rotation the same.

        See also: .parent (property)

        Args:
            new_parent: new parent node

        &#34;&#34;&#34;

        if isinstance(self, Point) and isinstance(new_parent, Point):
            raise TypeError(&#34;Points can not be placed on points&#34;)

        try:
            self.rotation
            has_rotation = True
        except:
            has_rotation = False

        try:
            self.position
            has_position = True
        except:
            has_position = False

        # it is possible that this function is called on an object without position/rotation
        # in that case just fall-back to a change of parent
        if not has_position and not has_rotation:
            self.parent = new_parent
            return

        # check new_parent
        if new_parent is not None:

            if not isinstance(new_parent, Axis):
                if not has_rotation:
                    if not isinstance(new_parent, Point):
                        raise TypeError(
                            &#34;Only Poi-type nodes (or derived types) can be used as parent. You tried to use a {} as parent&#34;.format(
                                type(new_parent)
                            )
                        )
                else:
                    raise TypeError(
                        &#34;Only None or Axis-type nodes (or derived types)  can be used as parent. You tried to use a {} as parent&#34;.format(
                            type(new_parent)
                        )
                    )

        glob_pos = self.global_position

        if has_rotation:
            glob_rot = self.global_rotation

        self.parent = new_parent

        if new_parent is None:
            self.position = glob_pos
            if has_rotation:
                self.rotation = glob_rot

        else:
            self.position = new_parent.to_loc_position(glob_pos)
            if has_rotation:
                self.rotation = new_parent.to_loc_direction(glob_rot)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="DAVE.scene.Buoyancy" href="#DAVE.scene.Buoyancy">Buoyancy</a></li>
<li><a title="DAVE.scene.Circle" href="#DAVE.scene.Circle">Circle</a></li>
<li><a title="DAVE.scene.ContactBall" href="#DAVE.scene.ContactBall">ContactBall</a></li>
<li><a title="DAVE.scene.ContactMesh" href="#DAVE.scene.ContactMesh">ContactMesh</a></li>
<li><a title="DAVE.scene.Force" href="#DAVE.scene.Force">Force</a></li>
<li><a title="DAVE.scene.HydSpring" href="#DAVE.scene.HydSpring">HydSpring</a></li>
<li><a title="DAVE.scene.NodeWithParentAndFootprint" href="#DAVE.scene.NodeWithParentAndFootprint">NodeWithParentAndFootprint</a></li>
<li><a title="DAVE.scene.SPMT" href="#DAVE.scene.SPMT">SPMT</a></li>
<li><a title="DAVE.scene.Tank" href="#DAVE.scene.Tank">Tank</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.NodeWithParent.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"><p>Determines the parent of the node. Should be an axis or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self):
    &#34;&#34;&#34;Determines the parent of the node. Should be an axis or None&#34;&#34;&#34;
    if self._vfNode.parent is None:
        return None
    else:
        return self._parent
        # return Axis(self._scene, self._vfNode.parent)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.NodeWithParent.parent_for_export"><code class="name">var <span class="ident">parent_for_export</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent_for_export(self):
    if self._parent_for_code_export == True:
        return self._parent
    else:
        return self._parent_for_code_export</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.NodeWithParent.change_parent_to"><code class="name flex">
<span>def <span class="ident">change_parent_to</span></span>(<span>self, new_parent)</span>
</code></dt>
<dd>
<div class="desc"><p>Assigns a new parent to the node but keeps the global position and rotation the same.</p>
<p>See also: .parent (property)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_parent</code></strong></dt>
<dd>new parent node</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_parent_to(self, new_parent):
    &#34;&#34;&#34;Assigns a new parent to the node but keeps the global position and rotation the same.

    See also: .parent (property)

    Args:
        new_parent: new parent node

    &#34;&#34;&#34;

    if isinstance(self, Point) and isinstance(new_parent, Point):
        raise TypeError(&#34;Points can not be placed on points&#34;)

    try:
        self.rotation
        has_rotation = True
    except:
        has_rotation = False

    try:
        self.position
        has_position = True
    except:
        has_position = False

    # it is possible that this function is called on an object without position/rotation
    # in that case just fall-back to a change of parent
    if not has_position and not has_rotation:
        self.parent = new_parent
        return

    # check new_parent
    if new_parent is not None:

        if not isinstance(new_parent, Axis):
            if not has_rotation:
                if not isinstance(new_parent, Point):
                    raise TypeError(
                        &#34;Only Poi-type nodes (or derived types) can be used as parent. You tried to use a {} as parent&#34;.format(
                            type(new_parent)
                        )
                    )
            else:
                raise TypeError(
                    &#34;Only None or Axis-type nodes (or derived types)  can be used as parent. You tried to use a {} as parent&#34;.format(
                        type(new_parent)
                    )
                )

    glob_pos = self.global_position

    if has_rotation:
        glob_rot = self.global_rotation

    self.parent = new_parent

    if new_parent is None:
        self.position = glob_pos
        if has_rotation:
            self.rotation = glob_rot

    else:
        self.position = new_parent.to_loc_position(glob_pos)
        if has_rotation:
            self.rotation = new_parent.to_loc_direction(glob_rot)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.CoreConnectedNode.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.CoreConnectedNode.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.NodeWithParentAndFootprint"><code class="flex name class">
<span>class <span class="ident">NodeWithParentAndFootprint</span></span>
<span>(</span><span>scene, vfNode)</span>
</code></dt>
<dd>
<div class="desc"><p>NodeWithParentAndFootprint</p>
<p>Do not use this class directly.
This is a base-class for all nodes that have a "footprint" property as well as a parent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeWithParentAndFootprint(NodeWithParent):
    &#34;&#34;&#34;
    NodeWithParentAndFootprint

    Do not use this class directly.
    This is a base-class for all nodes that have a &#34;footprint&#34; property as well as a parent
    &#34;&#34;&#34;

    def __init__(self, scene, vfNode):
        super().__init__(scene, vfNode)

    @property
    def footprint(self):
        &#34;&#34;&#34;tuple of tuples ((x1,y1,z1), (x2,y2,z2), .... (xn,yn,zn)&#34;&#34;&#34;
        r = []
        for i in range(self._vfNode.nFootprintVertices):
            r.append(self._vfNode.footprintVertexGet(i))
        return tuple(r)

    @footprint.setter
    def footprint(self, value):
        &#34;&#34;&#34;Sets the footprint vertices. Supply as an iterable with each element containing three floats&#34;&#34;&#34;
        for t in value:
            assert3f(t, &#34;Each entry of value assigned to footprints &#34;)

        self._vfNode.footprintVertexClearAll()
        for t in value:
            self._vfNode.footprintVertexAdd(*t)

    def add_footprint_python_code(self):
        if self.footprint:
            return f&#34;\ns[&#39;{self.name}&#39;].footprint = {str(self.footprint)}&#34;
        else:
            return &#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="DAVE.scene.Axis" href="#DAVE.scene.Axis">Axis</a></li>
<li><a title="DAVE.scene.Point" href="#DAVE.scene.Point">Point</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.NodeWithParentAndFootprint.footprint"><code class="name">var <span class="ident">footprint</span></code></dt>
<dd>
<div class="desc"><p>tuple of tuples ((x1,y1,z1), (x2,y2,z2), .... (xn,yn,zn)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def footprint(self):
    &#34;&#34;&#34;tuple of tuples ((x1,y1,z1), (x2,y2,z2), .... (xn,yn,zn)&#34;&#34;&#34;
    r = []
    for i in range(self._vfNode.nFootprintVertices):
        r.append(self._vfNode.footprintVertexGet(i))
    return tuple(r)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.NodeWithParentAndFootprint.add_footprint_python_code"><code class="name flex">
<span>def <span class="ident">add_footprint_python_code</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_footprint_python_code(self):
    if self.footprint:
        return f&#34;\ns[&#39;{self.name}&#39;].footprint = {str(self.footprint)}&#34;
    else:
        return &#34;&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.NodeWithParent.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.parent" href="#DAVE.scene.NodeWithParent.parent">parent</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.Point"><code class="flex name class">
<span>class <span class="ident">Point</span></span>
<span>(</span><span>scene, vfPoi)</span>
</code></dt>
<dd>
<div class="desc"><p>A location on an axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Point(NodeWithParentAndFootprint):
    &#34;&#34;&#34;A location on an axis&#34;&#34;&#34;

    # init parent and name are fully derived from NodeWithParent
    # _vfNode is a poi
    def __init__(self, scene, vfPoi):
        super().__init__(scene, vfPoi)
        self._None_parent_acceptable = True

    def on_observed_node_changed(self, changed_node):
        print(changed_node.name + &#34; has changed&#34;)

    @property
    def x(self):
        &#34;&#34;&#34;x component of local position [m] (parent axis)&#34;&#34;&#34;
        return self.position[0]

    @property
    def y(self):
        &#34;&#34;&#34;y component of local position [m] (parent axis)&#34;&#34;&#34;
        return self.position[1]

    @property
    def z(self):
        &#34;&#34;&#34;z component of local position [m] (parent axis)&#34;&#34;&#34;
        return self.position[2]

    @x.setter
    @node_setter_manageable
    @node_setter_observable
    def x(self, var):

        a = self.position
        self.position = (var, a[1], a[2])

    @y.setter
    @node_setter_manageable
    @node_setter_observable
    def y(self, var):

        a = self.position
        self.position = (a[0], var, a[2])

    @z.setter
    @node_setter_manageable
    @node_setter_observable
    @node_setter_manageable
    def z(self, var):

        &#34;&#34;&#34;z component of local position&#34;&#34;&#34;
        a = self.position
        self.position = (a[0], a[1], var)

    @property
    def position(self):
        &#34;&#34;&#34;Local position [m,m,m] (parent axis)&#34;&#34;&#34;
        return self._vfNode.position

    @position.setter
    @node_setter_manageable
    @node_setter_observable
    def position(self, new_position):

        assert3f(new_position)
        self._vfNode.position = new_position

    @property
    def applied_force_and_moment_global(self):
        &#34;&#34;&#34;Applied force and moment on this point [kN, kN, kN, kNm, kNm, kNm] (Global axis)&#34;&#34;&#34;
        return self._vfNode.applied_force

    @property
    def gx(self):
        &#34;&#34;&#34;x component of position [m] (global axis)&#34;&#34;&#34;
        return self.global_position[0]

    @property
    def gy(self):
        &#34;&#34;&#34;y component of position [m] (global axis)&#34;&#34;&#34;
        return self.global_position[1]

    @property
    def gz(self):
        &#34;&#34;&#34;z component of position [m] (global axis)&#34;&#34;&#34;
        return self.global_position[2]

    @gx.setter
    @node_setter_manageable
    @node_setter_observable
    def gx(self, var):

        a = self.global_position
        self.global_position = (var, a[1], a[2])

    @gy.setter
    @node_setter_manageable
    @node_setter_observable
    def gy(self, var):

        a = self.global_position
        self.global_position = (a[0], var, a[2])

    @gz.setter
    @node_setter_manageable
    @node_setter_observable
    def gz(self, var):

        a = self.global_position
        self.global_position = (a[0], a[1], var)

    @property
    def global_position(self):
        &#34;&#34;&#34;Global position [m,m,m] (global axis)&#34;&#34;&#34;
        return self._vfNode.global_position

    @global_position.setter
    @node_setter_manageable
    @node_setter_observable
    def global_position(self, val):

        assert3f(val, &#34;Global Position&#34;)
        if self.parent:
            self.position = self.parent.to_loc_position(val)
        else:
            self.position = val

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\ns.new_point(name=&#39;{}&#39;,&#34;.format(self.name)
        if self.parent_for_export:
            code += &#34;\n          parent=&#39;{}&#39;,&#34;.format(self.parent_for_export.name)

        # position

        code += &#34;\n          position=({},&#34;.format(self.position[0])
        code += &#34;\n                    {},&#34;.format(self.position[1])
        code += &#34;\n                    {}))&#34;.format(self.position[2])

        code += self.add_footprint_python_code()

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.NodeWithParentAndFootprint" href="#DAVE.scene.NodeWithParentAndFootprint">NodeWithParentAndFootprint</a></li>
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Point.applied_force_and_moment_global"><code class="name">var <span class="ident">applied_force_and_moment_global</span></code></dt>
<dd>
<div class="desc"><p>Applied force and moment on this point [kN, kN, kN, kNm, kNm, kNm] (Global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def applied_force_and_moment_global(self):
    &#34;&#34;&#34;Applied force and moment on this point [kN, kN, kN, kNm, kNm, kNm] (Global axis)&#34;&#34;&#34;
    return self._vfNode.applied_force</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Point.global_position"><code class="name">var <span class="ident">global_position</span></code></dt>
<dd>
<div class="desc"><p>Global position [m,m,m] (global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def global_position(self):
    &#34;&#34;&#34;Global position [m,m,m] (global axis)&#34;&#34;&#34;
    return self._vfNode.global_position</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Point.gx"><code class="name">var <span class="ident">gx</span></code></dt>
<dd>
<div class="desc"><p>x component of position [m] (global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gx(self):
    &#34;&#34;&#34;x component of position [m] (global axis)&#34;&#34;&#34;
    return self.global_position[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Point.gy"><code class="name">var <span class="ident">gy</span></code></dt>
<dd>
<div class="desc"><p>y component of position [m] (global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gy(self):
    &#34;&#34;&#34;y component of position [m] (global axis)&#34;&#34;&#34;
    return self.global_position[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Point.gz"><code class="name">var <span class="ident">gz</span></code></dt>
<dd>
<div class="desc"><p>z component of position [m] (global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gz(self):
    &#34;&#34;&#34;z component of position [m] (global axis)&#34;&#34;&#34;
    return self.global_position[2]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Point.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"><p>Local position [m,m,m] (parent axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def position(self):
    &#34;&#34;&#34;Local position [m,m,m] (parent axis)&#34;&#34;&#34;
    return self._vfNode.position</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Point.x"><code class="name">var <span class="ident">x</span></code></dt>
<dd>
<div class="desc"><p>x component of local position [m] (parent axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x(self):
    &#34;&#34;&#34;x component of local position [m] (parent axis)&#34;&#34;&#34;
    return self.position[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Point.y"><code class="name">var <span class="ident">y</span></code></dt>
<dd>
<div class="desc"><p>y component of local position [m] (parent axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def y(self):
    &#34;&#34;&#34;y component of local position [m] (parent axis)&#34;&#34;&#34;
    return self.position[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Point.z"><code class="name">var <span class="ident">z</span></code></dt>
<dd>
<div class="desc"><p>z component of local position [m] (parent axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z(self):
    &#34;&#34;&#34;z component of local position [m] (parent axis)&#34;&#34;&#34;
    return self.position[2]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.Point.on_observed_node_changed"><code class="name flex">
<span>def <span class="ident">on_observed_node_changed</span></span>(<span>self, changed_node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_observed_node_changed(self, changed_node):
    print(changed_node.name + &#34; has changed&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.NodeWithParentAndFootprint" href="#DAVE.scene.NodeWithParentAndFootprint">NodeWithParentAndFootprint</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.NodeWithParentAndFootprint.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParentAndFootprint.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParentAndFootprint.footprint" href="#DAVE.scene.NodeWithParentAndFootprint.footprint">footprint</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParentAndFootprint.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParentAndFootprint.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParentAndFootprint.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParentAndFootprint.parent" href="#DAVE.scene.NodeWithParent.parent">parent</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParentAndFootprint.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.RigidBody"><code class="flex name class">
<span>class <span class="ident">RigidBody</span></span>
<span>(</span><span>scene, axis, poi, force)</span>
</code></dt>
<dd>
<div class="desc"><p>A Rigid body, internally composed of an axis, a point (cog) and a force (gravity)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RigidBody(Axis):
    &#34;&#34;&#34;A Rigid body, internally composed of an axis, a point (cog) and a force (gravity)&#34;&#34;&#34;

    def __init__(self, scene, axis, poi, force):
        super().__init__(scene, axis)

        # The axis is the Node
        # poi and force are added separately

        self._vfPoi = poi
        self._vfForce = force

    # override the following properties
    # - name : sets the names of poi and force as well

    def _delete_vfc(self):
        super()._delete_vfc()
        self._scene._vfc.delete(self._vfPoi.name)
        self._scene._vfc.delete(self._vfForce.name)

    @property  # can not define a setter without a getter..?
    def name(self):
        return super().name

    @name.setter
    @node_setter_manageable
    @node_setter_observable
    def name(self, newname):
        &#34;&#34;&#34;Name of the node (str), must be unique&#34;&#34;&#34;

        # super().name = newname
        super(RigidBody, self.__class__).name.fset(self, newname)
        self._vfPoi.name = newname + vfc.VF_NAME_SPLIT + &#34;cog&#34;
        self._vfForce.name = newname + vfc.VF_NAME_SPLIT + &#34;gravity&#34;

    @property
    def footprint(self):
        return super().footprint

    @footprint.setter
    def footprint(self, value):
        &#34;&#34;&#34;Sets the footprint vertices. Supply as an iterable with each element containing three floats&#34;&#34;&#34;
        super(RigidBody, type(self)).footprint.fset(
            self, value
        )  # https://bugs.python.org/issue14965

        # assign the footprint to the CoG as well,
        # but subtract the cog position as
        self._sync_selfweight_footprint()

    def _sync_selfweight_footprint(self):
        &#34;&#34;&#34;The footprint of the CoG is defined relative to the CoG, so its needs to be updated
        whenever the CoG or the footprint changes&#34;&#34;&#34;

        fp = self.footprint

        self._vfPoi.footprintVertexClearAll()
        for t in fp:
            pos = np.array(t, dtype=float)
            relpos = pos - self.cog
            self._vfPoi.footprintVertexAdd(*relpos)

    @property
    def cogx(self):
        &#34;&#34;&#34;x-component of cog position [m] (local axis)&#34;&#34;&#34;
        return self.cog[0]

    @property
    def cogy(self):
        &#34;&#34;&#34;y-component of cog position [m] (local axis)&#34;&#34;&#34;
        return self.cog[1]

    @property
    def cogz(self):
        &#34;&#34;&#34;z-component of cog position [m] (local axis)&#34;&#34;&#34;
        return self.cog[2]

    @property
    def cog(self):
        &#34;&#34;&#34;Center of Gravity position [m,m,m] (local axis)&#34;&#34;&#34;
        return self._vfPoi.position

    @cogx.setter
    @node_setter_manageable
    @node_setter_observable
    def cogx(self, var):

        a = self.cog
        self.cog = (var, a[1], a[2])

    @cogy.setter
    @node_setter_manageable
    @node_setter_observable
    def cogy(self, var):

        a = self.cog
        self.cog = (a[0], var, a[2])

    @cogz.setter
    @node_setter_manageable
    @node_setter_observable
    def cogz(self, var):

        a = self.cog
        self.cog = (a[0], a[1], var)

    @cog.setter
    @node_setter_manageable
    @node_setter_observable
    def cog(self, newcog):

        assert3f(newcog)
        self._vfPoi.position = newcog
        self.inertia_position = self.cog
        self._sync_selfweight_footprint()

    @property
    def mass(self):
        &#34;&#34;&#34;Static mass of the body [mT]

        See Also: inertia
        &#34;&#34;&#34;
        return self._vfForce.force[2] / -vfc.G

    @mass.setter
    @node_setter_manageable
    @node_setter_observable
    def mass(self, newmass):

        assert1f(newmass)
        self.inertia = newmass
        self._vfForce.force = (0, 0, -vfc.G * newmass)

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\ns.new_rigidbody(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n                mass={},&#34;.format(self.mass)
        code += &#34;\n                cog=({},&#34;.format(self.cog[0])
        code += &#34;\n                     {},&#34;.format(self.cog[1])
        code += &#34;\n                     {}),&#34;.format(self.cog[2])

        if self.parent_for_export:
            code += &#34;\n                parent=&#39;{}&#39;,&#34;.format(self.parent_for_export.name)

        # position

        if self.fixed[0]:
            code += &#34;\n                position=({},&#34;.format(self.position[0])
        else:
            code += &#34;\n                position=(solved({}),&#34;.format(self.position[0])
        if self.fixed[1]:
            code += &#34;\n                          {},&#34;.format(self.position[1])
        else:
            code += &#34;\n                          solved({}),&#34;.format(self.position[1])
        if self.fixed[2]:
            code += &#34;\n                          {}),&#34;.format(self.position[2])
        else:
            code += &#34;\n                          solved({})),&#34;.format(self.position[2])

        # rotation

        if self.fixed[3]:
            code += &#34;\n                rotation=({},&#34;.format(self.rotation[0])
        else:
            code += &#34;\n                rotation=(solved({}),&#34;.format(self.rotation[0])
        if self.fixed[4]:
            code += &#34;\n                          {},&#34;.format(self.rotation[1])
        else:
            code += &#34;\n                          solved({}),&#34;.format(self.rotation[1])
        if self.fixed[5]:
            code += &#34;\n                          {}),&#34;.format(self.rotation[2])
        else:
            code += &#34;\n                          solved({})),&#34;.format(self.rotation[2])

        if np.any(self.inertia_radii &gt; 0):
            code += &#34;\n                     inertia_radii = ({}, {}, {}),&#34;.format(
                *self.inertia_radii
            )

        code += &#34;\n                fixed =({}, {}, {}, {}, {}, {}) )&#34;.format(
            *self.fixed
        )

        code += self.add_footprint_python_code()

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.Axis" href="#DAVE.scene.Axis">Axis</a></li>
<li><a title="DAVE.scene.NodeWithParentAndFootprint" href="#DAVE.scene.NodeWithParentAndFootprint">NodeWithParentAndFootprint</a></li>
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="DAVE.scene.Shackle" href="#DAVE.scene.Shackle">Shackle</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.RigidBody.cog"><code class="name">var <span class="ident">cog</span></code></dt>
<dd>
<div class="desc"><p>Center of Gravity position [m,m,m] (local axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cog(self):
    &#34;&#34;&#34;Center of Gravity position [m,m,m] (local axis)&#34;&#34;&#34;
    return self._vfPoi.position</code></pre>
</details>
</dd>
<dt id="DAVE.scene.RigidBody.cogx"><code class="name">var <span class="ident">cogx</span></code></dt>
<dd>
<div class="desc"><p>x-component of cog position [m] (local axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cogx(self):
    &#34;&#34;&#34;x-component of cog position [m] (local axis)&#34;&#34;&#34;
    return self.cog[0]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.RigidBody.cogy"><code class="name">var <span class="ident">cogy</span></code></dt>
<dd>
<div class="desc"><p>y-component of cog position [m] (local axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cogy(self):
    &#34;&#34;&#34;y-component of cog position [m] (local axis)&#34;&#34;&#34;
    return self.cog[1]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.RigidBody.cogz"><code class="name">var <span class="ident">cogz</span></code></dt>
<dd>
<div class="desc"><p>z-component of cog position [m] (local axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cogz(self):
    &#34;&#34;&#34;z-component of cog position [m] (local axis)&#34;&#34;&#34;
    return self.cog[2]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.RigidBody.mass"><code class="name">var <span class="ident">mass</span></code></dt>
<dd>
<div class="desc"><p>Static mass of the body [mT]</p>
<p>See Also: inertia</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mass(self):
    &#34;&#34;&#34;Static mass of the body [mT]

    See Also: inertia
    &#34;&#34;&#34;
    return self._vfForce.force[2] / -vfc.G</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.Axis" href="#DAVE.scene.Axis">Axis</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.Axis.applied_force" href="#DAVE.scene.Axis.applied_force">applied_force</a></code></li>
<li><code><a title="DAVE.scene.Axis.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_force" href="#DAVE.scene.Axis.connection_force">connection_force</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_force_x" href="#DAVE.scene.Axis.connection_force_x">connection_force_x</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_force_y" href="#DAVE.scene.Axis.connection_force_y">connection_force_y</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_force_z" href="#DAVE.scene.Axis.connection_force_z">connection_force_z</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_moment_x" href="#DAVE.scene.Axis.connection_moment_x">connection_moment_x</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_moment_y" href="#DAVE.scene.Axis.connection_moment_y">connection_moment_y</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_moment_z" href="#DAVE.scene.Axis.connection_moment_z">connection_moment_z</a></code></li>
<li><code><a title="DAVE.scene.Axis.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.Axis.equilibrium_error" href="#DAVE.scene.Axis.equilibrium_error">equilibrium_error</a></code></li>
<li><code><a title="DAVE.scene.Axis.fixed" href="#DAVE.scene.Axis.fixed">fixed</a></code></li>
<li><code><a title="DAVE.scene.Axis.footprint" href="#DAVE.scene.NodeWithParentAndFootprint.footprint">footprint</a></code></li>
<li><code><a title="DAVE.scene.Axis.give_load_shear_moment_diagram" href="#DAVE.scene.Axis.give_load_shear_moment_diagram">give_load_shear_moment_diagram</a></code></li>
<li><code><a title="DAVE.scene.Axis.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.Axis.global_position" href="#DAVE.scene.Axis.global_position">global_position</a></code></li>
<li><code><a title="DAVE.scene.Axis.global_rotation" href="#DAVE.scene.Axis.global_rotation">global_rotation</a></code></li>
<li><code><a title="DAVE.scene.Axis.global_transform" href="#DAVE.scene.Axis.global_transform">global_transform</a></code></li>
<li><code><a title="DAVE.scene.Axis.grx" href="#DAVE.scene.Axis.grx">grx</a></code></li>
<li><code><a title="DAVE.scene.Axis.gry" href="#DAVE.scene.Axis.gry">gry</a></code></li>
<li><code><a title="DAVE.scene.Axis.grz" href="#DAVE.scene.Axis.grz">grz</a></code></li>
<li><code><a title="DAVE.scene.Axis.gx" href="#DAVE.scene.Axis.gx">gx</a></code></li>
<li><code><a title="DAVE.scene.Axis.gy" href="#DAVE.scene.Axis.gy">gy</a></code></li>
<li><code><a title="DAVE.scene.Axis.gz" href="#DAVE.scene.Axis.gz">gz</a></code></li>
<li><code><a title="DAVE.scene.Axis.heading" href="#DAVE.scene.Axis.heading">heading</a></code></li>
<li><code><a title="DAVE.scene.Axis.heading_compass" href="#DAVE.scene.Axis.heading_compass">heading_compass</a></code></li>
<li><code><a title="DAVE.scene.Axis.heel" href="#DAVE.scene.Axis.heel">heel</a></code></li>
<li><code><a title="DAVE.scene.Axis.inertia" href="#DAVE.scene.Axis.inertia">inertia</a></code></li>
<li><code><a title="DAVE.scene.Axis.inertia_position" href="#DAVE.scene.Axis.inertia_position">inertia_position</a></code></li>
<li><code><a title="DAVE.scene.Axis.inertia_radii" href="#DAVE.scene.Axis.inertia_radii">inertia_radii</a></code></li>
<li><code><a title="DAVE.scene.Axis.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.Axis.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.Axis.parent" href="#DAVE.scene.Axis.parent">parent</a></code></li>
<li><code><a title="DAVE.scene.Axis.position" href="#DAVE.scene.Axis.position">position</a></code></li>
<li><code><a title="DAVE.scene.Axis.rotation" href="#DAVE.scene.Axis.rotation">rotation</a></code></li>
<li><code><a title="DAVE.scene.Axis.rx" href="#DAVE.scene.Axis.rx">rx</a></code></li>
<li><code><a title="DAVE.scene.Axis.ry" href="#DAVE.scene.Axis.ry">ry</a></code></li>
<li><code><a title="DAVE.scene.Axis.rz" href="#DAVE.scene.Axis.rz">rz</a></code></li>
<li><code><a title="DAVE.scene.Axis.set_fixed" href="#DAVE.scene.Axis.set_fixed">set_fixed</a></code></li>
<li><code><a title="DAVE.scene.Axis.set_free" href="#DAVE.scene.Axis.set_free">set_free</a></code></li>
<li><code><a title="DAVE.scene.Axis.tilt_x" href="#DAVE.scene.Axis.tilt_x">tilt_x</a></code></li>
<li><code><a title="DAVE.scene.Axis.tilt_y" href="#DAVE.scene.Axis.tilt_y">tilt_y</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_glob_direction" href="#DAVE.scene.Axis.to_glob_direction">to_glob_direction</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_glob_position" href="#DAVE.scene.Axis.to_glob_position">to_glob_position</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_glob_rotation" href="#DAVE.scene.Axis.to_glob_rotation">to_glob_rotation</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_loc_direction" href="#DAVE.scene.Axis.to_loc_direction">to_loc_direction</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_loc_position" href="#DAVE.scene.Axis.to_loc_position">to_loc_position</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_loc_rotation" href="#DAVE.scene.Axis.to_loc_rotation">to_loc_rotation</a></code></li>
<li><code><a title="DAVE.scene.Axis.trim" href="#DAVE.scene.Axis.trim">trim</a></code></li>
<li><code><a title="DAVE.scene.Axis.update" href="#DAVE.scene.Node.update">update</a></code></li>
<li><code><a title="DAVE.scene.Axis.ux" href="#DAVE.scene.Axis.ux">ux</a></code></li>
<li><code><a title="DAVE.scene.Axis.uy" href="#DAVE.scene.Axis.uy">uy</a></code></li>
<li><code><a title="DAVE.scene.Axis.uz" href="#DAVE.scene.Axis.uz">uz</a></code></li>
<li><code><a title="DAVE.scene.Axis.x" href="#DAVE.scene.Axis.x">x</a></code></li>
<li><code><a title="DAVE.scene.Axis.y" href="#DAVE.scene.Axis.y">y</a></code></li>
<li><code><a title="DAVE.scene.Axis.z" href="#DAVE.scene.Axis.z">z</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.SPMT"><code class="flex name class">
<span>class <span class="ident">SPMT</span></span>
<span>(</span><span>scene, node)</span>
</code></dt>
<dd>
<div class="desc"><p>An SPMT is a Self-propelled modular transporter</p>
<p>These are platform vehicles</p>
<p>============
=======
0 0 0 0 0 0
0 0 0 0</p>
<p>A number of axles share a common suspension system.</p>
<p>The SPMT node models such a system of axles.</p>
<p>The SPMT is attached to an axis system.
The upper locations of the axles are given as an array of 3d vectors.</p>
<p>Rays are extended from these points in local -Z direction (down) until they hit a contact-shape.</p>
<p>If no contact shape is found (or not within the maximum distance per axles) then the maximum defined extension for that axle is used.</p>
<p>A shared pressure is obtained from the combination of all individual extensions.</p>
<p>Finally an equal force is applied on all the axle connection points. This force acts in local Z direction.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SPMT(NodeWithParent):
    &#34;&#34;&#34;An SPMT is a Self-propelled modular transporter

    These are platform vehicles

    ============  =======
    0 0 0 0 0 0   0 0 0 0

    A number of axles share a common suspension system.

    The SPMT node models such a system of axles.

    The SPMT is attached to an axis system.
    The upper locations of the axles are given as an array of 3d vectors.

    Rays are extended from these points in local -Z direction (down) until they hit a contact-shape.

    If no contact shape is found (or not within the maximum distance per axles) then the maximum defined extension for that axle is used.

    A shared pressure is obtained from the combination of all individual extensions.

    Finally an equal force is applied on all the axle connection points. This force acts in local Z direction.

    &#34;&#34;&#34;

    def __init__(self, scene, node):
        super().__init__(scene, node)
        self._meshes = list()

    # read-only

    @property
    def axle_force(self) -&gt; tuple:
        &#34;&#34;&#34;Returns the force on each of the axles [kN, kN, kN] (global axis)&#34;&#34;&#34;
        return self._vfNode.force

    @property
    def compression(self) -&gt; float:
        &#34;&#34;&#34;Returns the total compression of all the axles together [m]&#34;&#34;&#34;
        return self._vfNode.compression

    def get_actual_global_points(self):
        &#34;&#34;&#34;Returns a list of points: axle1, bottom wheels 1, axle2, bottom wheels 2, etc&#34;&#34;&#34;
        gp = self._vfNode.actual_global_points

        pts = []
        n2 = int(len(gp) / 2)
        for i in range(n2):
            pts.append(gp[2 * i + 1])
            pts.append(gp[2 * i])

            if i &lt; n2 - 1:
                pts.append(gp[2 * i + 2])

        return pts

    # controllable

    # name is derived
    # parent is derived

    @property
    def k(self):
        &#34;&#34;&#34;Compression stiffness of the ball in force per meter of compression [kN/m]&#34;&#34;&#34;
        return self._vfNode.k

    @k.setter
    @node_setter_manageable
    @node_setter_observable
    def k(self, value):

        assert1f_positive_or_zero(value, &#34;k&#34;)
        self._vfNode.k = value
        pass

    @property
    def nominal_length(self):
        &#34;&#34;&#34;Average Axle extension (defined point to bottom of wheel) for zero force [m]&#34;&#34;&#34;
        return self._vfNode.nominal_length

    @nominal_length.setter
    @node_setter_manageable
    @node_setter_observable
    def nominal_length(self, value):

        assert1f_positive_or_zero(value, &#34;nominal_length&#34;)
        self._vfNode.nominal_length = value
        pass

    @property
    def max_length(self):
        &#34;&#34;&#34;Maximum axle extension per axle (defined point to bottom of wheel) [m]&#34;&#34;&#34;
        return self._vfNode.max_length

    @max_length.setter
    @node_setter_manageable
    @node_setter_observable
    def max_length(self, value):

        assert1f_positive_or_zero(value, &#34;max_length&#34;)
        self._vfNode.max_length = value
        pass

    # === control meshes ====

    @property
    def meshes(self) -&gt; tuple:
        &#34;&#34;&#34;List of contact-mesh nodes.
        When getting this will yield a list of node references.
        When setting node references and node-names may be used.

        eg: ball.meshes = [mesh1, &#39;mesh2&#39;]
        &#34;&#34;&#34;
        return tuple(self._meshes)

    @meshes.setter
    @node_setter_manageable
    @node_setter_observable
    def meshes(self, value):

        meshes = []

        for m in value:
            cm = self._scene._node_from_node_or_str(m)

            if not isinstance(cm, ContactMesh):
                raise ValueError(
                    f&#34;Only ContactMesh nodes can be used as mesh, but {cm.name} is a {type(cm)}&#34;
                )
            if cm in meshes:
                raise ValueError(f&#34;Can not add {cm.name} twice&#34;)

            meshes.append(cm)

        # copy to meshes
        self._meshes.clear()
        self._vfNode.clear_contact_meshes()
        for mesh in meshes:
            self._meshes.append(mesh)
            self._vfNode.add_contact_mesh(mesh._vfNode)

    @property
    def meshes_names(self) -&gt; list:
        &#34;&#34;&#34;List with the names of the meshes&#34;&#34;&#34;
        return [m.name for m in self._meshes]

    # === control axles ====

    def make_grid(self, nx=3, ny=1, dx=1.4, dy=1.45):
        offx = nx * dx / 2
        offy = ny * dy / 2
        self._vfNode.clear_axles()

        for ix in range(nx):
            for iy in range(ny):
                self._vfNode.add_axle(ix * dx - offx, iy * dy - offy, 0)

    @property
    def axles(self):
        &#34;&#34;&#34;Axles is a list axle positions. Each entry is a (x,y,z) entry which determines the location of the axle on
        SPMT. This is relative to the parent of the SPMT.

        Example:
            [(-10,0,0),(-5,0,0),(0,0,0)] for three axles
        &#34;&#34;&#34;
        return self._vfNode.get_axles()

    @axles.setter
    @node_setter_manageable
    @node_setter_observable
    def axles(self, value):
        self._vfNode.clear_axles()
        for v in value:
            assert3f(v, &#34;Each entry should contain three floating point numbers&#34;)
            self._vfNode.add_axle(*v)

    # actions

    def update(self):
        &#34;&#34;&#34;Updates the contact-points and applies forces on mesh and point&#34;&#34;&#34;
        self._vfNode.update()

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        code += &#34;\ns.new_spmt(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n                  parent=&#39;{}&#39;,&#34;.format(self.parent_for_export.name)
        code += &#34;\n                  maximal_length={},&#34;.format(self.max_length)
        code += &#34;\n                  nominal_length={},&#34;.format(self.nominal_length)
        code += &#34;\n                  k={},&#34;.format(self.k)
        code += &#34;\n                  meshes = [ &#34;

        for m in self._meshes:
            code += &#39;&#34;&#39; + m.name + &#39;&#34;,&#39;
        code = code[:-1] + &#34;],&#34;

        code += &#34;\n                  axles = [ &#34;

        for p in self.axles:
            code += f&#34;({p[0]}, {p[1]}, {p[2]}),&#34;

        code = code[:-1] + &#34;])&#34;

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.SPMT.axle_force"><code class="name">var <span class="ident">axle_force</span> :Â tuple</code></dt>
<dd>
<div class="desc"><p>Returns the force on each of the axles [kN, kN, kN] (global axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def axle_force(self) -&gt; tuple:
    &#34;&#34;&#34;Returns the force on each of the axles [kN, kN, kN] (global axis)&#34;&#34;&#34;
    return self._vfNode.force</code></pre>
</details>
</dd>
<dt id="DAVE.scene.SPMT.axles"><code class="name">var <span class="ident">axles</span></code></dt>
<dd>
<div class="desc"><p>Axles is a list axle positions. Each entry is a (x,y,z) entry which determines the location of the axle on
SPMT. This is relative to the parent of the SPMT.</p>
<h2 id="example">Example</h2>
<p>[(-10,0,0),(-5,0,0),(0,0,0)] for three axles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def axles(self):
    &#34;&#34;&#34;Axles is a list axle positions. Each entry is a (x,y,z) entry which determines the location of the axle on
    SPMT. This is relative to the parent of the SPMT.

    Example:
        [(-10,0,0),(-5,0,0),(0,0,0)] for three axles
    &#34;&#34;&#34;
    return self._vfNode.get_axles()</code></pre>
</details>
</dd>
<dt id="DAVE.scene.SPMT.compression"><code class="name">var <span class="ident">compression</span> :Â float</code></dt>
<dd>
<div class="desc"><p>Returns the total compression of all the axles together [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def compression(self) -&gt; float:
    &#34;&#34;&#34;Returns the total compression of all the axles together [m]&#34;&#34;&#34;
    return self._vfNode.compression</code></pre>
</details>
</dd>
<dt id="DAVE.scene.SPMT.k"><code class="name">var <span class="ident">k</span></code></dt>
<dd>
<div class="desc"><p>Compression stiffness of the ball in force per meter of compression [kN/m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def k(self):
    &#34;&#34;&#34;Compression stiffness of the ball in force per meter of compression [kN/m]&#34;&#34;&#34;
    return self._vfNode.k</code></pre>
</details>
</dd>
<dt id="DAVE.scene.SPMT.max_length"><code class="name">var <span class="ident">max_length</span></code></dt>
<dd>
<div class="desc"><p>Maximum axle extension per axle (defined point to bottom of wheel) [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_length(self):
    &#34;&#34;&#34;Maximum axle extension per axle (defined point to bottom of wheel) [m]&#34;&#34;&#34;
    return self._vfNode.max_length</code></pre>
</details>
</dd>
<dt id="DAVE.scene.SPMT.meshes"><code class="name">var <span class="ident">meshes</span> :Â tuple</code></dt>
<dd>
<div class="desc"><p>List of contact-mesh nodes.
When getting this will yield a list of node references.
When setting node references and node-names may be used.</p>
<p>eg: ball.meshes = [mesh1, 'mesh2']</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def meshes(self) -&gt; tuple:
    &#34;&#34;&#34;List of contact-mesh nodes.
    When getting this will yield a list of node references.
    When setting node references and node-names may be used.

    eg: ball.meshes = [mesh1, &#39;mesh2&#39;]
    &#34;&#34;&#34;
    return tuple(self._meshes)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.SPMT.meshes_names"><code class="name">var <span class="ident">meshes_names</span> :Â list</code></dt>
<dd>
<div class="desc"><p>List with the names of the meshes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def meshes_names(self) -&gt; list:
    &#34;&#34;&#34;List with the names of the meshes&#34;&#34;&#34;
    return [m.name for m in self._meshes]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.SPMT.nominal_length"><code class="name">var <span class="ident">nominal_length</span></code></dt>
<dd>
<div class="desc"><p>Average Axle extension (defined point to bottom of wheel) for zero force [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nominal_length(self):
    &#34;&#34;&#34;Average Axle extension (defined point to bottom of wheel) for zero force [m]&#34;&#34;&#34;
    return self._vfNode.nominal_length</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.SPMT.get_actual_global_points"><code class="name flex">
<span>def <span class="ident">get_actual_global_points</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of points: axle1, bottom wheels 1, axle2, bottom wheels 2, etc</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_actual_global_points(self):
    &#34;&#34;&#34;Returns a list of points: axle1, bottom wheels 1, axle2, bottom wheels 2, etc&#34;&#34;&#34;
    gp = self._vfNode.actual_global_points

    pts = []
    n2 = int(len(gp) / 2)
    for i in range(n2):
        pts.append(gp[2 * i + 1])
        pts.append(gp[2 * i])

        if i &lt; n2 - 1:
            pts.append(gp[2 * i + 2])

    return pts</code></pre>
</details>
</dd>
<dt id="DAVE.scene.SPMT.make_grid"><code class="name flex">
<span>def <span class="ident">make_grid</span></span>(<span>self, nx=3, ny=1, dx=1.4, dy=1.45)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_grid(self, nx=3, ny=1, dx=1.4, dy=1.45):
    offx = nx * dx / 2
    offy = ny * dy / 2
    self._vfNode.clear_axles()

    for ix in range(nx):
        for iy in range(ny):
            self._vfNode.add_axle(ix * dx - offx, iy * dy - offy, 0)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.SPMT.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the contact-points and applies forces on mesh and point</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#34;&#34;&#34;Updates the contact-points and applies forces on mesh and point&#34;&#34;&#34;
    self._vfNode.update()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.NodeWithParent.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.parent" href="#DAVE.scene.NodeWithParent.parent">parent</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.Scene"><code class="flex name class">
<span>class <span class="ident">Scene</span></span>
<span>(</span><span>filename=None, copy_from=None, code=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Scene is the main component of DAVE.</p>
<p>It provides a world to place nodes (elements) in.
It interfaces with the equilibrium core for all calculations.</p>
<p>By convention a Scene element is created with the name s, but create as many scenes as you want.</p>
<h2 id="examples">Examples</h2>
<p>s = Scene()
s.new_axis('my_axis', position = (0,0,1))</p>
<p>a = Scene() # another world
a.new_point('a point')</p>
<p>Creates a new Scene</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>(str or Path) Insert contents from this file into the newly created scene</dd>
<dt><strong><code>copy_from</code></strong></dt>
<dd>(Scene) Copy nodes from this other scene into the newly created scene</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Scene:
    &#34;&#34;&#34;
    A Scene is the main component of DAVE.

    It provides a world to place nodes (elements) in.
    It interfaces with the equilibrium core for all calculations.

    By convention a Scene element is created with the name s, but create as many scenes as you want.

    Examples:

        s = Scene()
        s.new_axis(&#39;my_axis&#39;, position = (0,0,1))

        a = Scene() # another world
        a.new_point(&#39;a point&#39;)


    &#34;&#34;&#34;

    def __init__(self, filename=None, copy_from=None, code=None):
        &#34;&#34;&#34;Creates a new Scene

        Args:
            filename: (str or Path) Insert contents from this file into the newly created scene
            copy_from:  (Scene) Copy nodes from this other scene into the newly created scene
        &#34;&#34;&#34;

        count = 0
        if filename:
            count += 1
        if copy_from:
            count += 1
        if code:
            count += 1
        if count &gt; 1:
            raise ValueError(
                &#34;Only one of the named arguments (filename OR copy_from OR code) can be used&#34;
            )

        self.verbose = True
        &#34;&#34;&#34;Report actions using print()&#34;&#34;&#34;

        self._vfc = pyo3d.Scene()
        &#34;&#34;&#34;_vfc : DAVE Core, where the actual magic happens&#34;&#34;&#34;

        self._nodes = []
        &#34;&#34;&#34;Contains a list of all nodes in the scene&#34;&#34;&#34;

        self.static_tolerance = 0.01
        &#34;&#34;&#34;Desired tolerance when solving statics&#34;&#34;&#34;

        self.resources_paths = []
        &#34;&#34;&#34;A list of paths where to look for resources such as .obj files. Priority is given to paths earlier in the list.&#34;&#34;&#34;
        self.resources_paths.extend(vfc.RESOURCE_PATH)

        self._savepoint = None
        &#34;&#34;&#34;Python code to re-create the scene, see savepoint_make()&#34;&#34;&#34;

        self._name_prefix = &#34;&#34;
        &#34;&#34;&#34;An optional prefix to be applied to node names. Used when importing scenes.&#34;&#34;&#34;

        self.current_manager = None
        &#34;&#34;&#34;Setting this to an instance of a Manager allows nodes with that manager to be changed&#34;&#34;&#34;

        self._godmode = False
        &#34;&#34;&#34;Icarus warning, wear proper PPE&#34;&#34;&#34;

        if filename is not None:
            self.load_scene(filename)

        if copy_from is not None:
            self.import_scene(copy_from, containerize=False)

        if code is not None:
            self.run_code(code)

    def clear(self):
        &#34;&#34;&#34;Deletes all nodes&#34;&#34;&#34;

        self._nodes = []
        del self._vfc
        self._vfc = pyo3d.Scene()

    # =========== private functions =============

    def _print_cpp(self):
        print(self._vfc.to_string())

    def _print(self, what):
        if self.verbose:
            print(what)

    def _prefix_name(self, name):
        return self._name_prefix + name

    def _verify_name_available(self, name):
        &#34;&#34;&#34;Throws an error if a node with name &#39;name&#39; already exists&#34;&#34;&#34;
        names = [n.name for n in self._nodes]
        names.extend(self._vfc.names)
        if name in names:
            raise Exception(
                &#34;The name &#39;{}&#39; is already in use. Pick a unique name&#34;.format(name)
            )

    def _node_from_node_or_str(self, node):
        &#34;&#34;&#34;If node is a string, then returns the node with that name,
        if node is a node, then returns that node

        Raises:
            ValueError if a string is passed with an non-existing node
        &#34;&#34;&#34;

        if isinstance(node, Node):
            return node
        if isinstance(node, str):
            return self[node]
        raise ValueError(
            &#34;Node should be a Node or a string, not a {}&#34;.format(type(node))
        )

    def _node_from_node(self, node, reqtype):
        &#34;&#34;&#34;Gets a node from the specified type

        Returns None if node is None
        Returns node if node is already a reqtype type node
        Else returns the axis with the given name

        Raises Exception if a node with name is not found&#34;&#34;&#34;

        if node is None:
            return None

        # node is a string then get the node with this name
        if type(node) == str:
            node = self[self._name_prefix + node]

        reqtype = make_iterable(reqtype)

        for r in reqtype:
            if isinstance(node, r):
                return node

        if issubclass(type(node), Node):
            raise Exception(
                &#34;Element with name {} can not be used , it should be a {} or derived type but is a {}.&#34;.format(
                    node.name, reqtype, type(node)
                )
            )

        raise Exception(&#34;This is not an acceptable input argument {}&#34;.format(node))

    def _parent_from_node(self, node):
        &#34;&#34;&#34;Returns None if node is None
        Returns node if node is an axis type node
        Else returns the axis with the given name

        Raises Exception if a node with name is not found&#34;&#34;&#34;

        return self._node_from_node(node, Axis)

    def _poi_from_node(self, node):
        &#34;&#34;&#34;Returns None if node is None
        Returns node if node is an poi type node
        Else returns the poi with the given name

        Raises Exception if anything is not ok&#34;&#34;&#34;

        return self._node_from_node(node, Point)

    def _poi_or_sheave_from_node(self, node):
        &#34;&#34;&#34;Returns None if node is None
        Returns node if node is an poi type node
        Else returns the poi with the given name

        Raises Exception if anything is not ok&#34;&#34;&#34;

        return self._node_from_node(node, [Point, Circle])

    def _sheave_from_node(self, node):
        &#34;&#34;&#34;Returns None if node is None
        Returns node if node is an poi type node
        Else returns the poi with the given name

        Raises Exception if anything is not ok&#34;&#34;&#34;

        return self._node_from_node(node, Circle)

    def _geometry_changed(self):
        &#34;&#34;&#34;Notify the scene that the geometry has changed and that the global transforms are invalid&#34;&#34;&#34;
        self._vfc.geometry_changed()

    def _fix_vessel_heel_trim(self):
        &#34;&#34;&#34;Fixes the heel and trim of each node that has a buoyancy or linear hydrostatics node attached.

        Returns:
            Dictionary with original fixed properties as dict({&#39;node name&#39;,fixed[6]}) which can be passed to _restore_original_fixes
        &#34;&#34;&#34;

        vessel_indicators = [
            *self.nodes_of_type(Buoyancy),
            *self.nodes_of_type(HydSpring),
        ]
        r = dict()

        for node in vessel_indicators:
            parent = node.parent  # axis

            if parent.fixed[3] and parent.fixed[4]:
                continue  # already fixed

            r[parent.name] = parent.fixed  # store original fixes
            fixed = [*parent.fixed]
            fixed[3] = True
            fixed[4] = True

            # if fixed[3] and fixed[4] are non-zero, then yaw has to be fixed as well.
            # The solver does not support it when an angular dof is free, but one of the fixed
            # angular dofs is non-zero

            fixed[5] = True

            parent.fixed = fixed

        return r

    def _restore_original_fixes(self, original_fixes):
        &#34;&#34;&#34;Restores the fixes as in original_fixes

        See also: _fix_vessel_heel_trim

        Args:
            original_fixes: dict with {&#39;node name&#39;,fixes[6] }

        Returns:
            None

        &#34;&#34;&#34;
        if original_fixes is None:
            return

        for name in original_fixes.keys():
            self.node_by_name(name).fixed = original_fixes[name]

    def _check_and_fix_geometric_contact_orientations(self) -&gt; (bool, str):
        &#34;&#34;&#34;A Geometric pin on pin contact may end up with tension in the contact. Fix that by moving the child pin to the other side of the parent pin

        Returns:
            True if anything was changed; False otherwise
        &#34;&#34;&#34;

        changed = False
        message = &#34;&#34;
        for n in self.nodes_of_type(GeometricContact):
            if not n.inside:

                # connection force of the child is the
                # force applied on the connecting rod
                # in the axis system of the rod
                if n._axis_on_child.connection_force_x &gt; 0:
                    message += f&#34;Changing side of pin-pin connection {n.name} due to tension in connection\n&#34;
                    n.change_side()
                    changed = True

        return (changed, message)

    # ======== resources =========

    def get_resource_path(self, url) -&gt; Path:
        &#34;&#34;&#34;Resolves the path on disk for resource url. Urls statring with res: result in a file from the resources system.

        Looks for a file with &#34;name&#34; in the specified resource-paths and returns the full path to the the first one
        that is found.
        If name is a full path to an existing file, then that is returned.

        See Also:
            resource_paths


        Returns:
            Full path to resource

        Raises:
            FileExistsError if resource is not found

        &#34;&#34;&#34;

        # warning and work-around for backwards compatibility
        # filenames without a path get res: in front of it
        try:
            if isinstance(url, Path):
                test = str(url)
            else:
                test = url

            if not test.startswith(&#34;res:&#34;):
                test = Path(test)
                if str(test.parent) == &#34;.&#34;:
                    # from warnings import warn
                    #
                    # warn(
                    #     f&#39;Resources should start with res: --&gt; fixing &#34;{url}&#34; to &#34;res: {url}&#34;&#39;
                    # )
                    url = &#34;res: &#34; + str(test)
        except:
            pass

        if isinstance(url, Path):
            file = url
        elif isinstance(url, str):
            if not url.startswith(&#34;res:&#34;):
                file = Path(url)
            else:
                # we have a string starting with &#39;res:&#39;
                filename = url[4:].strip()

                for res in self.resources_paths:
                    p = Path(res)

                    file = p / filename
                    if isfile(file):
                        return file

                # prepare feedback for error
                ext = str(url).split(&#34;.&#34;)[-1]  # everything after the last .

                print(&#34;Resource folders:&#34;)
                for res in self.resources_paths:
                    print(str(res))


                print(
                    &#34;The following resources with extension {} are available with &#34;.format(
                        ext
                    )
                )
                available = self.get_resource_list(ext)
                for a in available:
                    print(a)
                raise FileExistsError(
                    &#39;Resource &#34;{}&#34; not found in resource paths. A list with available resources with this extension is printed above this error&#39;.format(
                        url
                    )
                )
        else:
            raise ValueError(
                f&#34;Provided url shall be a Path or a string, not a {type(url)}&#34;
            )

        if file.exists():
            return file

        raise FileExistsError(
            &#39;File &#34;{}&#34; not found.\nHint: To obtain a resource put res: in front of the name.&#39;.format(
                url
            )
        )

    def get_resource_list(self, extension):
        &#34;&#34;&#34;Returns a list of all file-paths (strings) given extension in any of the resource-paths&#34;&#34;&#34;

        r = []

        for dir in self.resources_paths:
            try:
                files = listdir(dir)
                for file in files:
                    if file.lower().endswith(extension):
                        if file not in r:
                            r.append(&#34;res: &#34; + file)
            except FileNotFoundError:
                pass

        return r

    # ======== element functions =========

    def node_by_name(self, node_name, silent=False):
        for N in self._nodes:
            if N.name == node_name:
                return N

        if not silent:
            self.print_node_tree()
        raise ValueError(
            &#39;No node with name &#34;{}&#34;. Available names printed above.&#39;.format(node_name)
        )

    def __getitem__(self, node_name):
        &#34;&#34;&#34;Returns a node with name&#34;&#34;&#34;
        return self.node_by_name(node_name)

    def nodes_of_type(self, node_class):
        &#34;&#34;&#34;Returns all nodes of the specified or derived type

        Examples:
            pois = scene.nodes_of_type(DAVE.Poi)
            axis_and_bodies = scene.nodes_of_type(DAVE.Axis)
        &#34;&#34;&#34;
        r = list()
        for n in self._nodes:
            if isinstance(n, node_class):
                r.append(n)
        return r

    def assert_unique_names(self):
        &#34;&#34;&#34;Asserts that all names are unique&#34;&#34;&#34;
        names = [n.name for n in self._nodes]
        unique_names = set(names)

        if len(unique_names) != len(names):
            previous_name = &#34;&#34;
            names.sort()
            duplicates = &#34;&#34;
            for name in names:
                if name == previous_name:
                    print(f&#34;Duplicate: {name}&#34;)
                    duplicates += name + &#34; &#34;

                    for n in self._nodes:
                        if n.name == name:
                            print(n)

                previous_name = name
            raise ValueError(f&#34;Duplicate names exist: &#34; + duplicates)

    def sort_nodes_by_parent(self):
        &#34;&#34;&#34;Sorts the nodes such that the parent of this node (if any) occurs earlier in the list.

        See Also:
            sort_nodes_by_dependency
        &#34;&#34;&#34;

        self.assert_unique_names()

        exported = []
        to_be_exported = self._nodes.copy()
        counter = 0

        while to_be_exported:

            counter += 1
            if counter &gt; len(self._nodes):
                raise Exception(
                    &#34;Could not sort nodes by dependency, circular references exist?&#34;
                )

            can_be_exported = []

            for node in to_be_exported:

                if hasattr(node, &#34;parent&#34;):
                    parent = node.parent
                    if parent is not None and parent not in exported:
                        continue

                if node.manager is not None and node.manager not in exported:
                    continue

                # otherwise the node can be exported
                can_be_exported.append(node)

            # remove exported nodes from
            for n in can_be_exported:
                to_be_exported.remove(n)

            exported.extend(can_be_exported)

        self._nodes = exported

    def sort_nodes_by_dependency(self):
        &#34;&#34;&#34;Sorts the nodes such that a nodes creation only depends on nodes earlier in the list.

        This sorting is used for node creation order

        See Also:
            sort_nodes_by_parent
        &#34;&#34;&#34;

        self.assert_unique_names()

        exported = []
        to_be_exported = self._nodes.copy()
        counter = 0

        while to_be_exported:

            counter += 1
            if counter &gt; len(self._nodes):

                for node in to_be_exported:
                    print(f&#34;Node : {node.name}&#34;)
                    for d in node.depends_on():
                        print(f&#34;  depends on: {d.name}&#34;)
                    if node._manager:
                        print(f&#34;   managed by: {node._manager.name}&#34;)

                raise Exception(
                    &#34;Could not sort nodes by dependency, circular references exist?&#34;
                )

            can_be_exported = []

            for node in to_be_exported:
                # if node._manager:
                #     if node._manager in exported:
                #         can_be_exported.append(node)
                # el
                if all(el in exported for el in node.depends_on()):
                    can_be_exported.append(node)

            # remove exported nodes from
            for n in can_be_exported:
                to_be_exported.remove(n)

            exported.extend(can_be_exported)

        self._nodes = exported

        # scene_names = [n.name for n in self._nodes]
        #
        # self._vfc.state_update()  # use the function from the core.
        # new_list = []
        # for name in self._vfc.names:  # and then build a new list using the names
        #     if vfc.VF_NAME_SPLIT in name:
        #         continue
        #
        #     if name not in scene_names:
        #         raise Exception(&#39;Something went wrong with sorting the the nodes by dependency. &#39;
        #                         &#39;Node naming between core and scene is inconsistent for node {}&#39;.format(name))
        #
        #     new_list.append(self[name])
        #
        # # and add the nodes without a vfc-core connection
        # for node in self._nodes:
        #     if not node in new_list:
        #         new_list.append(node)
        #
        # self._nodes = new_list

    def name_available(self, name):
        &#34;&#34;&#34;Returns True if the name is still available&#34;&#34;&#34;
        names = [n.name for n in self._nodes]
        names.extend(self._vfc.names)
        return not (name in names)

    def available_name_like(self, like):
        &#34;&#34;&#34;Returns an available name like the one given, for example Axis23&#34;&#34;&#34;
        if self.name_available(like):
            return like
        counter = 1
        while True:
            name = like + &#34;_&#34; + str(counter)
            if self.name_available(name):
                return name
            counter += 1

    def node_A_core_depends_on_B_core(self, A, B):
        &#34;&#34;&#34;Returns True if the node core of node A depends on the core node of node B&#34;&#34;&#34;

        A = self._node_from_node_or_str(A)
        B = self._node_from_node_or_str(B)

        if not isinstance(A, CoreConnectedNode):
            raise ValueError(
                f&#34;{A.name} is not connected to a core node. Dependancies can not be traced using this function&#34;
            )
        if not isinstance(B, CoreConnectedNode):
            raise ValueError(
                f&#34;{B.name} is not connected to a core node. Dependancies can not be traced using this function&#34;
            )

        return self._vfc.element_A_depends_on_B(A._vfNode.name, B._vfNode.name)

    def nodes_managed_by(self, manager : Manager):
        &#34;&#34;&#34;Returns a list of nodes managed by manager&#34;&#34;&#34;

        return [node for node in self._nodes if node.manager == manager]

    def nodes_depending_on(self, node):
        &#34;&#34;&#34;Returns a list of nodes that physically depend on node. Only direct dependants are obtained with a connection to the core.
        This function should be used to determine if a node can be created, deleted, exported.

        For making node-trees please use nodes_with_parent instead.

        Args:
            node : Node or node-name

        Returns:
            list of names

        See Also: nodes_with_parent
        &#34;&#34;&#34;

        if isinstance(node, Node):
            node = node.name

        # check the node type
        _node = self[node]
        if not isinstance(_node, CoreConnectedNode):
            return []
        else:
            names = self._vfc.elements_depending_directly_on(node)

        r = []
        for name in names:
            try:
                node = self.node_by_name(name, silent=True)
                r.append(node.name)
            except:
                pass

        # check all other nodes in the scene

        for n in self._nodes:
            if _node in n.depends_on():
                if n.name not in r:
                    r.append(n.name)

        # for v in [*self.nodes_of_type(Visual), *self.nodes_of_type(WaveInteraction1)]:
        #     if v.parent is _node:
        #         r.append(v.name)

        return r

    def nodes_with_parent(self, node):
        &#34;&#34;&#34;Returns a list of nodes that have given node as a parent. Good for making trees.
        For checking physical connections use nodes_depending_on instead.

        Args:
            node : Node or node-name

        Returns:
            list of names

        See Also: nodes_depending_on
        &#34;&#34;&#34;

        if isinstance(node, str):
            node = self[node]

        r = []

        for n in self._nodes:

            try:
                parent = n.parent
            except AttributeError:
                continue

            if parent == node:
                r.append(n.name)

        return r

    def delete(self, node):
        &#34;&#34;&#34;Deletes the given node from the scene as well as all nodes depending on it.

        See Also:
            dissolve
        &#34;&#34;&#34;

        if isinstance(node, str):
            node = self[node]

        if node not in self._nodes:
            raise ValueError(
                &#34;Can not delete node because it is not a node of this scene&#34;
            )

        if isinstance(node, Manager):
            node.delete()
            # self._nodes.remove(node)
            # return &lt;-- do not return

        depending_nodes = self.nodes_depending_on(node)
        depending_nodes.extend([n.name for n in node.observers])

        if node._manager:  # node, delete its manager
            # print(&#39;Deleting manager&#39;)
            self.delete(node._manager)
            if node in self._nodes:
                self.delete(node)  # node may have been deleted by the manager

        else:
            self._print(
                &#34;Deleting {} [{}]&#34;.format(
                    node.name, str(type(node)).split(&#34;.&#34;)[-1][:-2]
                )
            )

            # First delete the dependencies
            for d in depending_nodes:
                if not self.name_available(d):  # element is still here
                    self.delete(d)

            # then remove the vtk node itself
            # self._print(&#39;removing vfc node&#39;)
            node._delete_vfc()
            self._nodes.remove(node)

    def dissolve(self, node):
        &#34;&#34;&#34;Attempts to delete the given node without affecting the rest of the model.

        1. Look for nodes that have this node as parent
        2. Attach those nodes to the parent of this node.
        3. Delete this node.

        There are many situations in which this will fail because an it is impossible to dissolve
        the element. For example a poi can only be dissolved when nothing is attached to it.

        For now this function only works on AXIS

        #TODO: Add managers - just release management

        &#34;&#34;&#34;

        if isinstance(node, str):
            node = self[node]

        ok = False
        if isinstance(node, Manager):

            if isinstance(node, Axis):
                p = self.new_axis(node.name + &#39;_dissolved&#39;)
            else:
                p = None

            for d in self.nodes_managed_by(node):
                with ClaimManagement(self,node):
                    if node in d.observers:
                        d.observers.remove(node)
                    d.manager = None

                    if isinstance(d, NodeWithParent):
                        if d.parent == node:
                            d.parent = p

            ok = True

        if isinstance(node, Axis):
            for d in self.nodes_depending_on(node):
                self[d].change_parent_to(node.parent)
            ok = True

        if not ok:
            raise TypeError(&#34;Only nodes of type Axis and Manager can be dissolved at this moment&#34;)

        self._nodes.remove(node)  # do not call delete as that will fail on managers

    def savepoint_make(self):
        self._savepoint = self.give_python_code()

    def savepoint_restore(self):
        if self._savepoint is not None:
            self.clear()
            exec(self._savepoint, {}, {&#34;s&#34;: self})
            self._savepoint = None
            return True
        else:
            return False

    # ========= The most important functions ========

    def update(self):
        &#34;&#34;&#34;Updates the interface between the nodes and the core. This includes the re-calculation of all forces,
        buoyancy positions, ballast-system cogs etc.
        &#34;&#34;&#34;
        for n in self._nodes:
            n.update()
        self._vfc.state_update()

    def solve_statics(self, silent=False, timeout=None):
        &#34;&#34;&#34;Solves statics

        Args:
            silent: Do not print if successfully solved

        Returns:
            bool: True if successful, False otherwise.

        &#34;&#34;&#34;
        self.update()

        if timeout is None:
            solve_func = self._vfc.state_solve_statics
        else:
            #       bool doStabilityCheck,
            #       double timeout,
            #           bool do_prepare_state,
            #           bool solve_linear_dofs_first,
            #           double stability_check_delta
            solve_func = lambda: self._vfc.state_solve_statics_with_timeout(
                True, timeout, True, True, 0
            )  # default stability value

        # pass 1
        orignal_fixes = self._fix_vessel_heel_trim()
        succes = solve_func()
        if not succes:
            self._restore_original_fixes(orignal_fixes)
            return False

        if orignal_fixes:
            # pass 2
            self._restore_original_fixes(orignal_fixes)
            succes = solve_func()

        if self.verify_equilibrium():

            changed, message = self._check_and_fix_geometric_contact_orientations()
            if changed:
                print(message)
                solve_func()
                if not self.verify_equilibrium():
                    return False

            if not silent:
                self._print(&#34;Solved to {}.&#34;.format(self._vfc.Emaxabs))
            return True

        d = np.array(self._vfc.get_dofs())
        if np.any(np.abs(d) &gt; 2000):
            print(
                &#34;Error: One of the degrees of freedom exceeded the boundary of 2000 [m]/[rad].&#34;
            )
            return False

        return False

    def verify_equilibrium(self, tol=1e-2):
        &#34;&#34;&#34;Checks if the current state is an equilibrium

        Returns:
            bool: True if successful, False if not an equilibrium.

        &#34;&#34;&#34;
        self.update()
        return self._vfc.Emaxabs &lt; tol

    # ====== goal seek ========

    def goal_seek(
        self, evaluate, target, change_node, change_property, bracket=None, tol=1e-3
    ):
        &#34;&#34;&#34;goal_seek

        Goal seek is the classic goal-seek. It changes a single property of a single node in order to get
        some property of some node to a specified value. Just like excel.

        Args:
            evaluate : code to be evaluated to yield the value that is solved for. Eg: s[&#39;poi&#39;].fx Scene is abbiviated as &#34;s&#34;
            target (number):       target value for that property
            change_node(Node or str):  node to be adjusted
            change_property (str): property of that node to be adjusted
            range(optional)  : specify the possible search-interval

        Returns:
            bool: True if successful, False otherwise.

        Examples:
            Change the y-position of the cog of a rigid body (&#39;Barge&#39;)  in order to obtain zero roll (rx)
            &gt;&gt;&gt; s.goal_seek(&#34;s[&#39;Barge&#39;].fx&#34;,0,&#39;Barge&#39;,&#39;cogy&#39;)

        &#34;&#34;&#34;
        s = self

        change_node = self._node_from_node_or_str(change_node)

        # check that the attributes exist and are single numbers
        test = eval(evaluate)

        try:
            float(test)
        except:
            raise ValueError(&#34;Evaluation of {} does not result in a float&#34;)

        self._print(
            &#34;Attempting to evaluate {} to {} (now {})&#34;.format(evaluate, target, test)
        )

        initial = getattr(change_node, change_property)
        self._print(
            &#34;By changing the value of {}.{} (now {})&#34;.format(
                change_node.name, change_property, initial
            )
        )

        def set_and_get(x):
            setattr(change_node, change_property, x)
            self.solve_statics(silent=True)
            s = self
            result = eval(evaluate)
            self._print(&#34;setting {} results in {}&#34;.format(x, result))
            return result - target

        from scipy.optimize import root_scalar

        x0 = initial
        x1 = initial + 0.0001

        if bracket is not None:
            res = root_scalar(set_and_get, x0=x0, x1=x1, bracket=bracket, xtol=tol)
        else:
            res = root_scalar(set_and_get, x0=x0, x1=x1, xtol=tol)

        self._print(res)

        # evaluate result
        final_value = eval(evaluate)
        if abs(final_value - target) &gt; 1e-3:
            raise ValueError(
                &#34;Target not reached. Target was {}, reached value is {}&#34;.format(
                    target, final_value
                )
            )

        return True

    def plot_effect(self, evaluate, change_node, change_property, start, to, steps):
        &#34;&#34;&#34;Produces a 2D plot with the relation between two properties of the scene. For example the length of a cable
        versus the force in another cable.

        The evaluate argument is processed using &#34;eval&#34; and may contain python code. This may be used to combine multiple
        properties to one value. For example calculate the diagonal load distribution from four independent loads.

        The plot is produced using matplotlob. The plot is produced in the current figure (if any) and plt.show is not executed.

        Args:
            evaluate (str): code to be evaluated to yield the value on the y-axis. Eg: s[&#39;poi&#39;].fx Scene is abbiviated as &#34;s&#34;
            change_node(Node or str):  node to be adjusted
            change_property (str): property of that node to be adjusted
            start : left side of the interval
            to : right side of the interval
            steps : number of steps in the interval

        Returns:
            Tuple (x,y) with x and y coordinates

        Examples:
            &gt;&gt;&gt; s.plot_effect(&#34;s[&#39;cable&#39;].tension&#34;, &#34;cable&#34;, &#34;length&#34;, 11, 14, 10)
            &gt;&gt;&gt; import matplotlib.pyplot as plt
            &gt;&gt;&gt; plt.show()

        &#34;&#34;&#34;
        s = self
        change_node = self._node_from_node_or_str(change_node)

        # check that the attributes exist and are single numbers
        test = eval(evaluate)

        try:
            float(test)
        except:
            raise ValueError(&#34;Evaluation of {} does not result in a float&#34;)

        def set_and_get(x):
            setattr(change_node, change_property, x)
            self.solve_statics(silent=True)
            s = self
            result = eval(evaluate)
            self._print(&#34;setting {} results in {}&#34;.format(x, result))
            return result

        xs = np.linspace(start, to, steps)
        y = []
        for x in xs:
            y.append(set_and_get(x))

        y = np.array(y)
        import matplotlib.pyplot as plt

        plt.plot(xs, y)
        plt.xlabel(&#34;{} of {}&#34;.format(change_property, change_node.name))
        plt.ylabel(evaluate)

        return (xs, y)

    # ======== create functions =========

    def new_axis(
        self,
        name,
        parent=None,
        position=None,
        rotation=None,
        inertia=None,
        inertia_radii=None,
        fixed=True,
    ) -&gt; Axis:
        &#34;&#34;&#34;Creates a new *axis* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: optional, name of the parent of the node
            position: optional, position for the node (x,y,z)
            rotation: optional, rotation for the node (rx,ry,rz)
            fixed [True]: optional, determines whether the axis is fixed [True] or free [False]. May also be a sequence of 6 booleans.

        Returns:
            Reference to newly created axis

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if position is not None:
            assert3f(position, &#34;Position &#34;)
        if rotation is not None:
            assert3f(rotation, &#34;Rotation &#34;)

        if inertia is not None:
            assert1f_positive_or_zero(inertia, &#34;inertia &#34;)

        if inertia_radii is not None:
            assert3f_positive(inertia_radii, &#34;Radii of inertia&#34;)
            assert inertia is not None, ValueError(
                &#34;Can not set radii of gyration without specifying inertia&#34;
            )

        if not isinstance(fixed, bool):
            if len(fixed) != 6:
                raise Exception(
                    &#39;&#34;fixed&#34; parameter should either be True/False or a 6x bool sequence such as (True,True,False,False,True,False)&#39;
                )

        # then create
        a = self._vfc.new_axis(name)

        new_node = Axis(self, a)

        # and set properties
        if b is not None:
            new_node.parent = b
        if position is not None:
            new_node.position = position
        if rotation is not None:
            new_node.rotation = rotation
        if inertia is not None:
            new_node.inertia = inertia
        if inertia_radii is not None:
            new_node.inertia_radii = inertia_radii

        if isinstance(fixed, bool):
            if fixed:
                new_node.set_fixed()
            else:
                new_node.set_free()
        else:
            new_node.fixed = fixed

        self._nodes.append(new_node)
        return new_node

    def new_geometriccontact(
        self,
        name,
        child,
        parent,
        inside=False,
        swivel=None,
        rotation_on_parent=None,
        child_rotation=None,
        swivel_fixed=True,
        fixed_to_parent=False,
        child_fixed=False,
    ) -&gt; GeometricContact:
        &#34;&#34;&#34;Creates a new *new_geometriccontact* node and adds it to the scene.

        Geometric contact connects two circular elements and can be used to model bar-bar connections or pin-in-hole connections.

        By default a bar-bar connection is created between item1 and item2.

        Args:
            name: Name for the node, should be unique
            child : [Sheave] will be the nodeA of the connection
            parent : [Sheave] will be the nodeB of the connection
            inside: [False] False creates a pinpin connection. True creates a pin-hole type of connection
            swivel: Rotation angle between the two items. Defaults to 90 for pinpin and 0 for pin-hole
            rotation_on_parent: Angle of the connecting hinge relative to nodeA or None for default
            child_rotation: Angle of the nodeB relative to the connecting hinge or None for default
            swivel_fixed: Fix swivel [True]
            fixed_to_parent: Fix connecting hinge to nodeA [False]
            child_fixed: Fix nodeB to connecting hinge [False]

        Note:
            For pin-hole connections there is no geometrical difference between the pin and the hole. Therefore it is not needed to specify
            which is the pin and which is the hole

        Returns:
            Reference to newly created new_geometriccontact

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)

        name_prefix = name + vfc.MANAGED_NODE_IDENTIFIER
        postfixes = [
            &#34;_axis_on_parent&#34;,
            &#34;_pin_hole_connection&#34;,
            &#34;_axis_on_child&#34;,
            &#34;_connection_axial_rotation&#34;,
        ]

        for pf in postfixes:
            self._verify_name_available(name_prefix + pf)

        child = self._sheave_from_node(child)
        parent = self._sheave_from_node(parent)

        assertBool(inside, &#34;inside&#34;)
        assertBool(swivel_fixed, &#34;swivel_fixed&#34;)
        assertBool(fixed_to_parent, &#34;fixed_to_parent&#34;)
        assertBool(child_fixed, &#34;child_fixed&#34;)

        GeometricContact._assert_parent_child_possible(parent, child)

        if swivel is None:
            if inside:
                swivel = 0
            else:
                swivel = 90

        assert1f(swivel, &#34;swivel_angle&#34;)

        if rotation_on_parent is not None:
            assert1f(rotation_on_parent, &#34;rotation_on_parent should be either None or &#34;)
        if child_rotation is not None:
            assert1f(child_rotation, &#34;child_rotation should be either None or &#34;)

        if child is None:
            raise ValueError(&#34;child needs to be a sheave-type node&#34;)
        if parent is None:
            raise ValueError(&#34;parent needs to be a sheave-type node&#34;)

        if child.parent.parent is None:
            raise ValueError(
                f&#34;The parent {child.parent.name} of the child item {child.name} is not located on an axis. Can not create the connection because there is no axis to nodeB&#34;
            )

        if child.parent.parent.manager is not None:
            self.print_node_tree()
            raise ValueError(
                f&#34;The axis or body that {child.name} is on is already managed by {child.parent.parent.manager.name} and can therefore not be changed - unable to create geometric contact&#34;
            )

        new_node = GeometricContact(self, child, parent, name)
        if inside:
            new_node.set_pin_in_hole_connection()
        else:
            new_node.set_pin_pin_connection()

        new_node.swivel = swivel
        if rotation_on_parent is not None:
            new_node.rotation_on_parent = rotation_on_parent
        if child_rotation is not None:
            new_node.child_rotation = child_rotation

        new_node.fixed_to_parent = fixed_to_parent
        new_node.child_fixed = child_fixed
        new_node.swivel_fixed = swivel_fixed

        self._nodes.append(new_node)
        return new_node

    def new_waveinteraction(
        self,
        name,
        path,
        parent=None,
        offset=None,
    ) -&gt; WaveInteraction1:
        &#34;&#34;&#34;Creates a new *wave interaction* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            path: Path to the hydrodynamic database
            parent: optional, name of the parent of the node
            offset: optional, position for the node (x,y,z)

        Returns:
            Reference to newly created wave-interaction object

        &#34;&#34;&#34;

        if not parent:
            raise ValueError(&#34;Wave-interaction has to be located on an Axis&#34;)

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if b is None:
            raise ValueError(&#34;Wave-interaction has to be located on an Axis&#34;)

        if offset is not None:
            assert3f(offset, &#34;Offset &#34;)

        self.get_resource_path(path)  # raises error when resource is not found

        # then create

        new_node = WaveInteraction1(self)

        new_node.name = name
        new_node.path = path
        new_node.parent = parent

        # and set properties
        new_node.parent = b
        if offset is not None:
            new_node.offset = offset

        self._nodes.append(new_node)
        return new_node

    def new_visual(
        self, name, path, parent=None, offset=None, rotation=None, scale=None
    ) -&gt; Visual:
        &#34;&#34;&#34;Creates a new *Visual* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            path: Path to the resource
            parent: optional, name of the parent of the node
            offset: optional, position for the node (x,y,z)
            rotation: optional, rotation for the node (rx,ry,rz)
            scale : optional, scale of the visual (x,y,z).

        Returns:
            Reference to newly created visual

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if offset is not None:
            assert3f(offset, &#34;Offset &#34;)
        if rotation is not None:
            assert3f(rotation, &#34;Rotation &#34;)

        self.get_resource_path(path)  # raises error when resource is not found

        # then create

        new_node = Visual(self)

        new_node.name = name
        new_node.path = path
        new_node.parent = parent

        # and set properties
        if b is not None:
            new_node.parent = b
        if offset is not None:
            new_node.offset = offset
        if rotation is not None:
            new_node.rotation = rotation
        if scale is not None:
            new_node.scale = scale

        self._nodes.append(new_node)
        return new_node

    def new_point(self, name, parent=None, position=None) -&gt; Point:
        &#34;&#34;&#34;Creates a new *poi* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: optional, name of the parent of the node
            position: optional, position for the node (x,y,z)


        Returns:
            Reference to newly created poi

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if position is not None:
            assert3f(position, &#34;Position &#34;)

        # then create
        a = self._vfc.new_poi(name)

        new_node = Point(self, a)

        # and set properties
        if b is not None:
            new_node.parent = b
        if position is not None:
            new_node.position = position

        self._nodes.append(new_node)
        return new_node

    def new_rigidbody(
        self,
        name,
        mass=0,
        cog=(0, 0, 0),
        parent=None,
        position=None,
        rotation=None,
        inertia_radii=None,
        fixed=True,
    ) -&gt; RigidBody:
        &#34;&#34;&#34;Creates a new *rigidbody* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            mass: optional, [0] mass in mT
            cog: optional, (0,0,0) cog-position in (m,m,m)
            parent: optional, name of the parent of the node
            position: optional, position for the node (x,y,z)
            rotation: optional, rotation for the node (rx,ry,rz)
            inertia_radii : optional, radii of gyration (rxx,ryy,rzz); only used for dynamics
            fixed [True]: optional, determines whether the axis is fixed [True] or free [False]. May also be a sequence of 6 booleans.

        Examples:
            scene.new_rigidbody(&#34;heavy_thing&#34;, mass = 10000, cog = (1.45, 0, -0.7))

        Returns:
            Reference to newly created RigidBody

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # check input
        assertValidName(name)
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if position is not None:
            assert3f(position, &#34;Position &#34;)
        if rotation is not None:
            assert3f(rotation, &#34;Rotation &#34;)

        if inertia_radii is not None:
            assert3f_positive(inertia_radii, &#34;Radii of inertia&#34;)
            assert mass &gt; 0, ValueError(
                &#34;Can not set radii of gyration without specifying mass&#34;
            )

        if not isinstance(fixed, bool):
            if len(fixed) != 6:
                raise Exception(
                    &#39;&#34;fixed&#34; parameter should either be True/False or a 6x bool sequence such as (True,True,False,False,True,False)&#39;
                )

        # make elements

        a = self._vfc.new_axis(name)

        p = self._vfc.new_poi(name + vfc.VF_NAME_SPLIT + &#34;cog&#34;)
        p.parent = a
        p.position = cog

        g = self._vfc.new_force(name + vfc.VF_NAME_SPLIT + &#34;gravity&#34;)
        g.parent = p
        g.force = (0, 0, -vfc.G * mass)

        r = RigidBody(self, a, p, g)

        r.cog = cog  # set inertia
        r.mass = mass

        # and set properties
        if b is not None:
            r.parent = b
        if position is not None:
            r.position = position
        if rotation is not None:
            r.rotation = rotation

        if inertia_radii is not None:
            r.inertia_radii = inertia_radii

        if isinstance(fixed, bool):
            if fixed:
                r.set_fixed()
            else:
                r.set_free()
        else:
            r.fixed = fixed

        self._nodes.append(r)
        return r

    def new_cable(
        self, name, endA, endB, length=-1, EA=0, diameter=0, sheaves=None
    ) -&gt; Cable:
        &#34;&#34;&#34;Creates a new *cable* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            endA : A Poi element to connect the first end of the cable to
            endB : A Poi element to connect the other end of the cable to
            length [-1] : un-stretched length of the cable in m; default [-1] create a cable with the current distance between the endpoints A and B
            EA [0] : stiffness of the cable in kN/m; default

            sheaves : [optional] A list of pois, these are sheaves that the cable runs over. Defined from endA to endB

        Examples:

            scene.new_cable(&#39;cable_name&#39; endA=&#39;poi_start&#39;, endB = &#39;poi_end&#39;)  # minimal use

            scene.new_cable(&#39;cable_name&#39;, length=50, EA=1000, endA=poi_start, endB = poi_end, sheaves=[sheave1, sheave2])

            scene.new_cable(&#39;cable_name&#39;, length=50, EA=1000, endA=&#39;poi_start&#39;, endB = &#39;poi_end&#39;, sheaves=[&#39;single_sheave&#39;]) # also a single sheave needs to be provided as a list

        Notes:
            The default options for length and EA can be used to measure distances between points

        Returns:
            Reference to newly created Cable

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        assert1f(length, &#34;length&#34;)
        assert1f(EA, &#34;EA&#34;)

        endA = self._poi_or_sheave_from_node(endA)
        endB = self._poi_or_sheave_from_node(endB)

        pois = [endA]
        if sheaves is not None:

            if isinstance(sheaves, Point):  # single sheave as poi or string
                sheaves = [sheaves]

            if isinstance(sheaves, Circle):  # single sheave as poi or string
                sheaves = [sheaves]

            if isinstance(sheaves, str):
                sheaves = [sheaves]

            for s in sheaves:
                # s may be a poi or a sheave
                pois.append(self._poi_or_sheave_from_node(s))

        pois.append(endB)

        # default options
        if length &gt; -1:
            if length &lt; 1e-9:
                raise Exception(&#34;Length should be more than 0&#34;)

        if EA &lt; 0:
            raise Exception(&#34;EA should be more than 0&#34;)

        assert1f(diameter, &#34;Diameter should be a number &gt;= 0&#34;)

        if diameter &lt; 0:
            raise Exception(&#34;Diameter should be &gt;= 0&#34;)

        # then create
        a = self._vfc.new_cable(name)
        new_node = Cable(self, a)
        if length &gt; 0:
            new_node.length = length
        new_node.EA = EA
        new_node.diameter = diameter

        new_node.connections = pois

        # and add to the scene
        self._nodes.append(new_node)

        if length &lt; 0:
            new_node.length = 1e-8
            self._vfc.state_update()

            new_length = new_node.stretch + 1e-8

            if new_length &gt; 0:
                new_node.length = new_length
            else:
                # is is possible that all nodes are at the same location which means the total length becomes 0
                self.delete(new_node.name)
                raise ValueError(
                    &#34;No lengh has been supplied and all connection points are at the same location - unable to determine a non-zero default length. Please supply a length&#34;
                )

        return new_node

    def new_force(self, name, parent=None, force=None, moment=None) -&gt; Force:
        &#34;&#34;&#34;Creates a new *force* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: name of the parent of the node [Poi]
            force: optional, global force on the node (x,y,z)
            moment: optional, global force on the node (x,y,z)


        Returns:
            Reference to newly created force

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._poi_from_node(parent)

        if force is not None:
            assert3f(force, &#34;Force &#34;)

        if moment is not None:
            assert3f(moment, &#34;Moment &#34;)

        # then create
        a = self._vfc.new_force(name)

        new_node = Force(self, a)

        # and set properties
        if b is not None:
            new_node.parent = b
        if force is not None:
            new_node.force = force
        if moment is not None:
            new_node.moment = moment

        self._nodes.append(new_node)
        return new_node

    def new_circle(self, name, parent, axis, radius=0.0) -&gt; Circle:
        &#34;&#34;&#34;Creates a new *sheave* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: name of the parent of the node [Poi]
            axis: direction of the axis of rotation (x,y,z)
            radius: optional, radius of the sheave


        Returns:
            Reference to newly created sheave

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._poi_from_node(parent)

        assert3f(axis, &#34;Axis of rotation &#34;)

        assert1f(radius, &#34;Radius of sheave&#34;)

        # then create
        a = self._vfc.new_sheave(name)

        new_node = Circle(self, a)

        # and set properties
        new_node.parent = b
        new_node.axis = axis
        new_node.radius = radius

        self._nodes.append(new_node)
        return new_node

    def new_hydspring(
        self,
        name,
        parent,
        cob,
        BMT,
        BML,
        COFX,
        COFY,
        kHeave,
        waterline,
        displacement_kN,
    ) -&gt; HydSpring:
        &#34;&#34;&#34;Creates a new *hydspring* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: name of the parent of the node [Axis]
            cob: position of the CoB (x,y,z) in the parent axis system
            BMT: Vertical distance between CoB and meta-center for roll
            BML: Vertical distance between CoB and meta-center for pitch
            COFX: X-location of center of flotation (center of waterplane) relative to CoB
            COFY: Y-location of center of flotation (center of waterplane) relative to CoB
            kHeave : heave stiffness (typically Awl * rho * g)
            waterline : Z-position (elevation) of the waterline relative to CoB
            displacement_kN : displacement (typically volume * rho * g)


        Returns:
            Reference to newly created hydrostatic spring

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._parent_from_node(parent)
        assert3f(cob, &#34;CoB &#34;)
        assert1f(BMT, &#34;BMT &#34;)
        assert1f(BML, &#34;BML &#34;)
        assert1f(COFX, &#34;COFX &#34;)
        assert1f(COFY, &#34;COFY &#34;)
        assert1f(kHeave, &#34;kHeave &#34;)
        assert1f(waterline, &#34;waterline &#34;)
        assert1f(displacement_kN, &#34;displacement_kN &#34;)

        # then create
        a = self._vfc.new_hydspring(name)
        new_node = HydSpring(self, a)

        new_node.cob = cob
        new_node.parent = b
        new_node.BMT = BMT
        new_node.BML = BML
        new_node.COFX = COFX
        new_node.COFY = COFY
        new_node.kHeave = kHeave
        new_node.waterline = waterline
        new_node.displacement_kN = displacement_kN

        self._nodes.append(new_node)

        return new_node

    def new_linear_connector_6d(self, name, main, secondary, stiffness=None) -&gt; LC6d:
        &#34;&#34;&#34;Creates a new *linear connector 6d* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            main: Main axis system [Axis]
            secondary: Secondary axis system [Axis]
            stiffness: optional, connection stiffness (x,y,z, rx,ry,rz)

        See :py:class:`LC6d` for details

        Returns:
            Reference to newly created connector

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        m = self._parent_from_node(secondary)
        s = self._parent_from_node(main)

        if stiffness is not None:
            assert6f(stiffness, &#34;Stiffness &#34;)
        else:
            stiffness = (0, 0, 0, 0, 0, 0)

        # then create
        a = self._vfc.new_linearconnector6d(name)

        new_node = LC6d(self, a)

        # and set properties
        new_node.main = m
        new_node.secondary = s
        new_node.stiffness = stiffness

        self._nodes.append(new_node)
        return new_node

    def new_connector2d(
        self, name, nodeA, nodeB, k_linear=0, k_angular=0
    ) -&gt; Connector2d:
        &#34;&#34;&#34;Creates a new *new_connector2d* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            nodeB: First axis system [Axis]
            nodeA: Second axis system [Axis]

            k_linear : linear stiffness in kN/m
            k_angular : angular stiffness in kN*m / rad

        Returns:
            Reference to newly created connector2d

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        m = self._parent_from_node(nodeA)
        s = self._parent_from_node(nodeB)

        assert1f(k_linear, &#34;Linear stiffness&#34;)
        assert1f(k_angular, &#34;Angular stiffness&#34;)

        # then create
        a = self._vfc.new_connector2d(name)

        new_node = Connector2d(self, a)

        # and set properties
        new_node.nodeA = m
        new_node.nodeB = s
        new_node.k_linear = k_linear
        new_node.k_angular = k_angular

        self._nodes.append(new_node)
        return new_node

    def new_beam(
        self,
        name,
        nodeA,
        nodeB,
        EIy=0,
        EIz=0,
        GIp=0,
        EA=0,
        L=None,
        mass=0,
        n_segments=1,
        tension_only=False,
    ) -&gt; Beam:
        &#34;&#34;&#34;Creates a new *beam* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            nodeA: First axis system [Axis]
            nodeB: Second axis system [Axis]

            All stiffness terms default to 0
            The length defaults to the distance between nodeA and nodeB


        See :py:class:`LinearBeam` for details

        Returns:
            Reference to newly created beam

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        m = self._parent_from_node(nodeA)
        s = self._parent_from_node(nodeB)

        if L is None:
            L = np.linalg.norm(
                np.array(m.global_position) - np.array(s.global_position)
            )
        else:
            if L &lt;= 0:
                raise ValueError(&#34;L should be &gt; 0 as stiffness is defined per length.&#34;)

        assert1f_positive_or_zero(EIy, &#34;EIy should be &gt;= 0&#34;)
        assert1f_positive_or_zero(EIz, &#34;EIz should be &gt;= 0&#34;)
        assert1f_positive_or_zero(GIp, &#34;GIp should be &gt;= 0&#34;)
        assert1f_positive_or_zero(EA, &#34;EA should be &gt;= 0&#34;)
        assertBool(tension_only, &#34;tension_only should be bool&#34;)
        assert1f(mass, &#34;Mass shall be a number&#34;)
        n_segments = int(round(n_segments))

        # then create
        a = self._vfc.new_linearbeam(name)

        new_node = Beam(self, a)

        # and set properties
        new_node.nodeA = m
        new_node.nodeB = s
        new_node.EIy = EIy
        new_node.EIz = EIz
        new_node.GIp = GIp
        new_node.EA = EA
        new_node.L = L
        new_node.mass = mass
        new_node.n_segments = n_segments
        new_node.tension_only = tension_only

        self._nodes.append(new_node)
        return new_node

    def new_buoyancy(self, name, parent=None, density=1.025) -&gt; Buoyancy:
        &#34;&#34;&#34;Creates a new *buoyancy* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: optional, name of the parent of the node


        Returns:
            Reference to newly created buoyancy

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if b is None:
            raise ValueError(&#34;A valid parent must be defined for a Buoyancy node&#34;)

        assert1f_positive_or_zero(density, &#34;density&#34;)

        # then create
        a = self._vfc.new_buoyancy(name)
        new_node = Buoyancy(self, a)

        # and set properties
        if b is not None:
            new_node.parent = b

        new_node.density = density

        self._nodes.append(new_node)
        return new_node

    def new_tank(self, name, parent=None, density=1.025, free_flooding=False) -&gt; Tank:
        &#34;&#34;&#34;Creates a new *tank* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: optional, name of the parent of the node

        Returns:
            Reference to newly created Tank

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        if b is None:
            raise ValueError(&#34;A valid parent must be defined for a Tank&#34;)

        assert isinstance(free_flooding, bool), ValueError(
            &#34;free_flooding shall be True or False&#34;
        )

        assert1f(density, &#34;density&#34;)

        # then create
        a = self._vfc.new_tank(name)
        new_node = Tank(self, a)
        new_node.density = density

        # and set properties
        if b is not None:
            new_node.parent = b

        new_node.free_flooding = free_flooding

        self._nodes.append(new_node)
        return new_node

    def new_contactmesh(self, name, parent=None) -&gt; ContactMesh:
        &#34;&#34;&#34;Creates a new *contactmesh* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: optional, name of the parent of the node

        Returns:
            Reference to newly created contact mesh

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        # then create
        a = self._vfc.new_contactmesh(name)
        new_node = ContactMesh(self, a)

        # and set properties
        if b is not None:
            new_node.parent = b

        self._nodes.append(new_node)
        return new_node

    def new_spmt(
        self,
        name,
        parent,
        maximal_length=1.8,
        nominal_length=1.5,
        k=1e6,
        meshes=None,
        axles=None,
    ) -&gt; SPMT:
        &#34;&#34;&#34;Creates a new *SPMT* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: name of the parent of the node [Axis]
            maximal_length: optional, maximum distance between top and bottom of wheel (1.5m + 300mm)
            nominal_length: optional, nominal distance between top and bottom of wheel [1.5m]
            k : stiffness per axle [kN/m]
            meshes : list of contact meshes
            axles  : list of axle locations [(x,y,z),(x,y,z), ... ]

        Returns:
            Reference to newly created SPMT

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        parent = self._node_from_node_or_str(parent)
        assert isinstance(parent, Axis), ValueError(
            f&#34;Parent should be an axis system or derived, not a {type(parent)}&#34;
        )

        assert1f_positive_or_zero(maximal_length, &#34;maximal_length &#34;)
        assert1f_positive_or_zero(nominal_length, &#34;nominal_length &#34;)

        if meshes is not None:
            meshes = make_iterable(meshes)
            for mesh in meshes:
                test = self._node_from_node(
                    mesh, ContactMesh
                )  # throws error if not found

        if axles is not None:
            for p in axles:
                assert3f(p, &#34;axle locations should be (x,y,z)&#34;)

        # then create
        a = self._vfc.new_spmt(name)

        new_node = SPMT(self, a)

        # and set properties
        new_node.parent = parent
        new_node.k = k
        new_node.max_length = maximal_length
        new_node.nominal_length = nominal_length

        if meshes is not None:
            new_node.meshes = meshes

        if axles is not None:
            new_node.axles = axles

        self._nodes.append(new_node)
        return new_node

    def new_contactball(
        self, name, parent=None, radius=1, k=9999, meshes=None
    ) -&gt; ContactBall:
        &#34;&#34;&#34;Creates a new *force* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: name of the parent of the node [Poi]
            force: optional, global force on the node (x,y,z)
            moment: optional, global force on the node (x,y,z)


        Returns:
            Reference to newly created force

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)
        b = self._poi_from_node(parent)

        assert1f_positive_or_zero(radius, &#34;Radius &#34;)
        assert1f_positive_or_zero(k, &#34;k &#34;)

        if meshes is not None:
            meshes = make_iterable(meshes)
            for mesh in meshes:
                test = self._node_from_node(mesh, ContactMesh)

        # then create
        a = self._vfc.new_contactball(name)

        new_node = ContactBall(self, a)

        # and set properties
        if b is not None:
            new_node.parent = b
        if k is not None:
            new_node.k = k
        if radius is not None:
            new_node.radius = radius

        if meshes is not None:
            new_node.meshes = meshes

        self._nodes.append(new_node)
        return new_node

    def new_ballastsystem(self, name, parent: Axis) -&gt; BallastSystem:
        &#34;&#34;&#34;Creates a new *rigidbody* node and adds it to the scene.

        Args:
            name: Name for the node, should be unique
            parent: name of the parent of the ballast system (ie: the vessel axis system)

        Examples:
            scene.new_ballastsystem(&#34;cheetah_ballast&#34;, parent=&#34;Cheetah&#34;)

        Returns:
            Reference to newly created BallastSystem

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # check input
        assertValidName(name)
        self._verify_name_available(name)
        b = self._parent_from_node(parent)

        parent = self._parent_from_node(parent)  # handles verification of type as well

        # make elements
        r = BallastSystem(self, parent)
        r.name = name

        self._nodes.append(r)
        return r

    def new_sling(
        self,
        name,
        length=-1,
        EA=1.0,
        mass=0.1,
        endA=None,
        endB=None,
        LeyeA=None,
        LeyeB=None,
        LspliceA=None,
        LspliceB=None,
        diameter=0.1,
        sheaves=None,
    ) -&gt; Sling:
        &#34;&#34;&#34;
        Creates a new sling, adds it to the scene and returns a reference to the newly created object.

        See Also:
            Sling

        Args:
            name:    name
            length:  length of the sling [m], defaults to distance between endpoints
            EA:      stiffness in kN, default: 1.0 (note: equilibrium will fail if mass &gt;0 and EA=0)
            mass:    mass in mT, default  0.1
            endA:    element to connect end A to [poi, circle]
            endB:    element to connect end B to [poi, circle]
            LeyeA:   inside eye on side A length [m], defaults to 1/6th of length
            LeyeB:   inside eye on side B length [m], defaults to 1/6th of length
            LspliceA: splice length on side A [m] (the part where the cable is connected to itself)
            LspliceB: splice length on side B [m] (the part where the cable is connected to itself)
            diameter: cable diameter in m, defaul to 0.1
            sheaves:  optional: list of sheaves/pois that the sling runs over

        Returns:
            a reference to the newly created Sling object.

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)

        name_prefix = name + vfc.MANAGED_NODE_IDENTIFIER
        postfixes = [
            &#34;_spliceA&#34;,
            &#34;_spliceA&#34;,
            &#34;_spliceA2&#34;,
            &#34;_spliceAM&#34;,
            &#34;_spliceA_visual&#34;,
            &#34;spliceB&#34;,
            &#34;_spliceB1&#34;,
            &#34;_spliceB2&#34;,
            &#34;_spliceBM&#34;,
            &#34;_spliceB_visual&#34;,
            &#34;_main_part&#34;,
            &#34;_eyeA&#34;,
            &#34;_eyeB&#34;,
        ]

        for pf in postfixes:
            self._verify_name_available(name_prefix + pf)

        endA = self._poi_or_sheave_from_node(endA)
        endB = self._poi_or_sheave_from_node(endB)

        if length == -1:  # default
            if endA is None or endB is None:
                raise ValueError(
                    &#34;Length for cable is not provided, so defaults to distance between endpoints; but at least one of the endpoints is None.&#34;
                )

            length = np.linalg.norm(
                np.array(endA.global_position) - np.array(endB.global_position)
            )

        if LeyeA is None:  # default
            LeyeA = length / 6
        if LeyeB is None:  # default
            LeyeB = length / 6
        if LspliceA is None:  # default
            LspliceA = length / 6
        if LspliceB is None:  # default
            LspliceB = length / 6

        if sheaves is None:
            sheaves = []

        assert1f_positive_or_zero(diameter, &#34;Diameter&#34;)
        assert1f_positive_or_zero(mass, &#34;mass&#34;)

        assert1f_positive(length, &#34;Length&#34;)
        assert1f_positive(LeyeA, &#34;length of eye A&#34;)
        assert1f_positive(LeyeB, &#34;length of eye B&#34;)
        assert1f_positive(LspliceA, &#34;length of splice A&#34;)
        assert1f_positive(LspliceB, &#34;length of splice B&#34;)

        for s in sheaves:
            _ = self._poi_or_sheave_from_node(s)

        # then make element
        # __init__(self, scene, name, Ltotal, LeyeA, LeyeB, LspliceA, LspliceB, diameter, EA, mass, endA = None, endB=None, sheaves=None):

        node = Sling(
            scene=self,
            name=name,
            length=length,
            LeyeA=LeyeA,
            LeyeB=LeyeB,
            LspliceA=LspliceA,
            LspliceB=LspliceB,
            diameter=diameter,
            EA=EA,
            mass=mass,
            endA=endA,
            endB=endB,
            sheaves=sheaves,
        )
        self._nodes.append(node)

        return node

    def new_shackle(self, name, kind=&#34;GP500&#34;) -&gt; Shackle:
        &#34;&#34;&#34;
        Creates a new shackle, adds it to the scene and returns a reference to the newly created object.

        See Also:
            Shackle

        Args:
            name:   name
            kind:  type of shackle; eg &#39;GP500&#39;


        Returns:
            a reference to the newly created Shackle object.

        &#34;&#34;&#34;

        # apply prefixes
        name = self._prefix_name(name)

        # first check
        assertValidName(name)
        self._verify_name_available(name)

        name_prefix = name + vfc.MANAGED_NODE_IDENTIFIER
        postfixes = [
            &#34;_body&#34;,
            &#34;_pin_point&#34;,
            &#34;_bow_point&#34;,
            &#34;_inside_circle_center&#34;,
            &#34;_inside&#34;,
            &#34;_visual&#34;,
        ]
        for pf in postfixes:
            self._verify_name_available(name_prefix + pf)

        # then make element

        # make elements

        a = self._vfc.new_axis(name)

        p = self._vfc.new_poi(name + vfc.VF_NAME_SPLIT + &#34;cog&#34;)
        p.parent = a

        g = self._vfc.new_force(name + vfc.VF_NAME_SPLIT + &#34;gravity&#34;)
        g.parent = p

        node = Shackle(scene=self, name=name, kind=kind, a=a, p=p, g=g)

        self._nodes.append(node)

        return node

    def print_python_code(self):
        &#34;&#34;&#34;Prints the python code that generates the current scene

        See also: give_python_code
        &#34;&#34;&#34;
        for line in self.give_python_code().split(&#34;\n&#34;):
            print(line)

    def give_python_code(self):
        &#34;&#34;&#34;Generates the python code that rebuilds the scene and elements in its current state.&#34;&#34;&#34;

        import datetime
        import getpass

        self.sort_nodes_by_dependency()

        code = &#34;# auto generated pyhton code&#34;
        try:
            code += &#34;\n# By {}&#34;.format(getpass.getuser())
        except:
            code += &#34;\n# By an unknown&#34;

        code += &#34;\n# Time: {} UTC&#34;.format(str(datetime.datetime.now()).split(&#34;.&#34;)[0])

        code += &#34;\n\n# To be able to distinguish the important number (eg: fixed positions) from&#34;
        code += &#34;\n# non-important numbers (eg: a position that is solved by the static solver) we use a dummy-function called &#39;solved&#39;.&#34;
        code += &#34;\n# For anything written as solved(number) that actual number does not influence the static solution&#34;
        code += &#34;\ndef solved(number):\n    return number\n&#34;

        for n in self._nodes:

            if n._manager is None:
                # print(f&#39;code for {n.name}&#39;)
                code += &#34;\n&#34; + n.give_python_code()
            else:
                if n._manager.creates(n):
                    pass
                else:
                    code += &#34;\n&#34; + n.give_python_code()

                # print(f&#39;skipping {n.name} &#39;)

        # store the visibility code separately

        for n in self._nodes:
            if not n.visible:
                code += f&#34;\ns[&#39;{n.name}&#39;].visible = False&#34;  # only report is not the default value

        return code

    def save_scene(self, filename):
        &#34;&#34;&#34;Saves the scene to a file

        This saves the scene in its current state to a file.
        Opening the saved file will reproduce exactly this scene.

        This sounds nice, but beware that it only saves the resulting model, not the process of creating the model.
        This means that if you created the model in a parametric fashion or assembled the model from other models then these are not re-evaluated when the model is openened again.
        So lets say this model uses a sub-model of a lifting hook which is imported from another file. If that other file is updated then
        the results of that update will not be reflected in the saved model.

        If no path is present in the file-name then the model will be saved in the last (lowest) resource-path (if any)

        Args:
            filename : filename or file-path to save the file. Default extension is .dave

        Returns:
            the full path to the saved file

        &#34;&#34;&#34;

        code = self.give_python_code()

        filename = Path(filename)

        # add .dave extension if needed
        if filename.suffix != &#34;.dave&#34;:
            filename = Path(str(filename) + &#34;.dave&#34;)

        # add path if not provided
        if not filename.is_absolute():
            try:
                filename = Path(self.resources_paths[-1]) / filename
            except:
                pass  # save in current folder

        # make sure directory exists
        directory = filename.parent
        if not directory.exists():
            directory.mkdir()

        f = open(filename, &#34;w+&#34;)
        f.write(code)
        f.close()

        self._print(&#34;Saved as {}&#34;.format(filename))

        return filename

    def print_node_tree(self):

        self.sort_nodes_by_dependency()

        to_be_printed = []
        for n in self._nodes:
            to_be_printed.append(n.name)

        # to_be_printed.reverse()

        def print_deps(name, spaces):

            node = self[name]
            deps = self.nodes_with_parent(node)
            print(spaces + name + &#34; [&#34; + str(type(node)).split(&#34;.&#34;)[-1][:-2] + &#34;]&#34;)

            if deps is not None:
                for dep in deps:
                    if spaces == &#34;&#34;:
                        spaces_plus = &#34; |-&gt; &#34;
                    else:
                        spaces_plus = &#34; |   &#34; + spaces
                    print_deps(dep, spaces_plus)

            to_be_printed.remove(name)

        while to_be_printed:
            name = to_be_printed[0]
            print_deps(name, &#34;&#34;)

    def run_code(self, code):
        &#34;&#34;&#34;Runs the provided code with &#39;s&#39; as self&#34;&#34;&#34;

        import DAVE

        locals = DAVE.__dict__
        locals[&#39;s&#39;] = self

        try:
            exec(code, {}, locals)
        except Exception as M:
            for i, line in enumerate(code.split(&#34;\n&#34;)):
                print(f&#34;{i} {line}&#34;)
            raise M

    def load_scene(self, filename=None):
        &#34;&#34;&#34;Loads the contents of filename into the current scene.

        This function is typically used on an empty scene.

        Filename is appended with .dave if needed.
        File is searched for in the resource-paths.

        See also: import scene&#34;&#34;&#34;

        if filename is None:
            raise Exception(&#34;Please provide a file-name&#34;)

        try:
            filename = self.get_resource_path(filename)
        except:
            if not str(filename).endswith(&#34;.dave&#34;):
                filename = Path(str(filename) + &#34;.dave&#34;)

        print(&#34;Loading {}&#34;.format(filename))

        f = open(file=filename, mode=&#34;r&#34;)
        code = &#34;&#34;
        for line in f:
            code += line + &#34;\n&#34;

        self.run_code(code)

    def import_scene(self, other, prefix=&#34;&#34;, containerize=True):
        &#34;&#34;&#34;Copy-paste all nodes of scene &#34;other&#34; into current scene.

        To avoid double names it is recommended to use a prefix. This prefix will be added to all element names.

        Returns:
            Contained (Axis-type Node) : if the imported scene is containerized then a reference to the created container is returned.
        &#34;&#34;&#34;

        if isinstance(other, Path):
            other = str(other)

        if isinstance(other, str):
            other = Scene(other)

        if not isinstance(other, Scene):
            raise TypeError(&#34;Other should be a Scene but is a &#34; + str(type(other)))

        old_prefix = self._name_prefix
        imported_element_names = []

        for n in other._nodes:
            imported_element_names.append(prefix + n.name)

        # check for double names

        for new_node_name in imported_element_names:
            if not self.name_available(new_node_name):
                raise NameError(
                    &#39;An element with name &#34;{}&#34; is already present. Please use a prefix to avoid double names&#39;.format(
                        new_node_name
                    )
                )

        self._name_prefix = prefix

        code = other.give_python_code()

        self.run_code(code)

        self._name_prefix = old_prefix  # restore

        # Move all imported elements without a parent into a newly created axis system
        if containerize:

            container_name = self.available_name_like(&#34;import_container&#34;)

            c = self.new_axis(prefix + container_name)

            for name in imported_element_names:

                node = self[name]

                if not node.manager:
                    if not isinstance(node, NodeWithParent):
                        continue

                    if node.parent is None:
                        node.change_parent_to(c)

            return c

        return None

    def copy(self):
        &#34;&#34;&#34;Creates a full and independent copy of the scene and returns it.

        Example:
            s = Scene()
            c = s.copy()
            c.new_axis(&#39;only in c&#39;)

        &#34;&#34;&#34;

        c = Scene()
        c.import_scene(self, containerize=False)
        return c

    # =================== DYNAMICS ==================

    def dynamics_M(self, delta=1e-6):
        &#34;&#34;&#34;Returns the mass matrix of the scene&#34;&#34;&#34;
        self.update()

        return self._vfc.M(delta)

    def dynamics_K(self, delta=1e-6):
        &#34;&#34;&#34;Returns the stiffness matrix of the scene for a perturbation of delta

        A component is positive if a displacement introduces an reaction force in the opposite direction.
        or:
        A component is positive if a positive force is needed to introduce a positive displacement.
        &#34;&#34;&#34;
        self.update()

        return -self._vfc.K(delta)

    def dynamics_nodes(self):
        &#34;&#34;&#34;Returns a list of nodes associated with the rows/columns of M and K&#34;&#34;&#34;
        self.update()
        nodes = self._vfc.get_dof_elements()

        node_names = [n.name for n in self._nodes]

        r = []
        for n in nodes:
            if n.name in node_names:
                r.append(self[n.name])
            else:
                r.append(None)

        return r

    def dynamics_modes(self):
        &#34;&#34;&#34;Returns a list of modes (0=x ... 5=rotation z) associated with the rows/columns of M and K&#34;&#34;&#34;
        self.update()
        return self._vfc.get_dof_modes()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Scene.current_manager"><code class="name">var <span class="ident">current_manager</span></code></dt>
<dd>
<div class="desc"><p>Setting this to an instance of a Manager allows nodes with that manager to be changed</p></div>
</dd>
<dt id="DAVE.scene.Scene.resources_paths"><code class="name">var <span class="ident">resources_paths</span></code></dt>
<dd>
<div class="desc"><p>A list of paths where to look for resources such as .obj files. Priority is given to paths earlier in the list.</p></div>
</dd>
<dt id="DAVE.scene.Scene.static_tolerance"><code class="name">var <span class="ident">static_tolerance</span></code></dt>
<dd>
<div class="desc"><p>Desired tolerance when solving statics</p></div>
</dd>
<dt id="DAVE.scene.Scene.verbose"><code class="name">var <span class="ident">verbose</span></code></dt>
<dd>
<div class="desc"><p>Report actions using print()</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.Scene.assert_unique_names"><code class="name flex">
<span>def <span class="ident">assert_unique_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Asserts that all names are unique</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_unique_names(self):
    &#34;&#34;&#34;Asserts that all names are unique&#34;&#34;&#34;
    names = [n.name for n in self._nodes]
    unique_names = set(names)

    if len(unique_names) != len(names):
        previous_name = &#34;&#34;
        names.sort()
        duplicates = &#34;&#34;
        for name in names:
            if name == previous_name:
                print(f&#34;Duplicate: {name}&#34;)
                duplicates += name + &#34; &#34;

                for n in self._nodes:
                    if n.name == name:
                        print(n)

            previous_name = name
        raise ValueError(f&#34;Duplicate names exist: &#34; + duplicates)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.available_name_like"><code class="name flex">
<span>def <span class="ident">available_name_like</span></span>(<span>self, like)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an available name like the one given, for example Axis23</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def available_name_like(self, like):
    &#34;&#34;&#34;Returns an available name like the one given, for example Axis23&#34;&#34;&#34;
    if self.name_available(like):
        return like
    counter = 1
    while True:
        name = like + &#34;_&#34; + str(counter)
        if self.name_available(name):
            return name
        counter += 1</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes all nodes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;Deletes all nodes&#34;&#34;&#34;

    self._nodes = []
    del self._vfc
    self._vfc = pyo3d.Scene()</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a full and independent copy of the scene and returns it.</p>
<h2 id="example">Example</h2>
<p>s = Scene()
c = s.copy()
c.new_axis('only in c')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;Creates a full and independent copy of the scene and returns it.

    Example:
        s = Scene()
        c = s.copy()
        c.new_axis(&#39;only in c&#39;)

    &#34;&#34;&#34;

    c = Scene()
    c.import_scene(self, containerize=False)
    return c</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the given node from the scene as well as all nodes depending on it.</p>
<p>See Also:
dissolve</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, node):
    &#34;&#34;&#34;Deletes the given node from the scene as well as all nodes depending on it.

    See Also:
        dissolve
    &#34;&#34;&#34;

    if isinstance(node, str):
        node = self[node]

    if node not in self._nodes:
        raise ValueError(
            &#34;Can not delete node because it is not a node of this scene&#34;
        )

    if isinstance(node, Manager):
        node.delete()
        # self._nodes.remove(node)
        # return &lt;-- do not return

    depending_nodes = self.nodes_depending_on(node)
    depending_nodes.extend([n.name for n in node.observers])

    if node._manager:  # node, delete its manager
        # print(&#39;Deleting manager&#39;)
        self.delete(node._manager)
        if node in self._nodes:
            self.delete(node)  # node may have been deleted by the manager

    else:
        self._print(
            &#34;Deleting {} [{}]&#34;.format(
                node.name, str(type(node)).split(&#34;.&#34;)[-1][:-2]
            )
        )

        # First delete the dependencies
        for d in depending_nodes:
            if not self.name_available(d):  # element is still here
                self.delete(d)

        # then remove the vtk node itself
        # self._print(&#39;removing vfc node&#39;)
        node._delete_vfc()
        self._nodes.remove(node)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.dissolve"><code class="name flex">
<span>def <span class="ident">dissolve</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Attempts to delete the given node without affecting the rest of the model.</p>
<ol>
<li>Look for nodes that have this node as parent</li>
<li>Attach those nodes to the parent of this node.</li>
<li>Delete this node.</li>
</ol>
<p>There are many situations in which this will fail because an it is impossible to dissolve
the element. For example a poi can only be dissolved when nothing is attached to it.</p>
<p>For now this function only works on AXIS</p>
<h1 id="todo-add-managers-just-release-management">TODO: Add managers - just release management</h1></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dissolve(self, node):
    &#34;&#34;&#34;Attempts to delete the given node without affecting the rest of the model.

    1. Look for nodes that have this node as parent
    2. Attach those nodes to the parent of this node.
    3. Delete this node.

    There are many situations in which this will fail because an it is impossible to dissolve
    the element. For example a poi can only be dissolved when nothing is attached to it.

    For now this function only works on AXIS

    #TODO: Add managers - just release management

    &#34;&#34;&#34;

    if isinstance(node, str):
        node = self[node]

    ok = False
    if isinstance(node, Manager):

        if isinstance(node, Axis):
            p = self.new_axis(node.name + &#39;_dissolved&#39;)
        else:
            p = None

        for d in self.nodes_managed_by(node):
            with ClaimManagement(self,node):
                if node in d.observers:
                    d.observers.remove(node)
                d.manager = None

                if isinstance(d, NodeWithParent):
                    if d.parent == node:
                        d.parent = p

        ok = True

    if isinstance(node, Axis):
        for d in self.nodes_depending_on(node):
            self[d].change_parent_to(node.parent)
        ok = True

    if not ok:
        raise TypeError(&#34;Only nodes of type Axis and Manager can be dissolved at this moment&#34;)

    self._nodes.remove(node)  # do not call delete as that will fail on managers</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.dynamics_K"><code class="name flex">
<span>def <span class="ident">dynamics_K</span></span>(<span>self, delta=1e-06)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stiffness matrix of the scene for a perturbation of delta</p>
<p>A component is positive if a displacement introduces an reaction force in the opposite direction.
or:
A component is positive if a positive force is needed to introduce a positive displacement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dynamics_K(self, delta=1e-6):
    &#34;&#34;&#34;Returns the stiffness matrix of the scene for a perturbation of delta

    A component is positive if a displacement introduces an reaction force in the opposite direction.
    or:
    A component is positive if a positive force is needed to introduce a positive displacement.
    &#34;&#34;&#34;
    self.update()

    return -self._vfc.K(delta)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.dynamics_M"><code class="name flex">
<span>def <span class="ident">dynamics_M</span></span>(<span>self, delta=1e-06)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the mass matrix of the scene</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dynamics_M(self, delta=1e-6):
    &#34;&#34;&#34;Returns the mass matrix of the scene&#34;&#34;&#34;
    self.update()

    return self._vfc.M(delta)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.dynamics_modes"><code class="name flex">
<span>def <span class="ident">dynamics_modes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of modes (0=x &hellip; 5=rotation z) associated with the rows/columns of M and K</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dynamics_modes(self):
    &#34;&#34;&#34;Returns a list of modes (0=x ... 5=rotation z) associated with the rows/columns of M and K&#34;&#34;&#34;
    self.update()
    return self._vfc.get_dof_modes()</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.dynamics_nodes"><code class="name flex">
<span>def <span class="ident">dynamics_nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of nodes associated with the rows/columns of M and K</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dynamics_nodes(self):
    &#34;&#34;&#34;Returns a list of nodes associated with the rows/columns of M and K&#34;&#34;&#34;
    self.update()
    nodes = self._vfc.get_dof_elements()

    node_names = [n.name for n in self._nodes]

    r = []
    for n in nodes:
        if n.name in node_names:
            r.append(self[n.name])
        else:
            r.append(None)

    return r</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.get_resource_list"><code class="name flex">
<span>def <span class="ident">get_resource_list</span></span>(<span>self, extension)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of all file-paths (strings) given extension in any of the resource-paths</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_resource_list(self, extension):
    &#34;&#34;&#34;Returns a list of all file-paths (strings) given extension in any of the resource-paths&#34;&#34;&#34;

    r = []

    for dir in self.resources_paths:
        try:
            files = listdir(dir)
            for file in files:
                if file.lower().endswith(extension):
                    if file not in r:
                        r.append(&#34;res: &#34; + file)
        except FileNotFoundError:
            pass

    return r</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.get_resource_path"><code class="name flex">
<span>def <span class="ident">get_resource_path</span></span>(<span>self, url) ->Â pathlib.Path</span>
</code></dt>
<dd>
<div class="desc"><p>Resolves the path on disk for resource url. Urls statring with res: result in a file from the resources system.</p>
<p>Looks for a file with "name" in the specified resource-paths and returns the full path to the the first one
that is found.
If name is a full path to an existing file, then that is returned.</p>
<p>See Also:
resource_paths</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Full path to resource</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileExistsError if resource is not found</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_resource_path(self, url) -&gt; Path:
    &#34;&#34;&#34;Resolves the path on disk for resource url. Urls statring with res: result in a file from the resources system.

    Looks for a file with &#34;name&#34; in the specified resource-paths and returns the full path to the the first one
    that is found.
    If name is a full path to an existing file, then that is returned.

    See Also:
        resource_paths


    Returns:
        Full path to resource

    Raises:
        FileExistsError if resource is not found

    &#34;&#34;&#34;

    # warning and work-around for backwards compatibility
    # filenames without a path get res: in front of it
    try:
        if isinstance(url, Path):
            test = str(url)
        else:
            test = url

        if not test.startswith(&#34;res:&#34;):
            test = Path(test)
            if str(test.parent) == &#34;.&#34;:
                # from warnings import warn
                #
                # warn(
                #     f&#39;Resources should start with res: --&gt; fixing &#34;{url}&#34; to &#34;res: {url}&#34;&#39;
                # )
                url = &#34;res: &#34; + str(test)
    except:
        pass

    if isinstance(url, Path):
        file = url
    elif isinstance(url, str):
        if not url.startswith(&#34;res:&#34;):
            file = Path(url)
        else:
            # we have a string starting with &#39;res:&#39;
            filename = url[4:].strip()

            for res in self.resources_paths:
                p = Path(res)

                file = p / filename
                if isfile(file):
                    return file

            # prepare feedback for error
            ext = str(url).split(&#34;.&#34;)[-1]  # everything after the last .

            print(&#34;Resource folders:&#34;)
            for res in self.resources_paths:
                print(str(res))


            print(
                &#34;The following resources with extension {} are available with &#34;.format(
                    ext
                )
            )
            available = self.get_resource_list(ext)
            for a in available:
                print(a)
            raise FileExistsError(
                &#39;Resource &#34;{}&#34; not found in resource paths. A list with available resources with this extension is printed above this error&#39;.format(
                    url
                )
            )
    else:
        raise ValueError(
            f&#34;Provided url shall be a Path or a string, not a {type(url)}&#34;
        )

    if file.exists():
        return file

    raise FileExistsError(
        &#39;File &#34;{}&#34; not found.\nHint: To obtain a resource put res: in front of the name.&#39;.format(
            url
        )
    )</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.give_python_code"><code class="name flex">
<span>def <span class="ident">give_python_code</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the python code that rebuilds the scene and elements in its current state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def give_python_code(self):
    &#34;&#34;&#34;Generates the python code that rebuilds the scene and elements in its current state.&#34;&#34;&#34;

    import datetime
    import getpass

    self.sort_nodes_by_dependency()

    code = &#34;# auto generated pyhton code&#34;
    try:
        code += &#34;\n# By {}&#34;.format(getpass.getuser())
    except:
        code += &#34;\n# By an unknown&#34;

    code += &#34;\n# Time: {} UTC&#34;.format(str(datetime.datetime.now()).split(&#34;.&#34;)[0])

    code += &#34;\n\n# To be able to distinguish the important number (eg: fixed positions) from&#34;
    code += &#34;\n# non-important numbers (eg: a position that is solved by the static solver) we use a dummy-function called &#39;solved&#39;.&#34;
    code += &#34;\n# For anything written as solved(number) that actual number does not influence the static solution&#34;
    code += &#34;\ndef solved(number):\n    return number\n&#34;

    for n in self._nodes:

        if n._manager is None:
            # print(f&#39;code for {n.name}&#39;)
            code += &#34;\n&#34; + n.give_python_code()
        else:
            if n._manager.creates(n):
                pass
            else:
                code += &#34;\n&#34; + n.give_python_code()

            # print(f&#39;skipping {n.name} &#39;)

    # store the visibility code separately

    for n in self._nodes:
        if not n.visible:
            code += f&#34;\ns[&#39;{n.name}&#39;].visible = False&#34;  # only report is not the default value

    return code</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.goal_seek"><code class="name flex">
<span>def <span class="ident">goal_seek</span></span>(<span>self, evaluate, target, change_node, change_property, bracket=None, tol=0.001)</span>
</code></dt>
<dd>
<div class="desc"><p>goal_seek</p>
<p>Goal seek is the classic goal-seek. It changes a single property of a single node in order to get
some property of some node to a specified value. Just like excel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>evaluate</code></strong> :&ensp;<code>code to be evaluated to yield the value that is solved for. Eg: s['poi'].fx Scene is abbiviated as "s"</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>target</code></strong> :&ensp;<code>number</code></dt>
<dd>
<p>target value for that property</p>
</dd>
<dt>change_node(Node or str):
node to be adjusted</dt>
<dt><strong><code>change_property</code></strong> :&ensp;<code>str</code></dt>
<dd>property of that node to be adjusted</dd>
</dl>
<p>range(optional)
: specify the possible search-interval</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if successful, False otherwise.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Change the y-position of the cog of a rigid body ('Barge')
in order to obtain zero roll (rx)</p>
<pre><code class="language-python">&gt;&gt;&gt; s.goal_seek(&quot;s['Barge'].fx&quot;,0,'Barge','cogy')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goal_seek(
    self, evaluate, target, change_node, change_property, bracket=None, tol=1e-3
):
    &#34;&#34;&#34;goal_seek

    Goal seek is the classic goal-seek. It changes a single property of a single node in order to get
    some property of some node to a specified value. Just like excel.

    Args:
        evaluate : code to be evaluated to yield the value that is solved for. Eg: s[&#39;poi&#39;].fx Scene is abbiviated as &#34;s&#34;
        target (number):       target value for that property
        change_node(Node or str):  node to be adjusted
        change_property (str): property of that node to be adjusted
        range(optional)  : specify the possible search-interval

    Returns:
        bool: True if successful, False otherwise.

    Examples:
        Change the y-position of the cog of a rigid body (&#39;Barge&#39;)  in order to obtain zero roll (rx)
        &gt;&gt;&gt; s.goal_seek(&#34;s[&#39;Barge&#39;].fx&#34;,0,&#39;Barge&#39;,&#39;cogy&#39;)

    &#34;&#34;&#34;
    s = self

    change_node = self._node_from_node_or_str(change_node)

    # check that the attributes exist and are single numbers
    test = eval(evaluate)

    try:
        float(test)
    except:
        raise ValueError(&#34;Evaluation of {} does not result in a float&#34;)

    self._print(
        &#34;Attempting to evaluate {} to {} (now {})&#34;.format(evaluate, target, test)
    )

    initial = getattr(change_node, change_property)
    self._print(
        &#34;By changing the value of {}.{} (now {})&#34;.format(
            change_node.name, change_property, initial
        )
    )

    def set_and_get(x):
        setattr(change_node, change_property, x)
        self.solve_statics(silent=True)
        s = self
        result = eval(evaluate)
        self._print(&#34;setting {} results in {}&#34;.format(x, result))
        return result - target

    from scipy.optimize import root_scalar

    x0 = initial
    x1 = initial + 0.0001

    if bracket is not None:
        res = root_scalar(set_and_get, x0=x0, x1=x1, bracket=bracket, xtol=tol)
    else:
        res = root_scalar(set_and_get, x0=x0, x1=x1, xtol=tol)

    self._print(res)

    # evaluate result
    final_value = eval(evaluate)
    if abs(final_value - target) &gt; 1e-3:
        raise ValueError(
            &#34;Target not reached. Target was {}, reached value is {}&#34;.format(
                target, final_value
            )
        )

    return True</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.import_scene"><code class="name flex">
<span>def <span class="ident">import_scene</span></span>(<span>self, other, prefix='', containerize=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy-paste all nodes of scene "other" into current scene.</p>
<p>To avoid double names it is recommended to use a prefix. This prefix will be added to all element names.</p>
<h2 id="returns">Returns</h2>
<p>Contained (Axis-type Node) : if the imported scene is containerized then a reference to the created container is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_scene(self, other, prefix=&#34;&#34;, containerize=True):
    &#34;&#34;&#34;Copy-paste all nodes of scene &#34;other&#34; into current scene.

    To avoid double names it is recommended to use a prefix. This prefix will be added to all element names.

    Returns:
        Contained (Axis-type Node) : if the imported scene is containerized then a reference to the created container is returned.
    &#34;&#34;&#34;

    if isinstance(other, Path):
        other = str(other)

    if isinstance(other, str):
        other = Scene(other)

    if not isinstance(other, Scene):
        raise TypeError(&#34;Other should be a Scene but is a &#34; + str(type(other)))

    old_prefix = self._name_prefix
    imported_element_names = []

    for n in other._nodes:
        imported_element_names.append(prefix + n.name)

    # check for double names

    for new_node_name in imported_element_names:
        if not self.name_available(new_node_name):
            raise NameError(
                &#39;An element with name &#34;{}&#34; is already present. Please use a prefix to avoid double names&#39;.format(
                    new_node_name
                )
            )

    self._name_prefix = prefix

    code = other.give_python_code()

    self.run_code(code)

    self._name_prefix = old_prefix  # restore

    # Move all imported elements without a parent into a newly created axis system
    if containerize:

        container_name = self.available_name_like(&#34;import_container&#34;)

        c = self.new_axis(prefix + container_name)

        for name in imported_element_names:

            node = self[name]

            if not node.manager:
                if not isinstance(node, NodeWithParent):
                    continue

                if node.parent is None:
                    node.change_parent_to(c)

        return c

    return None</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.load_scene"><code class="name flex">
<span>def <span class="ident">load_scene</span></span>(<span>self, filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads the contents of filename into the current scene.</p>
<p>This function is typically used on an empty scene.</p>
<p>Filename is appended with .dave if needed.
File is searched for in the resource-paths.</p>
<p>See also: import scene</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_scene(self, filename=None):
    &#34;&#34;&#34;Loads the contents of filename into the current scene.

    This function is typically used on an empty scene.

    Filename is appended with .dave if needed.
    File is searched for in the resource-paths.

    See also: import scene&#34;&#34;&#34;

    if filename is None:
        raise Exception(&#34;Please provide a file-name&#34;)

    try:
        filename = self.get_resource_path(filename)
    except:
        if not str(filename).endswith(&#34;.dave&#34;):
            filename = Path(str(filename) + &#34;.dave&#34;)

    print(&#34;Loading {}&#34;.format(filename))

    f = open(file=filename, mode=&#34;r&#34;)
    code = &#34;&#34;
    for line in f:
        code += line + &#34;\n&#34;

    self.run_code(code)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.name_available"><code class="name flex">
<span>def <span class="ident">name_available</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the name is still available</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def name_available(self, name):
    &#34;&#34;&#34;Returns True if the name is still available&#34;&#34;&#34;
    names = [n.name for n in self._nodes]
    names.extend(self._vfc.names)
    return not (name in names)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_axis"><code class="name flex">
<span>def <span class="ident">new_axis</span></span>(<span>self, name, parent=None, position=None, rotation=None, inertia=None, inertia_radii=None, fixed=True) ->Â <a title="DAVE.scene.Axis" href="#DAVE.scene.Axis">Axis</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <em>axis</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>optional, name of the parent of the node</dd>
<dt><strong><code>position</code></strong></dt>
<dd>optional, position for the node (x,y,z)</dd>
<dt><strong><code>rotation</code></strong></dt>
<dd>optional, rotation for the node (rx,ry,rz)</dd>
</dl>
<p>fixed [True]: optional, determines whether the axis is fixed [True] or free [False]. May also be a sequence of 6 booleans.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference to newly created axis</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_axis(
    self,
    name,
    parent=None,
    position=None,
    rotation=None,
    inertia=None,
    inertia_radii=None,
    fixed=True,
) -&gt; Axis:
    &#34;&#34;&#34;Creates a new *axis* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        parent: optional, name of the parent of the node
        position: optional, position for the node (x,y,z)
        rotation: optional, rotation for the node (rx,ry,rz)
        fixed [True]: optional, determines whether the axis is fixed [True] or free [False]. May also be a sequence of 6 booleans.

    Returns:
        Reference to newly created axis

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    assertValidName(name)
    self._verify_name_available(name)
    b = self._parent_from_node(parent)

    if position is not None:
        assert3f(position, &#34;Position &#34;)
    if rotation is not None:
        assert3f(rotation, &#34;Rotation &#34;)

    if inertia is not None:
        assert1f_positive_or_zero(inertia, &#34;inertia &#34;)

    if inertia_radii is not None:
        assert3f_positive(inertia_radii, &#34;Radii of inertia&#34;)
        assert inertia is not None, ValueError(
            &#34;Can not set radii of gyration without specifying inertia&#34;
        )

    if not isinstance(fixed, bool):
        if len(fixed) != 6:
            raise Exception(
                &#39;&#34;fixed&#34; parameter should either be True/False or a 6x bool sequence such as (True,True,False,False,True,False)&#39;
            )

    # then create
    a = self._vfc.new_axis(name)

    new_node = Axis(self, a)

    # and set properties
    if b is not None:
        new_node.parent = b
    if position is not None:
        new_node.position = position
    if rotation is not None:
        new_node.rotation = rotation
    if inertia is not None:
        new_node.inertia = inertia
    if inertia_radii is not None:
        new_node.inertia_radii = inertia_radii

    if isinstance(fixed, bool):
        if fixed:
            new_node.set_fixed()
        else:
            new_node.set_free()
    else:
        new_node.fixed = fixed

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_ballastsystem"><code class="name flex">
<span>def <span class="ident">new_ballastsystem</span></span>(<span>self, name, parent:Â <a title="DAVE.scene.Axis" href="#DAVE.scene.Axis">Axis</a>) ->Â <a title="DAVE.scene.BallastSystem" href="#DAVE.scene.BallastSystem">BallastSystem</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <em>rigidbody</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>name of the parent of the ballast system (ie: the vessel axis system)</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>scene.new_ballastsystem("cheetah_ballast", parent="Cheetah")</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference to newly created <a title="DAVE.scene.BallastSystem" href="#DAVE.scene.BallastSystem">BallastSystem</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_ballastsystem(self, name, parent: Axis) -&gt; BallastSystem:
    &#34;&#34;&#34;Creates a new *rigidbody* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        parent: name of the parent of the ballast system (ie: the vessel axis system)

    Examples:
        scene.new_ballastsystem(&#34;cheetah_ballast&#34;, parent=&#34;Cheetah&#34;)

    Returns:
        Reference to newly created BallastSystem

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # check input
    assertValidName(name)
    self._verify_name_available(name)
    b = self._parent_from_node(parent)

    parent = self._parent_from_node(parent)  # handles verification of type as well

    # make elements
    r = BallastSystem(self, parent)
    r.name = name

    self._nodes.append(r)
    return r</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_beam"><code class="name flex">
<span>def <span class="ident">new_beam</span></span>(<span>self, name, nodeA, nodeB, EIy=0, EIz=0, GIp=0, EA=0, L=None, mass=0, n_segments=1, tension_only=False) ->Â <a title="DAVE.scene.Beam" href="#DAVE.scene.Beam">Beam</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <em>beam</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>nodeA</code></strong></dt>
<dd>First axis system [Axis]</dd>
<dt><strong><code>nodeB</code></strong></dt>
<dd>Second axis system [Axis]</dd>
</dl>
<p>All stiffness terms default to 0
The length defaults to the distance between nodeA and nodeB
See :py:class:<code>LinearBeam</code> for details</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference to newly created beam</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_beam(
    self,
    name,
    nodeA,
    nodeB,
    EIy=0,
    EIz=0,
    GIp=0,
    EA=0,
    L=None,
    mass=0,
    n_segments=1,
    tension_only=False,
) -&gt; Beam:
    &#34;&#34;&#34;Creates a new *beam* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        nodeA: First axis system [Axis]
        nodeB: Second axis system [Axis]

        All stiffness terms default to 0
        The length defaults to the distance between nodeA and nodeB


    See :py:class:`LinearBeam` for details

    Returns:
        Reference to newly created beam

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    assertValidName(name)
    self._verify_name_available(name)
    m = self._parent_from_node(nodeA)
    s = self._parent_from_node(nodeB)

    if L is None:
        L = np.linalg.norm(
            np.array(m.global_position) - np.array(s.global_position)
        )
    else:
        if L &lt;= 0:
            raise ValueError(&#34;L should be &gt; 0 as stiffness is defined per length.&#34;)

    assert1f_positive_or_zero(EIy, &#34;EIy should be &gt;= 0&#34;)
    assert1f_positive_or_zero(EIz, &#34;EIz should be &gt;= 0&#34;)
    assert1f_positive_or_zero(GIp, &#34;GIp should be &gt;= 0&#34;)
    assert1f_positive_or_zero(EA, &#34;EA should be &gt;= 0&#34;)
    assertBool(tension_only, &#34;tension_only should be bool&#34;)
    assert1f(mass, &#34;Mass shall be a number&#34;)
    n_segments = int(round(n_segments))

    # then create
    a = self._vfc.new_linearbeam(name)

    new_node = Beam(self, a)

    # and set properties
    new_node.nodeA = m
    new_node.nodeB = s
    new_node.EIy = EIy
    new_node.EIz = EIz
    new_node.GIp = GIp
    new_node.EA = EA
    new_node.L = L
    new_node.mass = mass
    new_node.n_segments = n_segments
    new_node.tension_only = tension_only

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_buoyancy"><code class="name flex">
<span>def <span class="ident">new_buoyancy</span></span>(<span>self, name, parent=None, density=1.025) ->Â <a title="DAVE.scene.Buoyancy" href="#DAVE.scene.Buoyancy">Buoyancy</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <em>buoyancy</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>optional, name of the parent of the node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference to newly created buoyancy</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_buoyancy(self, name, parent=None, density=1.025) -&gt; Buoyancy:
    &#34;&#34;&#34;Creates a new *buoyancy* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        parent: optional, name of the parent of the node


    Returns:
        Reference to newly created buoyancy

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    assertValidName(name)
    self._verify_name_available(name)
    b = self._parent_from_node(parent)

    if b is None:
        raise ValueError(&#34;A valid parent must be defined for a Buoyancy node&#34;)

    assert1f_positive_or_zero(density, &#34;density&#34;)

    # then create
    a = self._vfc.new_buoyancy(name)
    new_node = Buoyancy(self, a)

    # and set properties
    if b is not None:
        new_node.parent = b

    new_node.density = density

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_cable"><code class="name flex">
<span>def <span class="ident">new_cable</span></span>(<span>self, name, endA, endB, length=-1, EA=0, diameter=0, sheaves=None) ->Â <a title="DAVE.scene.Cable" href="#DAVE.scene.Cable">Cable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <em>cable</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>endA</code></strong> :&ensp;<code>A Poi element to connect the first end</code> of <code>the cable to</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>endB</code></strong> :&ensp;<code>A Poi element to connect the other end</code> of <code>the cable to</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>length [-1] : un-stretched length of the cable in m; default [-1] create a cable with the current distance between the endpoints A and B
EA [0] : stiffness of the cable in kN/m; default</p>
<dl>
<dt><strong><code>sheaves</code></strong> :&ensp;<code>[optional] A list</code> of <code>pois, these are sheaves that the cable runs over. Defined from endA to endB</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>scene.new_cable('cable_name' endA='poi_start', endB = 'poi_end')
# minimal use</p>
<p>scene.new_cable('cable_name', length=50, EA=1000, endA=poi_start, endB = poi_end, sheaves=[sheave1, sheave2])</p>
<p>scene.new_cable('cable_name', length=50, EA=1000, endA='poi_start', endB = 'poi_end', sheaves=['single_sheave']) # also a single sheave needs to be provided as a list</p>
<h2 id="notes">Notes</h2>
<p>The default options for length and EA can be used to measure distances between points</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference to newly created <a title="DAVE.scene.Cable" href="#DAVE.scene.Cable">Cable</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_cable(
    self, name, endA, endB, length=-1, EA=0, diameter=0, sheaves=None
) -&gt; Cable:
    &#34;&#34;&#34;Creates a new *cable* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        endA : A Poi element to connect the first end of the cable to
        endB : A Poi element to connect the other end of the cable to
        length [-1] : un-stretched length of the cable in m; default [-1] create a cable with the current distance between the endpoints A and B
        EA [0] : stiffness of the cable in kN/m; default

        sheaves : [optional] A list of pois, these are sheaves that the cable runs over. Defined from endA to endB

    Examples:

        scene.new_cable(&#39;cable_name&#39; endA=&#39;poi_start&#39;, endB = &#39;poi_end&#39;)  # minimal use

        scene.new_cable(&#39;cable_name&#39;, length=50, EA=1000, endA=poi_start, endB = poi_end, sheaves=[sheave1, sheave2])

        scene.new_cable(&#39;cable_name&#39;, length=50, EA=1000, endA=&#39;poi_start&#39;, endB = &#39;poi_end&#39;, sheaves=[&#39;single_sheave&#39;]) # also a single sheave needs to be provided as a list

    Notes:
        The default options for length and EA can be used to measure distances between points

    Returns:
        Reference to newly created Cable

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    assertValidName(name)
    self._verify_name_available(name)
    assert1f(length, &#34;length&#34;)
    assert1f(EA, &#34;EA&#34;)

    endA = self._poi_or_sheave_from_node(endA)
    endB = self._poi_or_sheave_from_node(endB)

    pois = [endA]
    if sheaves is not None:

        if isinstance(sheaves, Point):  # single sheave as poi or string
            sheaves = [sheaves]

        if isinstance(sheaves, Circle):  # single sheave as poi or string
            sheaves = [sheaves]

        if isinstance(sheaves, str):
            sheaves = [sheaves]

        for s in sheaves:
            # s may be a poi or a sheave
            pois.append(self._poi_or_sheave_from_node(s))

    pois.append(endB)

    # default options
    if length &gt; -1:
        if length &lt; 1e-9:
            raise Exception(&#34;Length should be more than 0&#34;)

    if EA &lt; 0:
        raise Exception(&#34;EA should be more than 0&#34;)

    assert1f(diameter, &#34;Diameter should be a number &gt;= 0&#34;)

    if diameter &lt; 0:
        raise Exception(&#34;Diameter should be &gt;= 0&#34;)

    # then create
    a = self._vfc.new_cable(name)
    new_node = Cable(self, a)
    if length &gt; 0:
        new_node.length = length
    new_node.EA = EA
    new_node.diameter = diameter

    new_node.connections = pois

    # and add to the scene
    self._nodes.append(new_node)

    if length &lt; 0:
        new_node.length = 1e-8
        self._vfc.state_update()

        new_length = new_node.stretch + 1e-8

        if new_length &gt; 0:
            new_node.length = new_length
        else:
            # is is possible that all nodes are at the same location which means the total length becomes 0
            self.delete(new_node.name)
            raise ValueError(
                &#34;No lengh has been supplied and all connection points are at the same location - unable to determine a non-zero default length. Please supply a length&#34;
            )

    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_circle"><code class="name flex">
<span>def <span class="ident">new_circle</span></span>(<span>self, name, parent, axis, radius=0.0) ->Â <a title="DAVE.scene.Circle" href="#DAVE.scene.Circle">Circle</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <em>sheave</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>name of the parent of the node [Poi]</dd>
<dt><strong><code>axis</code></strong></dt>
<dd>direction of the axis of rotation (x,y,z)</dd>
<dt><strong><code>radius</code></strong></dt>
<dd>optional, radius of the sheave</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference to newly created sheave</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_circle(self, name, parent, axis, radius=0.0) -&gt; Circle:
    &#34;&#34;&#34;Creates a new *sheave* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        parent: name of the parent of the node [Poi]
        axis: direction of the axis of rotation (x,y,z)
        radius: optional, radius of the sheave


    Returns:
        Reference to newly created sheave

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    assertValidName(name)
    self._verify_name_available(name)
    b = self._poi_from_node(parent)

    assert3f(axis, &#34;Axis of rotation &#34;)

    assert1f(radius, &#34;Radius of sheave&#34;)

    # then create
    a = self._vfc.new_sheave(name)

    new_node = Circle(self, a)

    # and set properties
    new_node.parent = b
    new_node.axis = axis
    new_node.radius = radius

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_connector2d"><code class="name flex">
<span>def <span class="ident">new_connector2d</span></span>(<span>self, name, nodeA, nodeB, k_linear=0, k_angular=0) ->Â <a title="DAVE.scene.Connector2d" href="#DAVE.scene.Connector2d">Connector2d</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <em>new_connector2d</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>nodeB</code></strong></dt>
<dd>First axis system [Axis]</dd>
<dt><strong><code>nodeA</code></strong></dt>
<dd>Second axis system [Axis]</dd>
<dt><strong><code>k_linear</code></strong> :&ensp;<code>linear stiffness in kN/m</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>k_angular</code></strong> :&ensp;<code>angular stiffness in kN*m / rad</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference to newly created connector2d</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_connector2d(
    self, name, nodeA, nodeB, k_linear=0, k_angular=0
) -&gt; Connector2d:
    &#34;&#34;&#34;Creates a new *new_connector2d* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        nodeB: First axis system [Axis]
        nodeA: Second axis system [Axis]

        k_linear : linear stiffness in kN/m
        k_angular : angular stiffness in kN*m / rad

    Returns:
        Reference to newly created connector2d

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    assertValidName(name)
    self._verify_name_available(name)
    m = self._parent_from_node(nodeA)
    s = self._parent_from_node(nodeB)

    assert1f(k_linear, &#34;Linear stiffness&#34;)
    assert1f(k_angular, &#34;Angular stiffness&#34;)

    # then create
    a = self._vfc.new_connector2d(name)

    new_node = Connector2d(self, a)

    # and set properties
    new_node.nodeA = m
    new_node.nodeB = s
    new_node.k_linear = k_linear
    new_node.k_angular = k_angular

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_contactball"><code class="name flex">
<span>def <span class="ident">new_contactball</span></span>(<span>self, name, parent=None, radius=1, k=9999, meshes=None) ->Â <a title="DAVE.scene.ContactBall" href="#DAVE.scene.ContactBall">ContactBall</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <em>force</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>name of the parent of the node [Poi]</dd>
<dt><strong><code>force</code></strong></dt>
<dd>optional, global force on the node (x,y,z)</dd>
<dt><strong><code>moment</code></strong></dt>
<dd>optional, global force on the node (x,y,z)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference to newly created force</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_contactball(
    self, name, parent=None, radius=1, k=9999, meshes=None
) -&gt; ContactBall:
    &#34;&#34;&#34;Creates a new *force* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        parent: name of the parent of the node [Poi]
        force: optional, global force on the node (x,y,z)
        moment: optional, global force on the node (x,y,z)


    Returns:
        Reference to newly created force

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    assertValidName(name)
    self._verify_name_available(name)
    b = self._poi_from_node(parent)

    assert1f_positive_or_zero(radius, &#34;Radius &#34;)
    assert1f_positive_or_zero(k, &#34;k &#34;)

    if meshes is not None:
        meshes = make_iterable(meshes)
        for mesh in meshes:
            test = self._node_from_node(mesh, ContactMesh)

    # then create
    a = self._vfc.new_contactball(name)

    new_node = ContactBall(self, a)

    # and set properties
    if b is not None:
        new_node.parent = b
    if k is not None:
        new_node.k = k
    if radius is not None:
        new_node.radius = radius

    if meshes is not None:
        new_node.meshes = meshes

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_contactmesh"><code class="name flex">
<span>def <span class="ident">new_contactmesh</span></span>(<span>self, name, parent=None) ->Â <a title="DAVE.scene.ContactMesh" href="#DAVE.scene.ContactMesh">ContactMesh</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <em>contactmesh</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>optional, name of the parent of the node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference to newly created contact mesh</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_contactmesh(self, name, parent=None) -&gt; ContactMesh:
    &#34;&#34;&#34;Creates a new *contactmesh* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        parent: optional, name of the parent of the node

    Returns:
        Reference to newly created contact mesh

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    assertValidName(name)
    self._verify_name_available(name)
    b = self._parent_from_node(parent)

    # then create
    a = self._vfc.new_contactmesh(name)
    new_node = ContactMesh(self, a)

    # and set properties
    if b is not None:
        new_node.parent = b

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_force"><code class="name flex">
<span>def <span class="ident">new_force</span></span>(<span>self, name, parent=None, force=None, moment=None) ->Â <a title="DAVE.scene.Force" href="#DAVE.scene.Force">Force</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <em>force</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>name of the parent of the node [Poi]</dd>
<dt><strong><code>force</code></strong></dt>
<dd>optional, global force on the node (x,y,z)</dd>
<dt><strong><code>moment</code></strong></dt>
<dd>optional, global force on the node (x,y,z)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference to newly created force</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_force(self, name, parent=None, force=None, moment=None) -&gt; Force:
    &#34;&#34;&#34;Creates a new *force* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        parent: name of the parent of the node [Poi]
        force: optional, global force on the node (x,y,z)
        moment: optional, global force on the node (x,y,z)


    Returns:
        Reference to newly created force

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    assertValidName(name)
    self._verify_name_available(name)
    b = self._poi_from_node(parent)

    if force is not None:
        assert3f(force, &#34;Force &#34;)

    if moment is not None:
        assert3f(moment, &#34;Moment &#34;)

    # then create
    a = self._vfc.new_force(name)

    new_node = Force(self, a)

    # and set properties
    if b is not None:
        new_node.parent = b
    if force is not None:
        new_node.force = force
    if moment is not None:
        new_node.moment = moment

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_geometriccontact"><code class="name flex">
<span>def <span class="ident">new_geometriccontact</span></span>(<span>self, name, child, parent, inside=False, swivel=None, rotation_on_parent=None, child_rotation=None, swivel_fixed=True, fixed_to_parent=False, child_fixed=False) ->Â <a title="DAVE.scene.GeometricContact" href="#DAVE.scene.GeometricContact">GeometricContact</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <em>new_geometriccontact</em> node and adds it to the scene.</p>
<p>Geometric contact connects two circular elements and can be used to model bar-bar connections or pin-in-hole connections.</p>
<p>By default a bar-bar connection is created between item1 and item2.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>child</code></strong> :&ensp;<code>[Sheave] will be the nodeA</code> of <code>the connection</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code>[Sheave] will be the nodeB</code> of <code>the connection</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>inside</code></strong></dt>
<dd>[False] False creates a pinpin connection. True creates a pin-hole type of connection</dd>
<dt><strong><code>swivel</code></strong></dt>
<dd>Rotation angle between the two items. Defaults to 90 for pinpin and 0 for pin-hole</dd>
<dt><strong><code>rotation_on_parent</code></strong></dt>
<dd>Angle of the connecting hinge relative to nodeA or None for default</dd>
<dt><strong><code>child_rotation</code></strong></dt>
<dd>Angle of the nodeB relative to the connecting hinge or None for default</dd>
<dt><strong><code>swivel_fixed</code></strong></dt>
<dd>Fix swivel [True]</dd>
<dt><strong><code>fixed_to_parent</code></strong></dt>
<dd>Fix connecting hinge to nodeA [False]</dd>
<dt><strong><code>child_fixed</code></strong></dt>
<dd>Fix nodeB to connecting hinge [False]</dd>
</dl>
<h2 id="note">Note</h2>
<p>For pin-hole connections there is no geometrical difference between the pin and the hole. Therefore it is not needed to specify
which is the pin and which is the hole</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference to newly created new_geometriccontact</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_geometriccontact(
    self,
    name,
    child,
    parent,
    inside=False,
    swivel=None,
    rotation_on_parent=None,
    child_rotation=None,
    swivel_fixed=True,
    fixed_to_parent=False,
    child_fixed=False,
) -&gt; GeometricContact:
    &#34;&#34;&#34;Creates a new *new_geometriccontact* node and adds it to the scene.

    Geometric contact connects two circular elements and can be used to model bar-bar connections or pin-in-hole connections.

    By default a bar-bar connection is created between item1 and item2.

    Args:
        name: Name for the node, should be unique
        child : [Sheave] will be the nodeA of the connection
        parent : [Sheave] will be the nodeB of the connection
        inside: [False] False creates a pinpin connection. True creates a pin-hole type of connection
        swivel: Rotation angle between the two items. Defaults to 90 for pinpin and 0 for pin-hole
        rotation_on_parent: Angle of the connecting hinge relative to nodeA or None for default
        child_rotation: Angle of the nodeB relative to the connecting hinge or None for default
        swivel_fixed: Fix swivel [True]
        fixed_to_parent: Fix connecting hinge to nodeA [False]
        child_fixed: Fix nodeB to connecting hinge [False]

    Note:
        For pin-hole connections there is no geometrical difference between the pin and the hole. Therefore it is not needed to specify
        which is the pin and which is the hole

    Returns:
        Reference to newly created new_geometriccontact

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    assertValidName(name)
    self._verify_name_available(name)

    name_prefix = name + vfc.MANAGED_NODE_IDENTIFIER
    postfixes = [
        &#34;_axis_on_parent&#34;,
        &#34;_pin_hole_connection&#34;,
        &#34;_axis_on_child&#34;,
        &#34;_connection_axial_rotation&#34;,
    ]

    for pf in postfixes:
        self._verify_name_available(name_prefix + pf)

    child = self._sheave_from_node(child)
    parent = self._sheave_from_node(parent)

    assertBool(inside, &#34;inside&#34;)
    assertBool(swivel_fixed, &#34;swivel_fixed&#34;)
    assertBool(fixed_to_parent, &#34;fixed_to_parent&#34;)
    assertBool(child_fixed, &#34;child_fixed&#34;)

    GeometricContact._assert_parent_child_possible(parent, child)

    if swivel is None:
        if inside:
            swivel = 0
        else:
            swivel = 90

    assert1f(swivel, &#34;swivel_angle&#34;)

    if rotation_on_parent is not None:
        assert1f(rotation_on_parent, &#34;rotation_on_parent should be either None or &#34;)
    if child_rotation is not None:
        assert1f(child_rotation, &#34;child_rotation should be either None or &#34;)

    if child is None:
        raise ValueError(&#34;child needs to be a sheave-type node&#34;)
    if parent is None:
        raise ValueError(&#34;parent needs to be a sheave-type node&#34;)

    if child.parent.parent is None:
        raise ValueError(
            f&#34;The parent {child.parent.name} of the child item {child.name} is not located on an axis. Can not create the connection because there is no axis to nodeB&#34;
        )

    if child.parent.parent.manager is not None:
        self.print_node_tree()
        raise ValueError(
            f&#34;The axis or body that {child.name} is on is already managed by {child.parent.parent.manager.name} and can therefore not be changed - unable to create geometric contact&#34;
        )

    new_node = GeometricContact(self, child, parent, name)
    if inside:
        new_node.set_pin_in_hole_connection()
    else:
        new_node.set_pin_pin_connection()

    new_node.swivel = swivel
    if rotation_on_parent is not None:
        new_node.rotation_on_parent = rotation_on_parent
    if child_rotation is not None:
        new_node.child_rotation = child_rotation

    new_node.fixed_to_parent = fixed_to_parent
    new_node.child_fixed = child_fixed
    new_node.swivel_fixed = swivel_fixed

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_hydspring"><code class="name flex">
<span>def <span class="ident">new_hydspring</span></span>(<span>self, name, parent, cob, BMT, BML, COFX, COFY, kHeave, waterline, displacement_kN) ->Â <a title="DAVE.scene.HydSpring" href="#DAVE.scene.HydSpring">HydSpring</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <em>hydspring</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>name of the parent of the node [Axis]</dd>
<dt><strong><code>cob</code></strong></dt>
<dd>position of the CoB (x,y,z) in the parent axis system</dd>
<dt><strong><code>BMT</code></strong></dt>
<dd>Vertical distance between CoB and meta-center for roll</dd>
<dt><strong><code>BML</code></strong></dt>
<dd>Vertical distance between CoB and meta-center for pitch</dd>
<dt><strong><code>COFX</code></strong></dt>
<dd>X-location of center of flotation (center of waterplane) relative to CoB</dd>
<dt><strong><code>COFY</code></strong></dt>
<dd>Y-location of center of flotation (center of waterplane) relative to CoB</dd>
<dt><strong><code>kHeave</code></strong> :&ensp;<code>heave stiffness (typically Awl * rho * g)</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>waterline</code></strong> :&ensp;<code>Z-position (elevation)</code> of <code>the waterline relative to CoB</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>displacement_kN</code></strong> :&ensp;<code>displacement (typically volume * rho * g)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference to newly created hydrostatic spring</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_hydspring(
    self,
    name,
    parent,
    cob,
    BMT,
    BML,
    COFX,
    COFY,
    kHeave,
    waterline,
    displacement_kN,
) -&gt; HydSpring:
    &#34;&#34;&#34;Creates a new *hydspring* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        parent: name of the parent of the node [Axis]
        cob: position of the CoB (x,y,z) in the parent axis system
        BMT: Vertical distance between CoB and meta-center for roll
        BML: Vertical distance between CoB and meta-center for pitch
        COFX: X-location of center of flotation (center of waterplane) relative to CoB
        COFY: Y-location of center of flotation (center of waterplane) relative to CoB
        kHeave : heave stiffness (typically Awl * rho * g)
        waterline : Z-position (elevation) of the waterline relative to CoB
        displacement_kN : displacement (typically volume * rho * g)


    Returns:
        Reference to newly created hydrostatic spring

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    assertValidName(name)
    self._verify_name_available(name)
    b = self._parent_from_node(parent)
    assert3f(cob, &#34;CoB &#34;)
    assert1f(BMT, &#34;BMT &#34;)
    assert1f(BML, &#34;BML &#34;)
    assert1f(COFX, &#34;COFX &#34;)
    assert1f(COFY, &#34;COFY &#34;)
    assert1f(kHeave, &#34;kHeave &#34;)
    assert1f(waterline, &#34;waterline &#34;)
    assert1f(displacement_kN, &#34;displacement_kN &#34;)

    # then create
    a = self._vfc.new_hydspring(name)
    new_node = HydSpring(self, a)

    new_node.cob = cob
    new_node.parent = b
    new_node.BMT = BMT
    new_node.BML = BML
    new_node.COFX = COFX
    new_node.COFY = COFY
    new_node.kHeave = kHeave
    new_node.waterline = waterline
    new_node.displacement_kN = displacement_kN

    self._nodes.append(new_node)

    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_linear_connector_6d"><code class="name flex">
<span>def <span class="ident">new_linear_connector_6d</span></span>(<span>self, name, main, secondary, stiffness=None) ->Â <a title="DAVE.scene.LC6d" href="#DAVE.scene.LC6d">LC6d</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <em>linear connector 6d</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>main</code></strong></dt>
<dd>Main axis system [Axis]</dd>
<dt><strong><code>secondary</code></strong></dt>
<dd>Secondary axis system [Axis]</dd>
<dt><strong><code>stiffness</code></strong></dt>
<dd>optional, connection stiffness (x,y,z, rx,ry,rz)</dd>
</dl>
<p>See :py:class:<code><a title="DAVE.scene.LC6d" href="#DAVE.scene.LC6d">LC6d</a></code> for details</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference to newly created connector</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_linear_connector_6d(self, name, main, secondary, stiffness=None) -&gt; LC6d:
    &#34;&#34;&#34;Creates a new *linear connector 6d* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        main: Main axis system [Axis]
        secondary: Secondary axis system [Axis]
        stiffness: optional, connection stiffness (x,y,z, rx,ry,rz)

    See :py:class:`LC6d` for details

    Returns:
        Reference to newly created connector

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    assertValidName(name)
    self._verify_name_available(name)
    m = self._parent_from_node(secondary)
    s = self._parent_from_node(main)

    if stiffness is not None:
        assert6f(stiffness, &#34;Stiffness &#34;)
    else:
        stiffness = (0, 0, 0, 0, 0, 0)

    # then create
    a = self._vfc.new_linearconnector6d(name)

    new_node = LC6d(self, a)

    # and set properties
    new_node.main = m
    new_node.secondary = s
    new_node.stiffness = stiffness

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_point"><code class="name flex">
<span>def <span class="ident">new_point</span></span>(<span>self, name, parent=None, position=None) ->Â <a title="DAVE.scene.Point" href="#DAVE.scene.Point">Point</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <em>poi</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>optional, name of the parent of the node</dd>
<dt><strong><code>position</code></strong></dt>
<dd>optional, position for the node (x,y,z)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference to newly created poi</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_point(self, name, parent=None, position=None) -&gt; Point:
    &#34;&#34;&#34;Creates a new *poi* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        parent: optional, name of the parent of the node
        position: optional, position for the node (x,y,z)


    Returns:
        Reference to newly created poi

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    assertValidName(name)
    self._verify_name_available(name)
    b = self._parent_from_node(parent)

    if position is not None:
        assert3f(position, &#34;Position &#34;)

    # then create
    a = self._vfc.new_poi(name)

    new_node = Point(self, a)

    # and set properties
    if b is not None:
        new_node.parent = b
    if position is not None:
        new_node.position = position

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_rigidbody"><code class="name flex">
<span>def <span class="ident">new_rigidbody</span></span>(<span>self, name, mass=0, cog=(0, 0, 0), parent=None, position=None, rotation=None, inertia_radii=None, fixed=True) ->Â <a title="DAVE.scene.RigidBody" href="#DAVE.scene.RigidBody">RigidBody</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <em>rigidbody</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>mass</code></strong></dt>
<dd>optional, [0] mass in mT</dd>
<dt><strong><code>cog</code></strong></dt>
<dd>optional, (0,0,0) cog-position in (m,m,m)</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>optional, name of the parent of the node</dd>
<dt><strong><code>position</code></strong></dt>
<dd>optional, position for the node (x,y,z)</dd>
<dt><strong><code>rotation</code></strong></dt>
<dd>optional, rotation for the node (rx,ry,rz)</dd>
<dt><strong><code>inertia_radii</code></strong> :&ensp;<code>optional, radii</code> of <code>gyration (rxx,ryy,rzz); only used for dynamics</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>fixed [True]: optional, determines whether the axis is fixed [True] or free [False]. May also be a sequence of 6 booleans.</p>
<h2 id="examples">Examples</h2>
<p>scene.new_rigidbody("heavy_thing", mass = 10000, cog = (1.45, 0, -0.7))</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference to newly created <a title="DAVE.scene.RigidBody" href="#DAVE.scene.RigidBody">RigidBody</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_rigidbody(
    self,
    name,
    mass=0,
    cog=(0, 0, 0),
    parent=None,
    position=None,
    rotation=None,
    inertia_radii=None,
    fixed=True,
) -&gt; RigidBody:
    &#34;&#34;&#34;Creates a new *rigidbody* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        mass: optional, [0] mass in mT
        cog: optional, (0,0,0) cog-position in (m,m,m)
        parent: optional, name of the parent of the node
        position: optional, position for the node (x,y,z)
        rotation: optional, rotation for the node (rx,ry,rz)
        inertia_radii : optional, radii of gyration (rxx,ryy,rzz); only used for dynamics
        fixed [True]: optional, determines whether the axis is fixed [True] or free [False]. May also be a sequence of 6 booleans.

    Examples:
        scene.new_rigidbody(&#34;heavy_thing&#34;, mass = 10000, cog = (1.45, 0, -0.7))

    Returns:
        Reference to newly created RigidBody

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # check input
    assertValidName(name)
    self._verify_name_available(name)
    b = self._parent_from_node(parent)

    if position is not None:
        assert3f(position, &#34;Position &#34;)
    if rotation is not None:
        assert3f(rotation, &#34;Rotation &#34;)

    if inertia_radii is not None:
        assert3f_positive(inertia_radii, &#34;Radii of inertia&#34;)
        assert mass &gt; 0, ValueError(
            &#34;Can not set radii of gyration without specifying mass&#34;
        )

    if not isinstance(fixed, bool):
        if len(fixed) != 6:
            raise Exception(
                &#39;&#34;fixed&#34; parameter should either be True/False or a 6x bool sequence such as (True,True,False,False,True,False)&#39;
            )

    # make elements

    a = self._vfc.new_axis(name)

    p = self._vfc.new_poi(name + vfc.VF_NAME_SPLIT + &#34;cog&#34;)
    p.parent = a
    p.position = cog

    g = self._vfc.new_force(name + vfc.VF_NAME_SPLIT + &#34;gravity&#34;)
    g.parent = p
    g.force = (0, 0, -vfc.G * mass)

    r = RigidBody(self, a, p, g)

    r.cog = cog  # set inertia
    r.mass = mass

    # and set properties
    if b is not None:
        r.parent = b
    if position is not None:
        r.position = position
    if rotation is not None:
        r.rotation = rotation

    if inertia_radii is not None:
        r.inertia_radii = inertia_radii

    if isinstance(fixed, bool):
        if fixed:
            r.set_fixed()
        else:
            r.set_free()
    else:
        r.fixed = fixed

    self._nodes.append(r)
    return r</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_shackle"><code class="name flex">
<span>def <span class="ident">new_shackle</span></span>(<span>self, name, kind='GP500') ->Â <a title="DAVE.scene.Shackle" href="#DAVE.scene.Shackle">Shackle</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new shackle, adds it to the scene and returns a reference to the newly created object.</p>
<p>See Also:
Shackle</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>name</dd>
<dt><strong><code>kind</code></strong></dt>
<dd>type of shackle; eg 'GP500'</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a reference to the newly created Shackle object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_shackle(self, name, kind=&#34;GP500&#34;) -&gt; Shackle:
    &#34;&#34;&#34;
    Creates a new shackle, adds it to the scene and returns a reference to the newly created object.

    See Also:
        Shackle

    Args:
        name:   name
        kind:  type of shackle; eg &#39;GP500&#39;


    Returns:
        a reference to the newly created Shackle object.

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    assertValidName(name)
    self._verify_name_available(name)

    name_prefix = name + vfc.MANAGED_NODE_IDENTIFIER
    postfixes = [
        &#34;_body&#34;,
        &#34;_pin_point&#34;,
        &#34;_bow_point&#34;,
        &#34;_inside_circle_center&#34;,
        &#34;_inside&#34;,
        &#34;_visual&#34;,
    ]
    for pf in postfixes:
        self._verify_name_available(name_prefix + pf)

    # then make element

    # make elements

    a = self._vfc.new_axis(name)

    p = self._vfc.new_poi(name + vfc.VF_NAME_SPLIT + &#34;cog&#34;)
    p.parent = a

    g = self._vfc.new_force(name + vfc.VF_NAME_SPLIT + &#34;gravity&#34;)
    g.parent = p

    node = Shackle(scene=self, name=name, kind=kind, a=a, p=p, g=g)

    self._nodes.append(node)

    return node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_sling"><code class="name flex">
<span>def <span class="ident">new_sling</span></span>(<span>self, name, length=-1, EA=1.0, mass=0.1, endA=None, endB=None, LeyeA=None, LeyeB=None, LspliceA=None, LspliceB=None, diameter=0.1, sheaves=None) ->Â <a title="DAVE.scene.Sling" href="#DAVE.scene.Sling">Sling</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new sling, adds it to the scene and returns a reference to the newly created object.</p>
<p>See Also:
Sling</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>name</dd>
<dt><strong><code>length</code></strong></dt>
<dd>length of the sling [m], defaults to distance between endpoints</dd>
<dt><strong><code>EA</code></strong></dt>
<dd>
<p>stiffness in kN, default: 1.0 (note: equilibrium will fail if mass &gt;0 and EA=0)</p>
</dd>
<dt><strong><code>mass</code></strong></dt>
<dd>mass in mT, default
0.1</dd>
<dt><strong><code>endA</code></strong></dt>
<dd>element to connect end A to [poi, circle]</dd>
<dt><strong><code>endB</code></strong></dt>
<dd>element to connect end B to [poi, circle]</dd>
<dt><strong><code>LeyeA</code></strong></dt>
<dd>inside eye on side A length [m], defaults to 1/6th of length</dd>
<dt><strong><code>LeyeB</code></strong></dt>
<dd>inside eye on side B length [m], defaults to 1/6th of length</dd>
<dt><strong><code>LspliceA</code></strong></dt>
<dd>splice length on side A [m] (the part where the cable is connected to itself)</dd>
<dt><strong><code>LspliceB</code></strong></dt>
<dd>splice length on side B [m] (the part where the cable is connected to itself)</dd>
<dt><strong><code>diameter</code></strong></dt>
<dd>cable diameter in m, defaul to 0.1</dd>
<dt><strong><code>sheaves</code></strong></dt>
<dd>optional: list of sheaves/pois that the sling runs over</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a reference to the newly created Sling object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_sling(
    self,
    name,
    length=-1,
    EA=1.0,
    mass=0.1,
    endA=None,
    endB=None,
    LeyeA=None,
    LeyeB=None,
    LspliceA=None,
    LspliceB=None,
    diameter=0.1,
    sheaves=None,
) -&gt; Sling:
    &#34;&#34;&#34;
    Creates a new sling, adds it to the scene and returns a reference to the newly created object.

    See Also:
        Sling

    Args:
        name:    name
        length:  length of the sling [m], defaults to distance between endpoints
        EA:      stiffness in kN, default: 1.0 (note: equilibrium will fail if mass &gt;0 and EA=0)
        mass:    mass in mT, default  0.1
        endA:    element to connect end A to [poi, circle]
        endB:    element to connect end B to [poi, circle]
        LeyeA:   inside eye on side A length [m], defaults to 1/6th of length
        LeyeB:   inside eye on side B length [m], defaults to 1/6th of length
        LspliceA: splice length on side A [m] (the part where the cable is connected to itself)
        LspliceB: splice length on side B [m] (the part where the cable is connected to itself)
        diameter: cable diameter in m, defaul to 0.1
        sheaves:  optional: list of sheaves/pois that the sling runs over

    Returns:
        a reference to the newly created Sling object.

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    assertValidName(name)
    self._verify_name_available(name)

    name_prefix = name + vfc.MANAGED_NODE_IDENTIFIER
    postfixes = [
        &#34;_spliceA&#34;,
        &#34;_spliceA&#34;,
        &#34;_spliceA2&#34;,
        &#34;_spliceAM&#34;,
        &#34;_spliceA_visual&#34;,
        &#34;spliceB&#34;,
        &#34;_spliceB1&#34;,
        &#34;_spliceB2&#34;,
        &#34;_spliceBM&#34;,
        &#34;_spliceB_visual&#34;,
        &#34;_main_part&#34;,
        &#34;_eyeA&#34;,
        &#34;_eyeB&#34;,
    ]

    for pf in postfixes:
        self._verify_name_available(name_prefix + pf)

    endA = self._poi_or_sheave_from_node(endA)
    endB = self._poi_or_sheave_from_node(endB)

    if length == -1:  # default
        if endA is None or endB is None:
            raise ValueError(
                &#34;Length for cable is not provided, so defaults to distance between endpoints; but at least one of the endpoints is None.&#34;
            )

        length = np.linalg.norm(
            np.array(endA.global_position) - np.array(endB.global_position)
        )

    if LeyeA is None:  # default
        LeyeA = length / 6
    if LeyeB is None:  # default
        LeyeB = length / 6
    if LspliceA is None:  # default
        LspliceA = length / 6
    if LspliceB is None:  # default
        LspliceB = length / 6

    if sheaves is None:
        sheaves = []

    assert1f_positive_or_zero(diameter, &#34;Diameter&#34;)
    assert1f_positive_or_zero(mass, &#34;mass&#34;)

    assert1f_positive(length, &#34;Length&#34;)
    assert1f_positive(LeyeA, &#34;length of eye A&#34;)
    assert1f_positive(LeyeB, &#34;length of eye B&#34;)
    assert1f_positive(LspliceA, &#34;length of splice A&#34;)
    assert1f_positive(LspliceB, &#34;length of splice B&#34;)

    for s in sheaves:
        _ = self._poi_or_sheave_from_node(s)

    # then make element
    # __init__(self, scene, name, Ltotal, LeyeA, LeyeB, LspliceA, LspliceB, diameter, EA, mass, endA = None, endB=None, sheaves=None):

    node = Sling(
        scene=self,
        name=name,
        length=length,
        LeyeA=LeyeA,
        LeyeB=LeyeB,
        LspliceA=LspliceA,
        LspliceB=LspliceB,
        diameter=diameter,
        EA=EA,
        mass=mass,
        endA=endA,
        endB=endB,
        sheaves=sheaves,
    )
    self._nodes.append(node)

    return node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_spmt"><code class="name flex">
<span>def <span class="ident">new_spmt</span></span>(<span>self, name, parent, maximal_length=1.8, nominal_length=1.5, k=1000000.0, meshes=None, axles=None) ->Â <a title="DAVE.scene.SPMT" href="#DAVE.scene.SPMT">SPMT</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <em>SPMT</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>name of the parent of the node [Axis]</dd>
<dt><strong><code>maximal_length</code></strong></dt>
<dd>optional, maximum distance between top and bottom of wheel (1.5m + 300mm)</dd>
<dt><strong><code>nominal_length</code></strong></dt>
<dd>optional, nominal distance between top and bottom of wheel [1.5m]</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>stiffness per axle [kN/m]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>meshes</code></strong> :&ensp;<code>list</code> of <code>contact meshes</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>axles
: list of axle locations [(x,y,z),(x,y,z), &hellip; ]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference to newly created <a title="DAVE.scene.SPMT" href="#DAVE.scene.SPMT">SPMT</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_spmt(
    self,
    name,
    parent,
    maximal_length=1.8,
    nominal_length=1.5,
    k=1e6,
    meshes=None,
    axles=None,
) -&gt; SPMT:
    &#34;&#34;&#34;Creates a new *SPMT* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        parent: name of the parent of the node [Axis]
        maximal_length: optional, maximum distance between top and bottom of wheel (1.5m + 300mm)
        nominal_length: optional, nominal distance between top and bottom of wheel [1.5m]
        k : stiffness per axle [kN/m]
        meshes : list of contact meshes
        axles  : list of axle locations [(x,y,z),(x,y,z), ... ]

    Returns:
        Reference to newly created SPMT

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    assertValidName(name)
    self._verify_name_available(name)
    parent = self._node_from_node_or_str(parent)
    assert isinstance(parent, Axis), ValueError(
        f&#34;Parent should be an axis system or derived, not a {type(parent)}&#34;
    )

    assert1f_positive_or_zero(maximal_length, &#34;maximal_length &#34;)
    assert1f_positive_or_zero(nominal_length, &#34;nominal_length &#34;)

    if meshes is not None:
        meshes = make_iterable(meshes)
        for mesh in meshes:
            test = self._node_from_node(
                mesh, ContactMesh
            )  # throws error if not found

    if axles is not None:
        for p in axles:
            assert3f(p, &#34;axle locations should be (x,y,z)&#34;)

    # then create
    a = self._vfc.new_spmt(name)

    new_node = SPMT(self, a)

    # and set properties
    new_node.parent = parent
    new_node.k = k
    new_node.max_length = maximal_length
    new_node.nominal_length = nominal_length

    if meshes is not None:
        new_node.meshes = meshes

    if axles is not None:
        new_node.axles = axles

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_tank"><code class="name flex">
<span>def <span class="ident">new_tank</span></span>(<span>self, name, parent=None, density=1.025, free_flooding=False) ->Â <a title="DAVE.scene.Tank" href="#DAVE.scene.Tank">Tank</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <em>tank</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>optional, name of the parent of the node</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference to newly created <a title="DAVE.scene.Tank" href="#DAVE.scene.Tank">Tank</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_tank(self, name, parent=None, density=1.025, free_flooding=False) -&gt; Tank:
    &#34;&#34;&#34;Creates a new *tank* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        parent: optional, name of the parent of the node

    Returns:
        Reference to newly created Tank

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    assertValidName(name)
    self._verify_name_available(name)
    b = self._parent_from_node(parent)

    if b is None:
        raise ValueError(&#34;A valid parent must be defined for a Tank&#34;)

    assert isinstance(free_flooding, bool), ValueError(
        &#34;free_flooding shall be True or False&#34;
    )

    assert1f(density, &#34;density&#34;)

    # then create
    a = self._vfc.new_tank(name)
    new_node = Tank(self, a)
    new_node.density = density

    # and set properties
    if b is not None:
        new_node.parent = b

    new_node.free_flooding = free_flooding

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_visual"><code class="name flex">
<span>def <span class="ident">new_visual</span></span>(<span>self, name, path, parent=None, offset=None, rotation=None, scale=None) ->Â <a title="DAVE.scene.Visual" href="#DAVE.scene.Visual">Visual</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <em>Visual</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>path</code></strong></dt>
<dd>Path to the resource</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>optional, name of the parent of the node</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>optional, position for the node (x,y,z)</dd>
<dt><strong><code>rotation</code></strong></dt>
<dd>optional, rotation for the node (rx,ry,rz)</dd>
</dl>
<p>scale : optional, scale of the visual (x,y,z).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference to newly created visual</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_visual(
    self, name, path, parent=None, offset=None, rotation=None, scale=None
) -&gt; Visual:
    &#34;&#34;&#34;Creates a new *Visual* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        path: Path to the resource
        parent: optional, name of the parent of the node
        offset: optional, position for the node (x,y,z)
        rotation: optional, rotation for the node (rx,ry,rz)
        scale : optional, scale of the visual (x,y,z).

    Returns:
        Reference to newly created visual

    &#34;&#34;&#34;

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    assertValidName(name)
    self._verify_name_available(name)
    b = self._parent_from_node(parent)

    if offset is not None:
        assert3f(offset, &#34;Offset &#34;)
    if rotation is not None:
        assert3f(rotation, &#34;Rotation &#34;)

    self.get_resource_path(path)  # raises error when resource is not found

    # then create

    new_node = Visual(self)

    new_node.name = name
    new_node.path = path
    new_node.parent = parent

    # and set properties
    if b is not None:
        new_node.parent = b
    if offset is not None:
        new_node.offset = offset
    if rotation is not None:
        new_node.rotation = rotation
    if scale is not None:
        new_node.scale = scale

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.new_waveinteraction"><code class="name flex">
<span>def <span class="ident">new_waveinteraction</span></span>(<span>self, name, path, parent=None, offset=None) ->Â <a title="DAVE.scene.WaveInteraction1" href="#DAVE.scene.WaveInteraction1">WaveInteraction1</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <em>wave interaction</em> node and adds it to the scene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name for the node, should be unique</dd>
<dt><strong><code>path</code></strong></dt>
<dd>Path to the hydrodynamic database</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>optional, name of the parent of the node</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>optional, position for the node (x,y,z)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Reference to newly created wave-interaction object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_waveinteraction(
    self,
    name,
    path,
    parent=None,
    offset=None,
) -&gt; WaveInteraction1:
    &#34;&#34;&#34;Creates a new *wave interaction* node and adds it to the scene.

    Args:
        name: Name for the node, should be unique
        path: Path to the hydrodynamic database
        parent: optional, name of the parent of the node
        offset: optional, position for the node (x,y,z)

    Returns:
        Reference to newly created wave-interaction object

    &#34;&#34;&#34;

    if not parent:
        raise ValueError(&#34;Wave-interaction has to be located on an Axis&#34;)

    # apply prefixes
    name = self._prefix_name(name)

    # first check
    assertValidName(name)
    self._verify_name_available(name)
    b = self._parent_from_node(parent)

    if b is None:
        raise ValueError(&#34;Wave-interaction has to be located on an Axis&#34;)

    if offset is not None:
        assert3f(offset, &#34;Offset &#34;)

    self.get_resource_path(path)  # raises error when resource is not found

    # then create

    new_node = WaveInteraction1(self)

    new_node.name = name
    new_node.path = path
    new_node.parent = parent

    # and set properties
    new_node.parent = b
    if offset is not None:
        new_node.offset = offset

    self._nodes.append(new_node)
    return new_node</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.node_A_core_depends_on_B_core"><code class="name flex">
<span>def <span class="ident">node_A_core_depends_on_B_core</span></span>(<span>self, A, B)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the node core of node A depends on the core node of node B</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def node_A_core_depends_on_B_core(self, A, B):
    &#34;&#34;&#34;Returns True if the node core of node A depends on the core node of node B&#34;&#34;&#34;

    A = self._node_from_node_or_str(A)
    B = self._node_from_node_or_str(B)

    if not isinstance(A, CoreConnectedNode):
        raise ValueError(
            f&#34;{A.name} is not connected to a core node. Dependancies can not be traced using this function&#34;
        )
    if not isinstance(B, CoreConnectedNode):
        raise ValueError(
            f&#34;{B.name} is not connected to a core node. Dependancies can not be traced using this function&#34;
        )

    return self._vfc.element_A_depends_on_B(A._vfNode.name, B._vfNode.name)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.node_by_name"><code class="name flex">
<span>def <span class="ident">node_by_name</span></span>(<span>self, node_name, silent=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def node_by_name(self, node_name, silent=False):
    for N in self._nodes:
        if N.name == node_name:
            return N

    if not silent:
        self.print_node_tree()
    raise ValueError(
        &#39;No node with name &#34;{}&#34;. Available names printed above.&#39;.format(node_name)
    )</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.nodes_depending_on"><code class="name flex">
<span>def <span class="ident">nodes_depending_on</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of nodes that physically depend on node. Only direct dependants are obtained with a connection to the core.
This function should be used to determine if a node can be created, deleted, exported.</p>
<p>For making node-trees please use nodes_with_parent instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></code> or <code>node-name</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>names</code></dt>
<dd>&nbsp;</dd>
<dt><code>See Also: nodes_with_parent</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nodes_depending_on(self, node):
    &#34;&#34;&#34;Returns a list of nodes that physically depend on node. Only direct dependants are obtained with a connection to the core.
    This function should be used to determine if a node can be created, deleted, exported.

    For making node-trees please use nodes_with_parent instead.

    Args:
        node : Node or node-name

    Returns:
        list of names

    See Also: nodes_with_parent
    &#34;&#34;&#34;

    if isinstance(node, Node):
        node = node.name

    # check the node type
    _node = self[node]
    if not isinstance(_node, CoreConnectedNode):
        return []
    else:
        names = self._vfc.elements_depending_directly_on(node)

    r = []
    for name in names:
        try:
            node = self.node_by_name(name, silent=True)
            r.append(node.name)
        except:
            pass

    # check all other nodes in the scene

    for n in self._nodes:
        if _node in n.depends_on():
            if n.name not in r:
                r.append(n.name)

    # for v in [*self.nodes_of_type(Visual), *self.nodes_of_type(WaveInteraction1)]:
    #     if v.parent is _node:
    #         r.append(v.name)

    return r</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.nodes_managed_by"><code class="name flex">
<span>def <span class="ident">nodes_managed_by</span></span>(<span>self, manager:Â <a title="DAVE.scene.Manager" href="#DAVE.scene.Manager">Manager</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of nodes managed by manager</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nodes_managed_by(self, manager : Manager):
    &#34;&#34;&#34;Returns a list of nodes managed by manager&#34;&#34;&#34;

    return [node for node in self._nodes if node.manager == manager]</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.nodes_of_type"><code class="name flex">
<span>def <span class="ident">nodes_of_type</span></span>(<span>self, node_class)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all nodes of the specified or derived type</p>
<h2 id="examples">Examples</h2>
<p>pois = scene.nodes_of_type(DAVE.Poi)
axis_and_bodies = scene.nodes_of_type(DAVE.Axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nodes_of_type(self, node_class):
    &#34;&#34;&#34;Returns all nodes of the specified or derived type

    Examples:
        pois = scene.nodes_of_type(DAVE.Poi)
        axis_and_bodies = scene.nodes_of_type(DAVE.Axis)
    &#34;&#34;&#34;
    r = list()
    for n in self._nodes:
        if isinstance(n, node_class):
            r.append(n)
    return r</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.nodes_with_parent"><code class="name flex">
<span>def <span class="ident">nodes_with_parent</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of nodes that have given node as a parent. Good for making trees.
For checking physical connections use nodes_depending_on instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></code> or <code>node-name</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>names</code></dt>
<dd>&nbsp;</dd>
<dt><code>See Also: nodes_depending_on</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nodes_with_parent(self, node):
    &#34;&#34;&#34;Returns a list of nodes that have given node as a parent. Good for making trees.
    For checking physical connections use nodes_depending_on instead.

    Args:
        node : Node or node-name

    Returns:
        list of names

    See Also: nodes_depending_on
    &#34;&#34;&#34;

    if isinstance(node, str):
        node = self[node]

    r = []

    for n in self._nodes:

        try:
            parent = n.parent
        except AttributeError:
            continue

        if parent == node:
            r.append(n.name)

    return r</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.plot_effect"><code class="name flex">
<span>def <span class="ident">plot_effect</span></span>(<span>self, evaluate, change_node, change_property, start, to, steps)</span>
</code></dt>
<dd>
<div class="desc"><p>Produces a 2D plot with the relation between two properties of the scene. For example the length of a cable
versus the force in another cable.</p>
<p>The evaluate argument is processed using "eval" and may contain python code. This may be used to combine multiple
properties to one value. For example calculate the diagonal load distribution from four independent loads.</p>
<p>The plot is produced using matplotlob. The plot is produced in the current figure (if any) and plt.show is not executed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>evaluate</code></strong> :&ensp;<code>str</code></dt>
<dd>code to be evaluated to yield the value on the y-axis. Eg: s['poi'].fx Scene is abbiviated as "s"</dd>
<dt>change_node(Node or str):
node to be adjusted</dt>
<dt><strong><code>change_property</code></strong> :&ensp;<code>str</code></dt>
<dd>property of that node to be adjusted</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>left side</code> of <code>the interval</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>to</code></strong> :&ensp;<code>right side</code> of <code>the interval</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>steps</code></strong> :&ensp;<code>number</code> of <code>steps in the interval</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple (x,y) with x and y coordinates</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; s.plot_effect(&quot;s['cable'].tension&quot;, &quot;cable&quot;, &quot;length&quot;, 11, 14, 10)
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; plt.show()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_effect(self, evaluate, change_node, change_property, start, to, steps):
    &#34;&#34;&#34;Produces a 2D plot with the relation between two properties of the scene. For example the length of a cable
    versus the force in another cable.

    The evaluate argument is processed using &#34;eval&#34; and may contain python code. This may be used to combine multiple
    properties to one value. For example calculate the diagonal load distribution from four independent loads.

    The plot is produced using matplotlob. The plot is produced in the current figure (if any) and plt.show is not executed.

    Args:
        evaluate (str): code to be evaluated to yield the value on the y-axis. Eg: s[&#39;poi&#39;].fx Scene is abbiviated as &#34;s&#34;
        change_node(Node or str):  node to be adjusted
        change_property (str): property of that node to be adjusted
        start : left side of the interval
        to : right side of the interval
        steps : number of steps in the interval

    Returns:
        Tuple (x,y) with x and y coordinates

    Examples:
        &gt;&gt;&gt; s.plot_effect(&#34;s[&#39;cable&#39;].tension&#34;, &#34;cable&#34;, &#34;length&#34;, 11, 14, 10)
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; plt.show()

    &#34;&#34;&#34;
    s = self
    change_node = self._node_from_node_or_str(change_node)

    # check that the attributes exist and are single numbers
    test = eval(evaluate)

    try:
        float(test)
    except:
        raise ValueError(&#34;Evaluation of {} does not result in a float&#34;)

    def set_and_get(x):
        setattr(change_node, change_property, x)
        self.solve_statics(silent=True)
        s = self
        result = eval(evaluate)
        self._print(&#34;setting {} results in {}&#34;.format(x, result))
        return result

    xs = np.linspace(start, to, steps)
    y = []
    for x in xs:
        y.append(set_and_get(x))

    y = np.array(y)
    import matplotlib.pyplot as plt

    plt.plot(xs, y)
    plt.xlabel(&#34;{} of {}&#34;.format(change_property, change_node.name))
    plt.ylabel(evaluate)

    return (xs, y)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.print_node_tree"><code class="name flex">
<span>def <span class="ident">print_node_tree</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_node_tree(self):

    self.sort_nodes_by_dependency()

    to_be_printed = []
    for n in self._nodes:
        to_be_printed.append(n.name)

    # to_be_printed.reverse()

    def print_deps(name, spaces):

        node = self[name]
        deps = self.nodes_with_parent(node)
        print(spaces + name + &#34; [&#34; + str(type(node)).split(&#34;.&#34;)[-1][:-2] + &#34;]&#34;)

        if deps is not None:
            for dep in deps:
                if spaces == &#34;&#34;:
                    spaces_plus = &#34; |-&gt; &#34;
                else:
                    spaces_plus = &#34; |   &#34; + spaces
                print_deps(dep, spaces_plus)

        to_be_printed.remove(name)

    while to_be_printed:
        name = to_be_printed[0]
        print_deps(name, &#34;&#34;)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.print_python_code"><code class="name flex">
<span>def <span class="ident">print_python_code</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the python code that generates the current scene</p>
<p>See also: give_python_code</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_python_code(self):
    &#34;&#34;&#34;Prints the python code that generates the current scene

    See also: give_python_code
    &#34;&#34;&#34;
    for line in self.give_python_code().split(&#34;\n&#34;):
        print(line)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.run_code"><code class="name flex">
<span>def <span class="ident">run_code</span></span>(<span>self, code)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the provided code with 's' as self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_code(self, code):
    &#34;&#34;&#34;Runs the provided code with &#39;s&#39; as self&#34;&#34;&#34;

    import DAVE

    locals = DAVE.__dict__
    locals[&#39;s&#39;] = self

    try:
        exec(code, {}, locals)
    except Exception as M:
        for i, line in enumerate(code.split(&#34;\n&#34;)):
            print(f&#34;{i} {line}&#34;)
        raise M</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.save_scene"><code class="name flex">
<span>def <span class="ident">save_scene</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the scene to a file</p>
<p>This saves the scene in its current state to a file.
Opening the saved file will reproduce exactly this scene.</p>
<p>This sounds nice, but beware that it only saves the resulting model, not the process of creating the model.
This means that if you created the model in a parametric fashion or assembled the model from other models then these are not re-evaluated when the model is openened again.
So lets say this model uses a sub-model of a lifting hook which is imported from another file. If that other file is updated then
the results of that update will not be reflected in the saved model.</p>
<p>If no path is present in the file-name then the model will be saved in the last (lowest) resource-path (if any)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>filename</code> or <code>file-path to save the file. Default extension is .dave</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>the full path to the saved file</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_scene(self, filename):
    &#34;&#34;&#34;Saves the scene to a file

    This saves the scene in its current state to a file.
    Opening the saved file will reproduce exactly this scene.

    This sounds nice, but beware that it only saves the resulting model, not the process of creating the model.
    This means that if you created the model in a parametric fashion or assembled the model from other models then these are not re-evaluated when the model is openened again.
    So lets say this model uses a sub-model of a lifting hook which is imported from another file. If that other file is updated then
    the results of that update will not be reflected in the saved model.

    If no path is present in the file-name then the model will be saved in the last (lowest) resource-path (if any)

    Args:
        filename : filename or file-path to save the file. Default extension is .dave

    Returns:
        the full path to the saved file

    &#34;&#34;&#34;

    code = self.give_python_code()

    filename = Path(filename)

    # add .dave extension if needed
    if filename.suffix != &#34;.dave&#34;:
        filename = Path(str(filename) + &#34;.dave&#34;)

    # add path if not provided
    if not filename.is_absolute():
        try:
            filename = Path(self.resources_paths[-1]) / filename
        except:
            pass  # save in current folder

    # make sure directory exists
    directory = filename.parent
    if not directory.exists():
        directory.mkdir()

    f = open(filename, &#34;w+&#34;)
    f.write(code)
    f.close()

    self._print(&#34;Saved as {}&#34;.format(filename))

    return filename</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.savepoint_make"><code class="name flex">
<span>def <span class="ident">savepoint_make</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def savepoint_make(self):
    self._savepoint = self.give_python_code()</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.savepoint_restore"><code class="name flex">
<span>def <span class="ident">savepoint_restore</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def savepoint_restore(self):
    if self._savepoint is not None:
        self.clear()
        exec(self._savepoint, {}, {&#34;s&#34;: self})
        self._savepoint = None
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.solve_statics"><code class="name flex">
<span>def <span class="ident">solve_statics</span></span>(<span>self, silent=False, timeout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Solves statics</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>silent</code></strong></dt>
<dd>Do not print if successfully solved</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if successful, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve_statics(self, silent=False, timeout=None):
    &#34;&#34;&#34;Solves statics

    Args:
        silent: Do not print if successfully solved

    Returns:
        bool: True if successful, False otherwise.

    &#34;&#34;&#34;
    self.update()

    if timeout is None:
        solve_func = self._vfc.state_solve_statics
    else:
        #       bool doStabilityCheck,
        #       double timeout,
        #           bool do_prepare_state,
        #           bool solve_linear_dofs_first,
        #           double stability_check_delta
        solve_func = lambda: self._vfc.state_solve_statics_with_timeout(
            True, timeout, True, True, 0
        )  # default stability value

    # pass 1
    orignal_fixes = self._fix_vessel_heel_trim()
    succes = solve_func()
    if not succes:
        self._restore_original_fixes(orignal_fixes)
        return False

    if orignal_fixes:
        # pass 2
        self._restore_original_fixes(orignal_fixes)
        succes = solve_func()

    if self.verify_equilibrium():

        changed, message = self._check_and_fix_geometric_contact_orientations()
        if changed:
            print(message)
            solve_func()
            if not self.verify_equilibrium():
                return False

        if not silent:
            self._print(&#34;Solved to {}.&#34;.format(self._vfc.Emaxabs))
        return True

    d = np.array(self._vfc.get_dofs())
    if np.any(np.abs(d) &gt; 2000):
        print(
            &#34;Error: One of the degrees of freedom exceeded the boundary of 2000 [m]/[rad].&#34;
        )
        return False

    return False</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.sort_nodes_by_dependency"><code class="name flex">
<span>def <span class="ident">sort_nodes_by_dependency</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sorts the nodes such that a nodes creation only depends on nodes earlier in the list.</p>
<p>This sorting is used for node creation order</p>
<p>See Also:
sort_nodes_by_parent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_nodes_by_dependency(self):
    &#34;&#34;&#34;Sorts the nodes such that a nodes creation only depends on nodes earlier in the list.

    This sorting is used for node creation order

    See Also:
        sort_nodes_by_parent
    &#34;&#34;&#34;

    self.assert_unique_names()

    exported = []
    to_be_exported = self._nodes.copy()
    counter = 0

    while to_be_exported:

        counter += 1
        if counter &gt; len(self._nodes):

            for node in to_be_exported:
                print(f&#34;Node : {node.name}&#34;)
                for d in node.depends_on():
                    print(f&#34;  depends on: {d.name}&#34;)
                if node._manager:
                    print(f&#34;   managed by: {node._manager.name}&#34;)

            raise Exception(
                &#34;Could not sort nodes by dependency, circular references exist?&#34;
            )

        can_be_exported = []

        for node in to_be_exported:
            # if node._manager:
            #     if node._manager in exported:
            #         can_be_exported.append(node)
            # el
            if all(el in exported for el in node.depends_on()):
                can_be_exported.append(node)

        # remove exported nodes from
        for n in can_be_exported:
            to_be_exported.remove(n)

        exported.extend(can_be_exported)

    self._nodes = exported

    # scene_names = [n.name for n in self._nodes]
    #
    # self._vfc.state_update()  # use the function from the core.
    # new_list = []
    # for name in self._vfc.names:  # and then build a new list using the names
    #     if vfc.VF_NAME_SPLIT in name:
    #         continue
    #
    #     if name not in scene_names:
    #         raise Exception(&#39;Something went wrong with sorting the the nodes by dependency. &#39;
    #                         &#39;Node naming between core and scene is inconsistent for node {}&#39;.format(name))
    #
    #     new_list.append(self[name])
    #
    # # and add the nodes without a vfc-core connection
    # for node in self._nodes:
    #     if not node in new_list:
    #         new_list.append(node)
    #
    # self._nodes = new_list</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.sort_nodes_by_parent"><code class="name flex">
<span>def <span class="ident">sort_nodes_by_parent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sorts the nodes such that the parent of this node (if any) occurs earlier in the list.</p>
<p>See Also:
sort_nodes_by_dependency</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_nodes_by_parent(self):
    &#34;&#34;&#34;Sorts the nodes such that the parent of this node (if any) occurs earlier in the list.

    See Also:
        sort_nodes_by_dependency
    &#34;&#34;&#34;

    self.assert_unique_names()

    exported = []
    to_be_exported = self._nodes.copy()
    counter = 0

    while to_be_exported:

        counter += 1
        if counter &gt; len(self._nodes):
            raise Exception(
                &#34;Could not sort nodes by dependency, circular references exist?&#34;
            )

        can_be_exported = []

        for node in to_be_exported:

            if hasattr(node, &#34;parent&#34;):
                parent = node.parent
                if parent is not None and parent not in exported:
                    continue

            if node.manager is not None and node.manager not in exported:
                continue

            # otherwise the node can be exported
            can_be_exported.append(node)

        # remove exported nodes from
        for n in can_be_exported:
            to_be_exported.remove(n)

        exported.extend(can_be_exported)

    self._nodes = exported</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the interface between the nodes and the core. This includes the re-calculation of all forces,
buoyancy positions, ballast-system cogs etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#34;&#34;&#34;Updates the interface between the nodes and the core. This includes the re-calculation of all forces,
    buoyancy positions, ballast-system cogs etc.
    &#34;&#34;&#34;
    for n in self._nodes:
        n.update()
    self._vfc.state_update()</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Scene.verify_equilibrium"><code class="name flex">
<span>def <span class="ident">verify_equilibrium</span></span>(<span>self, tol=0.01)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the current state is an equilibrium</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if successful, False if not an equilibrium.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_equilibrium(self, tol=1e-2):
    &#34;&#34;&#34;Checks if the current state is an equilibrium

    Returns:
        bool: True if successful, False if not an equilibrium.

    &#34;&#34;&#34;
    self.update()
    return self._vfc.Emaxabs &lt; tol</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="DAVE.scene.Shackle"><code class="flex name class">
<span>class <span class="ident">Shackle</span></span>
<span>(</span><span>scene, name, kind, a, p, g)</span>
</code></dt>
<dd>
<div class="desc"><p>Green-Pin Heavy Duty Bow Shackle BN</p>
<p>visual from: <a href="https://www.traceparts.com/en/product/green-pinr-p-6036-green-pinr-heavy-duty-bow-shackle-bn-hdgphm0800-mm?CatalogPath=TRACEPARTS%3ATP04001002006&amp;Product=10-04072013-086517&amp;PartNumber=HDGPHM0800">https://www.traceparts.com/en/product/green-pinr-p-6036-green-pinr-heavy-duty-bow-shackle-bn-hdgphm0800-mm?CatalogPath=TRACEPARTS%3ATP04001002006&amp;Product=10-04072013-086517&amp;PartNumber=HDGPHM0800</a>
details from: <a href="https://www.greenpin.com/sites/default/files/2019-04/brochure-april-2019.pdf">https://www.greenpin.com/sites/default/files/2019-04/brochure-april-2019.pdf</a></p>
<p>wll a b c d e f g h i j k weight
[t] [mm]
[kg]
120 95 95 208 95 147 400 238 647 453 428 50 110
150 105 108 238 105 169 410 275 688 496 485 50 160
200 120 130 279 120 179 513 290 838 564 530 70 235
250 130 140 299 130 205 554 305 904 614 565 70 295
300 140 150 325 140 205 618 305 996 644 585 80 368
400 170 175 376 164 231 668 325 1114 690 665 70 560
500 180 185 398 164 256 718 350 1190 720 710 70 685
600 200 205 444 189 282 718 375 1243 810 775 70 880
700 210 215 454 204 308 718 400 1263 870 820 70 980
800 210 220 464 204 308 718 400 1270 870 820 70 1100
900 220 230 485 215 328 718 420 1296 920 860 70 1280
1000 240 240 515 215 349 718 420 1336 940 900 70 1460
1250 260 270 585 230 369 768 450 1456 1025 970 70 1990
1500 280 290 625 230 369 818 450 1556 1025 1010 70 2400</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Shackle(Manager, RigidBody):
    &#34;&#34;&#34;
    Green-Pin Heavy Duty Bow Shackle BN

    visual from: https://www.traceparts.com/en/product/green-pinr-p-6036-green-pinr-heavy-duty-bow-shackle-bn-hdgphm0800-mm?CatalogPath=TRACEPARTS%3ATP04001002006&amp;Product=10-04072013-086517&amp;PartNumber=HDGPHM0800
    details from: https://www.greenpin.com/sites/default/files/2019-04/brochure-april-2019.pdf

    wll a b c d e f g h i j k weight
    [t] [mm]  [kg]
    120 95 95 208 95 147 400 238 647 453 428 50 110
    150 105 108 238 105 169 410 275 688 496 485 50 160
    200 120 130 279 120 179 513 290 838 564 530 70 235
    250 130 140 299 130 205 554 305 904 614 565 70 295
    300 140 150 325 140 205 618 305 996 644 585 80 368
    400 170 175 376 164 231 668 325 1114 690 665 70 560
    500 180 185 398 164 256 718 350 1190 720 710 70 685
    600 200 205 444 189 282 718 375 1243 810 775 70 880
    700 210 215 454 204 308 718 400 1263 870 820 70 980
    800 210 220 464 204 308 718 400 1270 870 820 70 1100
    900 220 230 485 215 328 718 420 1296 920 860 70 1280
    1000 240 240 515 215 349 718 420 1336 940 900 70 1460
    1250 260 270 585 230 369 768 450 1456 1025 970 70 1990
    1500 280 290 625 230 369 818 450 1556 1025 1010 70 2400

    Returns:

    &#34;&#34;&#34;

    data = dict()
    # key = wll in t
    # dimensions a..k in [mm]
    #             a     b    c   d     e    f    g    h     i     j    k   weight[kg]
    # index       0     1    2    3    4    5    6    7     8     9    10   11
    data[&#34;GP120&#34;] = (95, 95, 208, 95, 147, 400, 238, 647, 453, 428, 50, 110)
    data[&#34;GP150&#34;] = (105, 108, 238, 105, 169, 410, 275, 688, 496, 485, 50, 160)
    data[&#34;GP200&#34;] = (120, 130, 279, 120, 179, 513, 290, 838, 564, 530, 70, 235)
    data[&#34;GP250&#34;] = (130, 140, 299, 130, 205, 554, 305, 904, 614, 565, 70, 295)
    data[&#34;GP300&#34;] = (140, 150, 325, 140, 205, 618, 305, 996, 644, 585, 80, 368)
    data[&#34;GP400&#34;] = (170, 175, 376, 164, 231, 668, 325, 1114, 690, 665, 70, 560)
    data[&#34;GP500&#34;] = (180, 185, 398, 164, 256, 718, 350, 1190, 720, 710, 70, 685)
    data[&#34;GP600&#34;] = (200, 205, 444, 189, 282, 718, 375, 1243, 810, 775, 70, 880)
    data[&#34;GP700&#34;] = (210, 215, 454, 204, 308, 718, 400, 1263, 870, 820, 70, 980)
    data[&#34;GP800&#34;] = (210, 220, 464, 204, 308, 718, 400, 1270, 870, 820, 70, 1100)
    data[&#34;GP900&#34;] = (220, 230, 485, 215, 328, 718, 420, 1296, 920, 860, 70, 1280)
    data[&#34;GP1000&#34;] = (240, 240, 515, 215, 349, 718, 420, 1336, 940, 900, 70, 1460)
    data[&#34;GP1250&#34;] = (260, 270, 585, 230, 369, 768, 450, 1456, 1025, 970, 70, 1990)
    data[&#34;GP1500&#34;] = (280, 290, 625, 230, 369, 818, 450, 1556, 1025, 1010, 70, 2400)

    def defined_kinds(self):
        &#34;&#34;&#34;Defined shackle kinds&#34;&#34;&#34;
        list = [a for a in Shackle.data.keys()]
        return list

    def _give_values(self, kind):
        if kind not in Shackle.data:
            for key in Shackle.data.keys():
                print(key)
            raise ValueError(
                f&#34;No data available for a Shackle of kind {kind}. Available values printed above&#34;
            )

        return Shackle.data[kind]

    def __init__(self, scene, name, kind, a, p, g):

        Manager.__init__(self, scene)
        RigidBody.__init__(self, scene, axis=a, poi=p, force=g)

        self.name = name

        _ = self._give_values(kind)  # to make sure it exists

        # origin is at center of pin
        # z-axis up
        # y-axis in direction of pin

        # self.body = scene.new_rigidbody(name=name + &#39;_body&#39;)

        # pin
        self.pin_point = scene.new_point(
            name=name + &#34;_pin_point&#34;, parent=self, position=(0.0, 0.0, 0.0)
        )
        self.pin = scene.new_circle(
            name=name + &#34;_pin&#34;, parent=self.pin_point, axis=(0.0, 1.0, 0.0)
        )

        # bow
        self.bow_point = scene.new_point(name=name + &#34;_bow_point&#34;, parent=self)

        self.bow = scene.new_circle(
            name=name + &#34;_bow&#34;, parent=self.bow_point, axis=(0.0, 1.0, 0.0)
        )

        # inside circle
        self.inside_point = scene.new_point(
            name=name + &#34;_inside_circle_center&#34;, parent=self
        )
        self.inside = scene.new_circle(
            name=name + &#34;_inside&#34;, parent=self.inside_point, axis=(1.0, 0, 0)
        )

        # code for GP800_visual
        self.visual_node = scene.new_visual(
            name=name + &#34;_visual&#34;,
            parent=self,
            path=r&#34;shackle_gp800.obj&#34;,
            offset=(0, 0, 0),
            rotation=(0, 0, 0),
        )

        self.kind = kind

        for n in self.managed_nodes():
            n.manager = self

    def depends_on(self):
        return []

    @property
    def kind(self):
        &#34;&#34;&#34;Type of shackle, for example GP800 [text]&#34;&#34;&#34;
        return self._kind

    @kind.setter
    # @node_setter_manageable   : allow changing of shackle kind
    @node_setter_observable
    def kind(self, kind):

        values = self._give_values(kind)
        weight = values[11] / 1000  # convert to tonne
        pin_dia = values[1] / 1000
        bow_dia = values[0] / 1000
        bow_length_inside = values[5] / 1000
        bow_circle_inside = values[6] / 1000

        cogz = 0.5 * pin_dia + bow_length_inside / 3  # estimated

        remember = self._scene.current_manager

        self._scene.current_manager = (
            self.manager
        )  # WORK-AROUND : in case the shackle itself is managed, fake management

        self.mass = weight
        self.cog = (0, 0, cogz)

        self._scene.current_manager = self  # register self a manager (as it should)

        self.pin.radius = pin_dia / 2

        self.bow_point.position = (
            0.0,
            0.0,
            0.5 * pin_dia + bow_length_inside + 0.5 * bow_dia,
        )
        self.bow.radius = bow_dia / 2

        self.inside_point.position = (
            0,
            0,
            0.5 * pin_dia + bow_length_inside - 0.5 * bow_circle_inside,
        )
        self.inside.radius = bow_circle_inside / 2

        # determine the scale for the shackle
        # based on a GP800
        #
        actual_size = 0.5 * pin_dia + 0.5 * bow_dia + bow_length_inside
        gp800_size = 0.5 * 0.210 + 0.5 * 0.220 + 0.718

        scale = actual_size / gp800_size

        self.visual_node.scale = [scale, scale, scale]

        self._scene.current_manager = remember

        self._kind = kind

    def managed_nodes(self):
        return [
            self.pin_point,
            self.pin,
            self.bow_point,
            self.bow,
            self.inside_point,
            self.inside,
            self.visual_node,
        ]

    def creates(self, node: Node):
        return node in self.managed_nodes()  # all these are created

    def delete(self):

        # delete created nodes
        a = self.managed_nodes()

        for n in a:
            n._manager = None

        for n in a:
            if n in self._scene._nodes:
                self._scene.delete(n)  # delete if it is still available

    def give_python_code(self):
        code = f&#34;# Exporting {self.name}&#34;

        code += &#34;\n# Create Shackle&#34;
        code += f&#39;\ns.new_shackle(&#34;{self.name}&#34;, kind = &#34;{self.kind}&#34;)&#39;  # , elastic={self.elastic})&#39;

        if self.parent_for_export:
            code += f&#34;\ns[&#39;{self.name}&#39;].parent = s[&#39;{self.parent_for_export.name}&#39;]&#34;

        code += &#34;\ns[&#39;{}&#39;].position = ({},{},{})&#34;.format(self.name, *self.position)
        code += &#34;\ns[&#39;{}&#39;].rotation = ({},{},{})&#34;.format(self.name, *self.rotation)

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.Manager" href="#DAVE.scene.Manager">Manager</a></li>
<li><a title="DAVE.scene.RigidBody" href="#DAVE.scene.RigidBody">RigidBody</a></li>
<li><a title="DAVE.scene.Axis" href="#DAVE.scene.Axis">Axis</a></li>
<li><a title="DAVE.scene.NodeWithParentAndFootprint" href="#DAVE.scene.NodeWithParentAndFootprint">NodeWithParentAndFootprint</a></li>
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="DAVE.scene.Shackle.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Shackle.kind"><code class="name">var <span class="ident">kind</span></code></dt>
<dd>
<div class="desc"><p>Type of shackle, for example GP800 [text]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def kind(self):
    &#34;&#34;&#34;Type of shackle, for example GP800 [text]&#34;&#34;&#34;
    return self._kind</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.Shackle.defined_kinds"><code class="name flex">
<span>def <span class="ident">defined_kinds</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Defined shackle kinds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def defined_kinds(self):
    &#34;&#34;&#34;Defined shackle kinds&#34;&#34;&#34;
    list = [a for a in Shackle.data.keys()]
    return list</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Shackle.managed_nodes"><code class="name flex">
<span>def <span class="ident">managed_nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def managed_nodes(self):
    return [
        self.pin_point,
        self.pin,
        self.bow_point,
        self.bow,
        self.inside_point,
        self.inside,
        self.visual_node,
    ]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.Manager" href="#DAVE.scene.Manager">Manager</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.Manager.creates" href="#DAVE.scene.Manager.creates">creates</a></code></li>
<li><code><a title="DAVE.scene.Manager.delete" href="#DAVE.scene.Manager.delete">delete</a></code></li>
<li><code><a title="DAVE.scene.Manager.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.Manager.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.Manager.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.Manager.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.Manager.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
<li><code><b><a title="DAVE.scene.RigidBody" href="#DAVE.scene.RigidBody">RigidBody</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.RigidBody.applied_force" href="#DAVE.scene.Axis.applied_force">applied_force</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.cog" href="#DAVE.scene.RigidBody.cog">cog</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.cogx" href="#DAVE.scene.RigidBody.cogx">cogx</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.cogy" href="#DAVE.scene.RigidBody.cogy">cogy</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.cogz" href="#DAVE.scene.RigidBody.cogz">cogz</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.connection_force" href="#DAVE.scene.Axis.connection_force">connection_force</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.connection_force_x" href="#DAVE.scene.Axis.connection_force_x">connection_force_x</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.connection_force_y" href="#DAVE.scene.Axis.connection_force_y">connection_force_y</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.connection_force_z" href="#DAVE.scene.Axis.connection_force_z">connection_force_z</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.connection_moment_x" href="#DAVE.scene.Axis.connection_moment_x">connection_moment_x</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.connection_moment_y" href="#DAVE.scene.Axis.connection_moment_y">connection_moment_y</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.connection_moment_z" href="#DAVE.scene.Axis.connection_moment_z">connection_moment_z</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.equilibrium_error" href="#DAVE.scene.Axis.equilibrium_error">equilibrium_error</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.fixed" href="#DAVE.scene.Axis.fixed">fixed</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.footprint" href="#DAVE.scene.NodeWithParentAndFootprint.footprint">footprint</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.give_load_shear_moment_diagram" href="#DAVE.scene.Axis.give_load_shear_moment_diagram">give_load_shear_moment_diagram</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.global_position" href="#DAVE.scene.Axis.global_position">global_position</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.global_rotation" href="#DAVE.scene.Axis.global_rotation">global_rotation</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.global_transform" href="#DAVE.scene.Axis.global_transform">global_transform</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.grx" href="#DAVE.scene.Axis.grx">grx</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.gry" href="#DAVE.scene.Axis.gry">gry</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.grz" href="#DAVE.scene.Axis.grz">grz</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.gx" href="#DAVE.scene.Axis.gx">gx</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.gy" href="#DAVE.scene.Axis.gy">gy</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.gz" href="#DAVE.scene.Axis.gz">gz</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.heading" href="#DAVE.scene.Axis.heading">heading</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.heading_compass" href="#DAVE.scene.Axis.heading_compass">heading_compass</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.heel" href="#DAVE.scene.Axis.heel">heel</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.inertia" href="#DAVE.scene.Axis.inertia">inertia</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.inertia_position" href="#DAVE.scene.Axis.inertia_position">inertia_position</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.inertia_radii" href="#DAVE.scene.Axis.inertia_radii">inertia_radii</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.mass" href="#DAVE.scene.RigidBody.mass">mass</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.parent" href="#DAVE.scene.Axis.parent">parent</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.position" href="#DAVE.scene.Axis.position">position</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.rotation" href="#DAVE.scene.Axis.rotation">rotation</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.rx" href="#DAVE.scene.Axis.rx">rx</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.ry" href="#DAVE.scene.Axis.ry">ry</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.rz" href="#DAVE.scene.Axis.rz">rz</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.set_fixed" href="#DAVE.scene.Axis.set_fixed">set_fixed</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.set_free" href="#DAVE.scene.Axis.set_free">set_free</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.tilt_x" href="#DAVE.scene.Axis.tilt_x">tilt_x</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.tilt_y" href="#DAVE.scene.Axis.tilt_y">tilt_y</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.to_glob_direction" href="#DAVE.scene.Axis.to_glob_direction">to_glob_direction</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.to_glob_position" href="#DAVE.scene.Axis.to_glob_position">to_glob_position</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.to_glob_rotation" href="#DAVE.scene.Axis.to_glob_rotation">to_glob_rotation</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.to_loc_direction" href="#DAVE.scene.Axis.to_loc_direction">to_loc_direction</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.to_loc_position" href="#DAVE.scene.Axis.to_loc_position">to_loc_position</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.to_loc_rotation" href="#DAVE.scene.Axis.to_loc_rotation">to_loc_rotation</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.trim" href="#DAVE.scene.Axis.trim">trim</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.ux" href="#DAVE.scene.Axis.ux">ux</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.uy" href="#DAVE.scene.Axis.uy">uy</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.uz" href="#DAVE.scene.Axis.uz">uz</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.x" href="#DAVE.scene.Axis.x">x</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.y" href="#DAVE.scene.Axis.y">y</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.z" href="#DAVE.scene.Axis.z">z</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.Sling"><code class="flex name class">
<span>class <span class="ident">Sling</span></span>
<span>(</span><span>scene, name, length, LeyeA, LeyeB, LspliceA, LspliceB, diameter, EA, mass, endA=None, endB=None, sheaves=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Sling is a single wire with an eye on each end. The eyes are created by splicing the end of the sling back
into the itself.</p>
<p>The geometry of a sling is defined as follows:</p>
<p>diameter : diameter of the wire
LeyeA, LeyeB : inside lengths of the eyes
LsplicaA, LspliceB : the length of the splices
Total : the distance between the insides of ends of the eyes A and B when pulled straight.</p>
<p>Stiffness:
The stiffness of the sling is specified by a single value: EA
This determines the stiffnesses of the individual parts as follows:
Wire in the eyes: EA
Splices: Infinity (rigid)
Main part: determined such that total stiffness (k) of the sling is EA/L</p>
<p>Eye A
Splice A
nodeA part
Splice B
Eye B</p>
<p>/---------------\
/---------------
|
=============-------------------------------------===============
|
---------------/
---------------/</p>
<p>See Also: Grommet</p>
<p>Creates a new sling with the following structure</p>
<pre><code>endA
eyeA (cable)
splice (body , mass/2)
nodeA (cable)     [optional: runs over sheave]
splice (body, mass/2)
eyeB (cable)
endB
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scene</code></strong></dt>
<dd>
<p>The scene in which the sling should be created</p>
</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Name prefix</dd>
<dt><strong><code>length</code></strong></dt>
<dd>Total length measured between the inside of the eyes of the sling is pulled straight.</dd>
<dt><strong><code>LeyeA</code></strong></dt>
<dd>Total inside length in eye A if stretched flat</dd>
<dt><strong><code>LeyeB</code></strong></dt>
<dd>Total inside length in eye B if stretched flat</dd>
<dt><strong><code>LspliceA</code></strong></dt>
<dd>Length of the splice at end A</dd>
<dt><strong><code>LspliceB</code></strong></dt>
<dd>Length of the splice at end B</dd>
<dt><strong><code>diameter</code></strong></dt>
<dd>Diameter of the sling</dd>
<dt><strong><code>EA</code></strong></dt>
<dd>Effective mean EA of the sling</dd>
<dt><strong><code>mass</code></strong></dt>
<dd>total mass</dd>
<dt><strong><code>endA</code></strong> :&ensp;<code>Sheave</code> or <code>poi to fix end A</code> of <code>the sling to [optional]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>endB</code></strong> :&ensp;<code>Sheave</code> or <code>poi to fix end A</code> of <code>the sling to [optional]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>sheave</code></strong> :&ensp;<code>Sheave</code> or <code>poi for the nodeA part</code> of <code>the sling</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sling(Manager):
    &#34;&#34;&#34;A Sling is a single wire with an eye on each end. The eyes are created by splicing the end of the sling back
    into the itself.

    The geometry of a sling is defined as follows:

    diameter : diameter of the wire
    LeyeA, LeyeB : inside lengths of the eyes
    LsplicaA, LspliceB : the length of the splices
    Total : the distance between the insides of ends of the eyes A and B when pulled straight.

    Stiffness:
    The stiffness of the sling is specified by a single value: EA
    This determines the stiffnesses of the individual parts as follows:
    Wire in the eyes: EA
    Splices: Infinity (rigid)
    Main part: determined such that total stiffness (k) of the sling is EA/L


      Eye A           Splice A             nodeA part                   Splice B          Eye B

    /---------------\                                                                /---------------\
    |                =============-------------------------------------===============                |
    \---------------/                                                                \---------------/

    See Also: Grommet

    &#34;&#34;&#34;

    def __init__(
        self,
        scene,
        name,
        length,
        LeyeA,
        LeyeB,
        LspliceA,
        LspliceB,
        diameter,
        EA,
        mass,
        endA=None,
        endB=None,
        sheaves=None,
    ):
        &#34;&#34;&#34;
        Creates a new sling with the following structure

            endA
            eyeA (cable)
            splice (body , mass/2)
            nodeA (cable)     [optional: runs over sheave]
            splice (body, mass/2)
            eyeB (cable)
            endB

        Args:
            scene:     The scene in which the sling should be created
            name:  Name prefix
            length: Total length measured between the inside of the eyes of the sling is pulled straight.
            LeyeA: Total inside length in eye A if stretched flat
            LeyeB: Total inside length in eye B if stretched flat
            LspliceA: Length of the splice at end A
            LspliceB: Length of the splice at end B
            diameter: Diameter of the sling
            EA: Effective mean EA of the sling
            mass: total mass
            endA : Sheave or poi to fix end A of the sling to [optional]
            endB : Sheave or poi to fix end A of the sling to [optional]
            sheave : Sheave or poi for the nodeA part of the sling

        Returns:

        &#34;&#34;&#34;

        super().__init__(scene)
        self.name = name

        name_prefix = self.name + vfc.MANAGED_NODE_IDENTIFIER

        # store the properties
        self._length = length
        self._LeyeA = LeyeA
        self._LeyeB = LeyeB
        self._LspliceA = LspliceA
        self._LspliceB = LspliceB
        self._diameter = diameter
        self._EA = EA
        self._mass = mass
        self._endA = scene._poi_or_sheave_from_node(endA)
        self._endB = scene._poi_or_sheave_from_node(endB)

        # create the two splices

        self.sa = scene.new_rigidbody(
            scene.available_name_like(name_prefix + &#34;_spliceA&#34;), fixed=False
        )
        self.a1 = scene.new_point(
            scene.available_name_like(name_prefix + &#34;_spliceA&#34;), parent=self.sa
        )
        self.a2 = scene.new_point(
            scene.available_name_like(name_prefix + &#34;_spliceA2&#34;), parent=self.sa
        )
        self.am = scene.new_point(
            scene.available_name_like(name_prefix + &#34;_spliceAM&#34;), parent=self.sa
        )

        self.avis = scene.new_visual(
            name + &#34;_spliceA_visual&#34;,
            parent=self.sa,
            path=r&#34;cylinder 1x1x1 lowres.obj&#34;,
            offset=(-LspliceA / 2, 0.0, 0.0),
            rotation=(0.0, 90.0, 0.0),
            scale=(LspliceA, 2 * diameter, diameter),
        )

        self.sb = scene.new_rigidbody(
            scene.available_name_like(name_prefix + &#34;_spliceB&#34;),
            rotation=(0, 0, 180),
            fixed=False,
        )
        self.b1 = scene.new_point(
            scene.available_name_like(name_prefix + &#34;_spliceB1&#34;), parent=self.sb
        )
        self.b2 = scene.new_point(
            scene.available_name_like(name_prefix + &#34;_spliceB2&#34;), parent=self.sb
        )
        self.bm = scene.new_point(
            scene.available_name_like(name_prefix + &#34;_spliceBM&#34;), parent=self.sb
        )

        self.bvis = scene.new_visual(
            scene.available_name_like(name_prefix + &#34;_spliceB_visual&#34;),
            parent=self.sb,
            path=r&#34;cylinder 1x1x1 lowres.obj&#34;,
            offset=(-LspliceB / 2, 0.0, 0.0),
            rotation=(0.0, 90.0, 0.0),
            scale=(LspliceB, 2 * diameter, diameter),
        )

        self.main = scene.new_cable(
            scene.available_name_like(name_prefix + &#34;_main_part&#34;),
            endA=self.am,
            endB=self.bm,
            length=1,
            EA=1,
            diameter=diameter,
        )

        self.eyeA = scene.new_cable(
            scene.available_name_like(name_prefix + &#34;_eyeA&#34;),
            endA=self.a1,
            endB=self.a2,
            length=1,
            EA=1,
        )
        self.eyeB = scene.new_cable(
            scene.available_name_like(name_prefix + &#34;_eyeB&#34;),
            endA=self.b1,
            endB=self.b2,
            length=1,
            EA=1,
        )

        # set initial positions of splices if we can
        if self._endA is not None and self._endB is not None:
            a = np.array(self._endA.global_position)
            b = np.array(self._endB.global_position)

            dir = b - a
            dir /= np.linalg.norm(dir)

            self.sa.rotation = rotation_from_x_axis_direction(-dir)
            self.sb.rotation = rotation_from_x_axis_direction(dir)
            self.sa.position = a + (LeyeA + 0.5 * LspliceA) * dir
            self.sb.position = b - (LeyeB + 0.5 * LspliceB) * dir

        # Update properties
        self.sheaves = sheaves
        self._update_properties()

        for n in self.managed_nodes():
            n.manager = self

    def _update_properties(self):

        # The stiffness of the nodeA part is corrected to account for the stiffness of the splices.
        # It is considered that the stiffness of the splices is two times that of the wire.
        #
        # Springs in series: 1/Ktotal = 1/k1 + 1/k2 + 1/k3

        backup = self._scene.current_manager  # store
        self._scene.current_manager = self

        Lmain = (
            self._length - self._LspliceA - self._LspliceB - self._LeyeA - self._LeyeB
        )

        if self._EA == 0:
            EAmain = 0
        else:
            ka = 2 * self._EA / self._LspliceA
            kb = 2 * self._EA / self._LspliceB
            kmain = self._EA / Lmain
            k_total = 1 / ((1 / ka) + (1 / kmain) + (1 / kb))

            EAmain = k_total * Lmain

        self.sa.mass = self._mass / 2
        self.sa.inertia_radii = (
            self._LspliceA / 2,
            self._LspliceA / 2,
            self._diameter / 2,
        )

        self.a1.position = (self._LspliceA / 2, self._diameter / 2, 0)
        self.a2.position = (self._LspliceA / 2, -self._diameter / 2, 0)
        self.am.position = (-self._LspliceA / 2, 0, 0)

        self.avis.offset = (-self._LspliceA / 2, 0.0, 0.0)
        self.avis.scale = (self._LspliceA, 2 * self._diameter, self._diameter)

        self.sb.mass = self._mass / 2
        self.sb.inertia_radii = (
            self._LspliceB / 2,
            self._LspliceB / 2,
            self._diameter / 2,
        )

        self.b1.position = (self._LspliceB / 2, self._diameter / 2, 0)
        self.b2.position = (self._LspliceB / 2, -self._diameter / 2, 0)
        self.bm.position = (-self._LspliceB / 2, 0, 0)

        self.bvis.offset = (-self._LspliceB / 2, 0.0, 0.0)
        self.bvis.scale = (self._LspliceB, 2 * self._diameter, self._diameter)

        self.main.length = Lmain
        self.main.EA = EAmain
        self.main.diameter = self._diameter
        self.main.connections = tuple([self.am, *self._sheaves, self.bm])

        self.eyeA.length = self._LeyeA * 2 - self._diameter
        self.eyeA.EA = self._EA
        self.eyeA.diameter = self._diameter

        if self._endA is not None:
            self.eyeA.connections = (self.a1, self._endA, self.a2)
        else:
            self.eyeA.connections = (self.a1, self.a2)

        self.eyeB.length = self._LeyeB * 2 - self._diameter
        self.eyeB.EA = self._EA
        self.eyeB.diameter = self._diameter

        if self._endB is not None:
            self.eyeB.connections = (self.b1, self._endB, self.b2)
        else:
            self.eyeB.connections = (self.b1, self.b2)

        self._scene.current_manager = backup  # restore

    def depends_on(self):
        &#34;&#34;&#34;The sling depends on the endpoints and sheaves (if any)&#34;&#34;&#34;

        a = list()

        if self._endA is not None:
            a.append(self._endA)
        if self._endB is not None:
            a.append(self._endB)

        a.extend(self.sheaves)

        return a

    def managed_nodes(self):
        a = [
            self.sa,
            self.a1,
            self.a2,
            self.am,
            self.avis,
            self.sb,
            self.b1,
            self.b2,
            self.bm,
            self.bvis,
            self.main,
            self.eyeA,
            self.eyeB,
        ]

        return a

    def creates(self, node: Node):
        return node in self.managed_nodes()  # all these are created

    def delete(self):

        # delete created nodes
        a = self.managed_nodes()

        for n in a:
            n._manager = None

        for n in a:
            if n in self._scene._nodes:
                self._scene.delete(n)  # delete if it is still available

    def give_python_code(self):
        code = f&#34;# Exporting {self.name}&#34;

        # if self.endA is not None:
        #     code += self.endA.give_python_code()
        # if self.endB is not None:
        #     code += self.endB.give_python_code()
        # for s in self.sheaves:
        #     code += s.give_python_code()

        code += &#34;\n# Create sling&#34;

        # (self, scene, name, Ltotal, LeyeA, LeyeB, LspliceA, LspliceB, diameter, EA, mass, endA = None, endB=None, sheaves=None):

        code += f&#39;\ns.new_sling(&#34;{self.name}&#34;, length = {self.length},&#39;
        code += f&#34;\n            LeyeA = {self.LeyeA},&#34;
        code += f&#34;\n            LeyeB = {self.LeyeB},&#34;
        code += f&#34;\n            LspliceA = {self.LspliceA},&#34;
        code += f&#34;\n            LspliceB = {self.LspliceB},&#34;
        code += f&#34;\n            diameter = {self.diameter},&#34;
        code += f&#34;\n            EA = {self.EA},&#34;
        code += f&#34;\n            mass = {self.mass},&#34;
        code += f&#39;\n            endA = &#34;{self.endA.name}&#34;,&#39;
        code += f&#39;\n            endB = &#34;{self.endB.name}&#34;,&#39;

        if self.sheaves:
            sheaves = &#34;[&#34;
            for s in self.sheaves:
                sheaves += f&#39;&#34;{s.name}&#34;, &#39;
            sheaves = sheaves[:-2] + &#34;]&#34;
        else:
            sheaves = &#34;None&#34;

        code += f&#34;\n            sheaves = {sheaves})&#34;

        return code

    # properties
    @property
    def length(self):
        &#34;&#34;&#34;Total length measured between the INSIDE of the eyes of the sling is pulled straight. [m]&#34;&#34;&#34;
        return self._length

    @length.setter
    @node_setter_manageable
    @node_setter_observable
    def length(self, value):

        min_length = self.LeyeA + self.LeyeB + self.LspliceA + self.LspliceB
        if value &lt;= min_length:
            raise ValueError(
                &#34;Total length of the sling should be at least the length of the eyes plus the length of the splices&#34;
            )

        self._length = value
        self._update_properties()

    @property
    def LeyeA(self):
        &#34;&#34;&#34;Total length inside eye A if stretched flat [m]&#34;&#34;&#34;
        return self._LeyeA

    @LeyeA.setter
    @node_setter_manageable
    @node_setter_observable
    def LeyeA(self, value):

        max_length = self.length - (self.LeyeB + self.LspliceA + self.LspliceB)
        if value &gt;= max_length:
            raise ValueError(
                &#34;Total length of the sling should be at least the length of the eyes plus the length of the splices&#34;
            )

        self._LeyeA = value
        self._update_properties()

    @property
    def LeyeB(self):
        &#34;&#34;&#34;Total length inside eye B if stretched flat [m]&#34;&#34;&#34;
        return self._LeyeB

    @LeyeB.setter
    @node_setter_manageable
    @node_setter_observable
    def LeyeB(self, value):

        max_length = self.length - (self.LeyeA + self.LspliceA + self.LspliceB)
        if value &gt;= max_length:
            raise ValueError(
                &#34;Total length of the sling should be at least the length of the eyes plus the length of the splices&#34;
            )

        self._LeyeB = value
        self._update_properties()

    @property
    def LspliceA(self):
        &#34;&#34;&#34;Length of the splice at end A [m]&#34;&#34;&#34;
        return self._LspliceA

    @LspliceA.setter
    @node_setter_manageable
    @node_setter_observable
    def LspliceA(self, value):

        max_length = self.length - (self.LeyeA + self.LeyeB + self.LspliceB)
        if value &gt;= max_length:
            raise ValueError(
                &#34;Total length of the sling should be at least the length of the eyes plus the length of the splices&#34;
            )

        self._LspliceA = value
        self._update_properties()

    @property
    def LspliceB(self):
        &#34;&#34;&#34;Length of the splice at end B [m]&#34;&#34;&#34;
        return self._LspliceB

    @LspliceB.setter
    @node_setter_manageable
    @node_setter_observable
    def LspliceB(self, value):

        max_length = self.length - (self.LeyeA + self.LeyeB + self.LspliceA)
        if value &gt;= max_length:
            raise ValueError(
                &#34;Total length of the sling should be at least the length of the eyes plus the length of the splices&#34;
            )

        self._LspliceB = value
        self._update_properties()

    @property
    def diameter(self):
        &#34;&#34;&#34;Diameter of the sling (except the splices) [m]&#34;&#34;&#34;
        return self._diameter

    @diameter.setter
    @node_setter_manageable
    @node_setter_observable
    def diameter(self, value):
        self._diameter = value
        self._update_properties()

    @property
    def EA(self):
        &#34;&#34;&#34;Effective mean EA of the sling when eyes are flat [kN].
        This is the EA that would be obtained when measuring the stiffness of the sling by putting zero-diameter pins in the eyes and stretching the sling and then using the length between the insides of the eyes.&#34;&#34;&#34;
        return self._EA

    @EA.setter
    @node_setter_manageable
    @node_setter_observable
    def EA(self, value):
        self._EA = value
        self._update_properties()

    @property
    def mass(self):
        &#34;&#34;&#34;Mass and weight of the sling. This mass is discretized  distributed over the two splices [mT]&#34;&#34;&#34;
        return self._mass

    @mass.setter
    @node_setter_manageable
    @node_setter_observable
    def mass(self, value):
        self._mass = value
        self._update_properties()

    @property
    def endA(self):
        &#34;&#34;&#34;End A [circle or point node]&#34;&#34;&#34;
        return self._endA

    @endA.setter
    @node_setter_manageable
    @node_setter_observable
    def endA(self, value):
        node = self._scene._node_from_node_or_str(value)
        self._endA = self._scene._poi_or_sheave_from_node(node)
        self._update_properties()

    @property
    def endB(self):
        &#34;&#34;&#34;End B [circle or point node]&#34;&#34;&#34;
        return self._endB

    @endB.setter
    @node_setter_manageable
    @node_setter_observable
    def endB(self, value):
        node = self._scene._node_from_node_or_str(value)
        self._endB = self._scene._poi_or_sheave_from_node(node)
        self._update_properties()

    @property
    def sheaves(self):
        &#34;&#34;&#34;List of sheaves (circles, points) that the sling runs over between the two ends.

        May be provided as list of nodes or node-names.
        &#34;&#34;&#34;
        return self._sheaves

    @sheaves.setter
    @node_setter_manageable
    @node_setter_observable
    def sheaves(self, value):
        s = []
        for v in value:
            node = self._scene._node_from_node_or_str(v)
            s.append(self._scene._poi_or_sheave_from_node(node))
        self._sheaves = s
        self._update_properties()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.Manager" href="#DAVE.scene.Manager">Manager</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Sling.EA"><code class="name">var <span class="ident">EA</span></code></dt>
<dd>
<div class="desc"><p>Effective mean EA of the sling when eyes are flat [kN].
This is the EA that would be obtained when measuring the stiffness of the sling by putting zero-diameter pins in the eyes and stretching the sling and then using the length between the insides of the eyes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def EA(self):
    &#34;&#34;&#34;Effective mean EA of the sling when eyes are flat [kN].
    This is the EA that would be obtained when measuring the stiffness of the sling by putting zero-diameter pins in the eyes and stretching the sling and then using the length between the insides of the eyes.&#34;&#34;&#34;
    return self._EA</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Sling.LeyeA"><code class="name">var <span class="ident">LeyeA</span></code></dt>
<dd>
<div class="desc"><p>Total length inside eye A if stretched flat [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def LeyeA(self):
    &#34;&#34;&#34;Total length inside eye A if stretched flat [m]&#34;&#34;&#34;
    return self._LeyeA</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Sling.LeyeB"><code class="name">var <span class="ident">LeyeB</span></code></dt>
<dd>
<div class="desc"><p>Total length inside eye B if stretched flat [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def LeyeB(self):
    &#34;&#34;&#34;Total length inside eye B if stretched flat [m]&#34;&#34;&#34;
    return self._LeyeB</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Sling.LspliceA"><code class="name">var <span class="ident">LspliceA</span></code></dt>
<dd>
<div class="desc"><p>Length of the splice at end A [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def LspliceA(self):
    &#34;&#34;&#34;Length of the splice at end A [m]&#34;&#34;&#34;
    return self._LspliceA</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Sling.LspliceB"><code class="name">var <span class="ident">LspliceB</span></code></dt>
<dd>
<div class="desc"><p>Length of the splice at end B [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def LspliceB(self):
    &#34;&#34;&#34;Length of the splice at end B [m]&#34;&#34;&#34;
    return self._LspliceB</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Sling.diameter"><code class="name">var <span class="ident">diameter</span></code></dt>
<dd>
<div class="desc"><p>Diameter of the sling (except the splices) [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def diameter(self):
    &#34;&#34;&#34;Diameter of the sling (except the splices) [m]&#34;&#34;&#34;
    return self._diameter</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Sling.endA"><code class="name">var <span class="ident">endA</span></code></dt>
<dd>
<div class="desc"><p>End A [circle or point node]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def endA(self):
    &#34;&#34;&#34;End A [circle or point node]&#34;&#34;&#34;
    return self._endA</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Sling.endB"><code class="name">var <span class="ident">endB</span></code></dt>
<dd>
<div class="desc"><p>End B [circle or point node]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def endB(self):
    &#34;&#34;&#34;End B [circle or point node]&#34;&#34;&#34;
    return self._endB</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Sling.length"><code class="name">var <span class="ident">length</span></code></dt>
<dd>
<div class="desc"><p>Total length measured between the INSIDE of the eyes of the sling is pulled straight. [m]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def length(self):
    &#34;&#34;&#34;Total length measured between the INSIDE of the eyes of the sling is pulled straight. [m]&#34;&#34;&#34;
    return self._length</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Sling.mass"><code class="name">var <span class="ident">mass</span></code></dt>
<dd>
<div class="desc"><p>Mass and weight of the sling. This mass is discretized
distributed over the two splices [mT]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mass(self):
    &#34;&#34;&#34;Mass and weight of the sling. This mass is discretized  distributed over the two splices [mT]&#34;&#34;&#34;
    return self._mass</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Sling.sheaves"><code class="name">var <span class="ident">sheaves</span></code></dt>
<dd>
<div class="desc"><p>List of sheaves (circles, points) that the sling runs over between the two ends.</p>
<p>May be provided as list of nodes or node-names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sheaves(self):
    &#34;&#34;&#34;List of sheaves (circles, points) that the sling runs over between the two ends.

    May be provided as list of nodes or node-names.
    &#34;&#34;&#34;
    return self._sheaves</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.Sling.depends_on"><code class="name flex">
<span>def <span class="ident">depends_on</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The sling depends on the endpoints and sheaves (if any)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def depends_on(self):
    &#34;&#34;&#34;The sling depends on the endpoints and sheaves (if any)&#34;&#34;&#34;

    a = list()

    if self._endA is not None:
        a.append(self._endA)
    if self._endB is not None:
        a.append(self._endB)

    a.extend(self.sheaves)

    return a</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Sling.managed_nodes"><code class="name flex">
<span>def <span class="ident">managed_nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def managed_nodes(self):
    a = [
        self.sa,
        self.a1,
        self.a2,
        self.am,
        self.avis,
        self.sb,
        self.b1,
        self.b2,
        self.bm,
        self.bvis,
        self.main,
        self.eyeA,
        self.eyeB,
    ]

    return a</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.Manager" href="#DAVE.scene.Manager">Manager</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.Manager.creates" href="#DAVE.scene.Manager.creates">creates</a></code></li>
<li><code><a title="DAVE.scene.Manager.delete" href="#DAVE.scene.Manager.delete">delete</a></code></li>
<li><code><a title="DAVE.scene.Manager.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.Manager.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.Manager.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.Manager.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.Tank"><code class="flex name class">
<span>class <span class="ident">Tank</span></span>
<span>(</span><span>scene, vfTank)</span>
</code></dt>
<dd>
<div class="desc"><p>Tank provides a fillable tank based on a mesh. The mesh is triangulated and chopped at the instantaneous flat fluid surface. Gravity is applied as an downwards force that the center of fluid.
The calculation of fluid volume and center is as accurate as the provided geometry.</p>
<p>There as no restrictions to the size or aspect ratio of the panels. It is excellent to model as box using 6 faces. Using smaller panels has a negative effect on performance.</p>
<p>The normals of the panels should point <em>away</em> from the fluid. This means that the same basic shapes can be used for both buoyancy and tanks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tank(NodeWithParent):
    &#34;&#34;&#34;Tank provides a fillable tank based on a mesh. The mesh is triangulated and chopped at the instantaneous flat fluid surface. Gravity is applied as an downwards force that the center of fluid.
    The calculation of fluid volume and center is as accurate as the provided geometry.

    There as no restrictions to the size or aspect ratio of the panels. It is excellent to model as box using 6 faces. Using smaller panels has a negative effect on performance.

    The normals of the panels should point *away* from the fluid. This means that the same basic shapes can be used for both buoyancy and tanks.
    &#34;&#34;&#34;

    # init parent and name are fully derived from NodeWithParent
    # _vfNode is a tank
    def __init__(self, scene, vfTank):
        super().__init__(scene, vfTank)
        self._None_parent_acceptable = False
        self._trimesh = TriMeshSource(
            self._scene, self._vfNode.trimesh
        )  # the tri-mesh is wrapped in a custom object

        self._inertia = scene._vfc.new_pointmass(
            self.name + vfc.VF_NAME_SPLIT + &#34;inertia&#34;
        )

    def update(self):
        self._vfNode.reloadTrimesh()

        # update inertia
        self._inertia.parent = self.parent._vfNode
        self._inertia.position = self.cog_local
        self._inertia.inertia = self.volume * self.density


    def _delete_vfc(self):
        self._scene._vfc.delete(self._inertia.name)
        super()._delete_vfc()

    @property
    def trimesh(self) -&gt; TriMeshSource:
        return self._trimesh

    @property
    def free_flooding(self):
        return self._vfNode.free_flooding

    @free_flooding.setter
    def free_flooding(self, value):
        assert isinstance(value, bool), ValueError(
            f&#34;free_flooding shall be a bool, you passed a {type(value)}&#34;
        )
        self._vfNode.free_flooding = value

    @property
    def permeability(self):
        &#34;&#34;&#34;Permeability is the fraction of the enclosed volume that can be filled with fluid [-]&#34;&#34;&#34;
        return self._vfNode.permeability

    @permeability.setter
    def permeability(self, value):
        assert1f_positive_or_zero(value)
        self._vfNode.permeability = value

    @property
    def cog(self):
        &#34;&#34;&#34;Returns the GLOBAL position of the center of volume / gravity&#34;&#34;&#34;
        return self._vfNode.cog

    @property
    def cog_local(self):
        &#34;&#34;&#34;Returns the local position of the center of gravity&#34;&#34;&#34;
        return self.parent.to_loc_position(self.cog)

    @property
    def cog_when_full(self):
        &#34;&#34;&#34;Returns the LOCAL position of the center of volume / gravity of the tank when it is filled&#34;&#34;&#34;
        return self._vfNode.cog_when_full

    @property
    def fill_pct(self):
        &#34;&#34;&#34;Amount of volume in tank as percentage of capacity [%]&#34;&#34;&#34;
        if self.capacity == 0:
            return 0
        return 100 * self.volume / self.capacity

    @fill_pct.setter
    @node_setter_manageable
    @node_setter_observable
    def fill_pct(self, value):

        if value &lt; 0 and value &gt; -0.01:
            value = 0

        assert1f_positive_or_zero(value)

        if value &gt; 100.1:
            raise ValueError(
                f&#34;Fill percentage should be between 0 and 100 [%], {value} is not valid&#34;
            )
        if value &gt; 100:
            value = 100
        self.volume = value * self.capacity / 100

    @property
    def level_global(self):
        &#34;&#34;&#34;The fluid plane elevation in the global axis system. Setting this adjusts the volume&#34;&#34;&#34;
        return self._vfNode.fluid_level_global

    @level_global.setter
    @node_setter_manageable
    @node_setter_observable
    def level_global(self, value):
        assert1f(value)
        self._vfNode.fluid_level_global = value

    @property
    def volume(self):
        &#34;&#34;&#34;The volume of fluid in the tank in m3. Setting this adjusts the fluid level&#34;&#34;&#34;
        return self._vfNode.volume

    @volume.setter
    @node_setter_manageable
    @node_setter_observable
    def volume(self, value):
        assert1f_positive_or_zero(value, &#34;Volume&#34;)
        self._vfNode.volume = value

    @property
    def density(self):
        &#34;&#34;&#34;Density of the fluid in the tank in mT/m3&#34;&#34;&#34;
        return self._vfNode.density

    @density.setter
    @node_setter_manageable
    @node_setter_observable
    def density(self, value):
        assert1f(value)
        self._vfNode.density = value

    @property
    def capacity(self):
        &#34;&#34;&#34;Returns the capacity of the tank in m3. This is calculated from the defined geometry.&#34;&#34;&#34;
        return self._vfNode.capacity

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)
        code += &#34;\nmesh = s.new_tank(name=&#39;{}&#39;,&#34;.format(self.name)

        if self.density != 1.025:
            code += f&#34;\n          density={self.density},&#34;

        if self.free_flooding:
            code += f&#34;\n          free_flooding=True,&#34;

        code += &#34;\n          parent=&#39;{}&#39;)&#34;.format(self.parent_for_export.name)

        if self.trimesh._invert_normals:
            code += &#34;\nmesh.trimesh.load_file(r&#39;{}&#39;, scale = ({},{},{}), rotation = ({},{},{}), offset = ({},{},{}), invert_normals=True)&#34;.format(
                self.trimesh._path,
                *self.trimesh._scale,
                *self.trimesh._rotation,
                *self.trimesh._offset,
            )
        else:
            code += &#34;\nmesh.trimesh.load_file(r&#39;{}&#39;, scale = ({},{},{}), rotation = ({},{},{}), offset = ({},{},{}))&#34;.format(
                self.trimesh._path,
                *self.trimesh._scale,
                *self.trimesh._rotation,
                *self.trimesh._offset,
            )
        code += f&#34;\ns[&#39;{self.name}&#39;].volume = {self.volume}   # first load mesh, then set volume&#34;

        return code</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></li>
<li><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></li>
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Tank.capacity"><code class="name">var <span class="ident">capacity</span></code></dt>
<dd>
<div class="desc"><p>Returns the capacity of the tank in m3. This is calculated from the defined geometry.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def capacity(self):
    &#34;&#34;&#34;Returns the capacity of the tank in m3. This is calculated from the defined geometry.&#34;&#34;&#34;
    return self._vfNode.capacity</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Tank.cog"><code class="name">var <span class="ident">cog</span></code></dt>
<dd>
<div class="desc"><p>Returns the GLOBAL position of the center of volume / gravity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cog(self):
    &#34;&#34;&#34;Returns the GLOBAL position of the center of volume / gravity&#34;&#34;&#34;
    return self._vfNode.cog</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Tank.cog_local"><code class="name">var <span class="ident">cog_local</span></code></dt>
<dd>
<div class="desc"><p>Returns the local position of the center of gravity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cog_local(self):
    &#34;&#34;&#34;Returns the local position of the center of gravity&#34;&#34;&#34;
    return self.parent.to_loc_position(self.cog)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Tank.cog_when_full"><code class="name">var <span class="ident">cog_when_full</span></code></dt>
<dd>
<div class="desc"><p>Returns the LOCAL position of the center of volume / gravity of the tank when it is filled</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cog_when_full(self):
    &#34;&#34;&#34;Returns the LOCAL position of the center of volume / gravity of the tank when it is filled&#34;&#34;&#34;
    return self._vfNode.cog_when_full</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Tank.density"><code class="name">var <span class="ident">density</span></code></dt>
<dd>
<div class="desc"><p>Density of the fluid in the tank in mT/m3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def density(self):
    &#34;&#34;&#34;Density of the fluid in the tank in mT/m3&#34;&#34;&#34;
    return self._vfNode.density</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Tank.fill_pct"><code class="name">var <span class="ident">fill_pct</span></code></dt>
<dd>
<div class="desc"><p>Amount of volume in tank as percentage of capacity [%]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fill_pct(self):
    &#34;&#34;&#34;Amount of volume in tank as percentage of capacity [%]&#34;&#34;&#34;
    if self.capacity == 0:
        return 0
    return 100 * self.volume / self.capacity</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Tank.free_flooding"><code class="name">var <span class="ident">free_flooding</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def free_flooding(self):
    return self._vfNode.free_flooding</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Tank.level_global"><code class="name">var <span class="ident">level_global</span></code></dt>
<dd>
<div class="desc"><p>The fluid plane elevation in the global axis system. Setting this adjusts the volume</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def level_global(self):
    &#34;&#34;&#34;The fluid plane elevation in the global axis system. Setting this adjusts the volume&#34;&#34;&#34;
    return self._vfNode.fluid_level_global</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Tank.permeability"><code class="name">var <span class="ident">permeability</span></code></dt>
<dd>
<div class="desc"><p>Permeability is the fraction of the enclosed volume that can be filled with fluid [-]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def permeability(self):
    &#34;&#34;&#34;Permeability is the fraction of the enclosed volume that can be filled with fluid [-]&#34;&#34;&#34;
    return self._vfNode.permeability</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Tank.trimesh"><code class="name">var <span class="ident">trimesh</span> :Â <a title="DAVE.scene.TriMeshSource" href="#DAVE.scene.TriMeshSource">TriMeshSource</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def trimesh(self) -&gt; TriMeshSource:
    return self._trimesh</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Tank.volume"><code class="name">var <span class="ident">volume</span></code></dt>
<dd>
<div class="desc"><p>The volume of fluid in the tank in m3. Setting this adjusts the fluid level</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self):
    &#34;&#34;&#34;The volume of fluid in the tank in m3. Setting this adjusts the fluid level&#34;&#34;&#34;
    return self._vfNode.volume</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.NodeWithParent.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.parent" href="#DAVE.scene.NodeWithParent.parent">parent</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.TriMeshSource"><code class="flex name class">
<span>class <span class="ident">TriMeshSource</span></span>
<span>(</span><span>scene, source)</span>
</code></dt>
<dd>
<div class="desc"><p>TriMesh</p>
<p>A TriMesh node contains triangular mesh which can be used for buoyancy or contact</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TriMeshSource(Node):
    &#34;&#34;&#34;
    TriMesh

    A TriMesh node contains triangular mesh which can be used for buoyancy or contact

    &#34;&#34;&#34;

    def __init__(self, scene, source):

        super().__init__(scene)

        # Note: Visual does not have a corresponding vfCore Node in the scene but does have a vfCore
        self._TriMesh = source
        self._new_mesh = True  # cheat for visuals

        self._path = &#34;&#34;  # stores the data that was used to load the obj
        self._offset = (0, 0, 0)
        self._scale = (1, 1, 1)
        self._rotation = (0, 0, 0)

        self._invert_normals = False

    def depends_on(self) -&gt; list:
        return []

    def AddVertex(self, x, y, z):
        &#34;&#34;&#34;Adds a vertex (point)&#34;&#34;&#34;
        self._TriMesh.AddVertex(x, y, z)

    def AddFace(self, i, j, k):
        &#34;&#34;&#34;Adds a triangular face between vertex numbers i,j and k&#34;&#34;&#34;
        self._TriMesh.AddFace(i, j, k)

    def get_extends(self):
        &#34;&#34;&#34;Returns the extends of the mesh in global coordinates

        Returns: (minimum_x, maximum_x, minimum_y, maximum_y, minimum_z, maximum_z)

        &#34;&#34;&#34;

        t = self._TriMesh

        if t.nFaces == 0:
            return (0, 0, 0, 0, 0, 0)

        v = t.GetVertex(0)
        xn = v[0]
        xp = v[0]
        yn = v[1]
        yp = v[1]
        zn = v[2]
        zp = v[2]

        for i in range(t.nVertices):
            v = t.GetVertex(i)
            x = v[0]
            y = v[1]
            z = v[2]

            if x &lt; xn:
                xn = x
            if x &gt; xp:
                xp = x
            if y &lt; yn:
                yn = y
            if y &gt; yp:
                yp = y
            if z &lt; zn:
                zn = z
            if z &gt; zp:
                zp = z

        return (xn, xp, yn, yp, zn, zp)

    def _fromVTKpolydata(
        self, polydata, offset=None, rotation=None, scale=None, invert_normals=False
    ):

        import vtk

        tri = vtk.vtkTriangleFilter()

        tri.SetInputConnection(polydata)

        scaleFilter = vtk.vtkTransformPolyDataFilter()
        rotationFilter = vtk.vtkTransformPolyDataFilter()

        s = vtk.vtkTransform()
        s.Identity()
        r = vtk.vtkTransform()
        r.Identity()

        rotationFilter.SetInputConnection(tri.GetOutputPort())
        scaleFilter.SetInputConnection(rotationFilter.GetOutputPort())

        if scale is not None:
            s.Scale(*scale)

        if rotation is not None:
            q = rotation
            angle = (q[0] ** 2 + q[1] ** 2 + q[2] ** 2) ** (0.5)
            if angle &gt; 0:
                r.RotateWXYZ(angle, q[0] / angle, q[1] / angle, q[2] / angle)

        if offset is None:
            offset = [0, 0, 0]

        scaleFilter.SetTransform(s)
        rotationFilter.SetTransform(r)

        scaleFilter.Update()
        data = scaleFilter.GetOutput()
        self._TriMesh.Clear()

        for i in range(data.GetNumberOfPoints()):
            point = data.GetPoint(i)
            self._TriMesh.AddVertex(
                point[0] + offset[0], point[1] + offset[1], point[2] + offset[2]
            )

        for i in range(data.GetNumberOfCells()):
            cell = data.GetCell(i)

            if isinstance(cell, vtk.vtkLine):
                print(&#34;Cell nr {} is a line, not adding to mesh&#34;.format(i))
                continue

            if isinstance(cell, vtk.vtkVertex):
                print(&#34;Cell nr {} is a vertex, not adding to mesh&#34;.format(i))
                continue

            id0 = cell.GetPointId(0)
            id1 = cell.GetPointId(1)
            id2 = cell.GetPointId(2)

            if invert_normals:
                self._TriMesh.AddFace(id2, id1, id0)
            else:
                self._TriMesh.AddFace(id0, id1, id2)

        # check if anything was loaded
        if self._TriMesh.nFaces == 0:
            raise Exception(
                &#34;No faces in poly-data - no geometry added (hint: empty obj file?)&#34;
            )
        self._new_mesh = True
        self._scene.update()

    def check_shape(self):
        &#34;&#34;&#34;Performs some checks on the shape in the trimesh
        - Boundary edges (edge with only one face attached)
        - Non-manifold edges (edit with more than two faces attached)
        - Volume should be positive
        &#34;&#34;&#34;

        tm = self._TriMesh

        if tm.nFaces == 0:
            return [&#34;No mesh&#34;]

        # Make a list of all boundaries using their vertex IDs
        boundaries = np.zeros((3 * tm.nFaces, 2))
        for i in range(tm.nFaces):
            face = tm.GetFace(i)
            boundaries[3 * i] = [face[0], face[1]]
            boundaries[3 * i + 1] = [face[1], face[2]]
            boundaries[3 * i + 2] = [face[2], face[0]]

        # For an edge is doesn&#39;t matter in which direction it runs
        boundaries.sort(axis=1)

        rows_occurance_count = np.unique(boundaries, axis=0, return_counts=True)[
            1
        ]  # count of rows

        n_boundary = np.count_nonzero(rows_occurance_count == 1)
        n_nonmanifold = np.count_nonzero(rows_occurance_count &gt; 2)

        messages = []

        if n_boundary &gt; 0:
            messages.append(f&#34;Mesh contains {n_boundary} boundary edges&#34;)
        if n_nonmanifold &gt; 0:
            messages.append(f&#34;Mesh contains {n_nonmanifold} non-manifold edges&#34;)

        # Do not check for volume if we have nonmanifold geometry or boundary edges
        try:
            volume = tm.Volume()
        except:
            volume = 1  # no available in every pyo3d yet

        if volume &lt; 0:
            messages.append(
                f&#34;Total mesh volume is negative ({volume:.2f} m3 of enclosed volume).&#34;
            )
            messages.append(&#34;Hint: Use invert-normals&#34;)

        return messages

    def load_vtk_polydataSource(self, polydata):
        &#34;&#34;&#34;Fills the triangle data from a vtk polydata such as a cubeSource.

        The vtk TriangleFilter is used to triangulate the source

        Examples:
            cube = vtk.vtkCubeSource()
            cube.SetXLength(122)
            cube.SetYLength(38)
            cube.SetZLength(10)
            trimesh.load_vtk_polydataSource(cube)
        &#34;&#34;&#34;

        self._fromVTKpolydata(polydata.GetOutputPort())

    def load_obj(
        self, filename, offset=None, rotation=None, scale=None, invert_normals=False
    ):
        self.load_file(filename, offset, rotation, scale, invert_normals)

    def load_file(
        self, url, offset=None, rotation=None, scale=None, invert_normals=False
    ):
        &#34;&#34;&#34;Loads an .obj or .stl file and and triangulates it.

        Order of modifications:

        1. rotate
        2. scale
        3. offset

        Args:
            url: (str or path or resource): file to load
            offset: : offset
            rotation:  : rotation
            scale:  scale

        &#34;&#34;&#34;

        self._path = str(url)

        filename = str(self._scene.get_resource_path(url))

        import vtk

        ext = filename.lower()[-3:]
        if ext == &#34;obj&#34;:
            obj = vtk.vtkOBJReader()
            obj.SetFileName(filename)
        elif ext == &#34;stl&#34;:
            obj = vtk.vtkSTLReader()
            obj.SetFileName(filename)
        else:
            raise ValueError(
                f&#34;File should be an .obj or .stl file but has extension {ext}&#34;
            )

        # Add cleaning
        cln = vtk.vtkCleanPolyData()
        cln.SetInputConnection(obj.GetOutputPort())

        self._fromVTKpolydata(
            cln.GetOutputPort(),
            offset=offset,
            rotation=rotation,
            scale=scale,
            invert_normals=invert_normals,
        )

        self._scale = scale
        self._offset = offset
        self._rotation = rotation

        if self._scale is None:
            self._scale = (1.0, 1.0, 1.0)
        if self._offset is None:
            self._offset = (0.0, 0.0, 0.0)
        if self._rotation is None:
            self._rotation = (0.0, 0.0, 0.0)
        self._invert_normals = invert_normals

    def _load_from_privates(self):
        &#34;&#34;&#34;(Re)Loads the mesh using the values currently stored in _scale, _offset, _rotation and _invert_normals&#34;&#34;&#34;
        self.load_file(url = self._path,
                       scale=self._scale,
                       offset=self._offset,
                       rotation=self._rotation,
                       invert_normals=self._invert_normals)


    def give_python_code(self):
        code = &#34;# No code generated for TriMeshSource&#34;
        return code

    # def change_parent_to(self, new_parent):
    #
    #     if not (isinstance(new_parent, Axis) or new_parent is None):
    #         raise ValueError(&#39;Visuals can only be attached to an axis (or derived) or None&#39;)
    #
    #     # get current position and orientation
    #     if self.parent is not None:
    #         cur_position = self.parent.to_glob_position(self.offset)
    #         cur_rotation = self.parent.to_glob_direction(self.rotation)
    #     else:
    #         cur_position = self.offset
    #         cur_rotation = self.rotation
    #
    #     self.parent = new_parent
    #
    #     if new_parent is None:
    #         self.offset = cur_position
    #         self.rotation = cur_rotation
    #     else:
    #         self.offset = new_parent.to_loc_position(cur_position)
    #         self.rotation = new_parent.to_loc_direction(cur_rotation)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.TriMeshSource.AddFace"><code class="name flex">
<span>def <span class="ident">AddFace</span></span>(<span>self, i, j, k)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a triangular face between vertex numbers i,j and k</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddFace(self, i, j, k):
    &#34;&#34;&#34;Adds a triangular face between vertex numbers i,j and k&#34;&#34;&#34;
    self._TriMesh.AddFace(i, j, k)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.TriMeshSource.AddVertex"><code class="name flex">
<span>def <span class="ident">AddVertex</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a vertex (point)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddVertex(self, x, y, z):
    &#34;&#34;&#34;Adds a vertex (point)&#34;&#34;&#34;
    self._TriMesh.AddVertex(x, y, z)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.TriMeshSource.check_shape"><code class="name flex">
<span>def <span class="ident">check_shape</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs some checks on the shape in the trimesh
- Boundary edges (edge with only one face attached)
- Non-manifold edges (edit with more than two faces attached)
- Volume should be positive</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_shape(self):
    &#34;&#34;&#34;Performs some checks on the shape in the trimesh
    - Boundary edges (edge with only one face attached)
    - Non-manifold edges (edit with more than two faces attached)
    - Volume should be positive
    &#34;&#34;&#34;

    tm = self._TriMesh

    if tm.nFaces == 0:
        return [&#34;No mesh&#34;]

    # Make a list of all boundaries using their vertex IDs
    boundaries = np.zeros((3 * tm.nFaces, 2))
    for i in range(tm.nFaces):
        face = tm.GetFace(i)
        boundaries[3 * i] = [face[0], face[1]]
        boundaries[3 * i + 1] = [face[1], face[2]]
        boundaries[3 * i + 2] = [face[2], face[0]]

    # For an edge is doesn&#39;t matter in which direction it runs
    boundaries.sort(axis=1)

    rows_occurance_count = np.unique(boundaries, axis=0, return_counts=True)[
        1
    ]  # count of rows

    n_boundary = np.count_nonzero(rows_occurance_count == 1)
    n_nonmanifold = np.count_nonzero(rows_occurance_count &gt; 2)

    messages = []

    if n_boundary &gt; 0:
        messages.append(f&#34;Mesh contains {n_boundary} boundary edges&#34;)
    if n_nonmanifold &gt; 0:
        messages.append(f&#34;Mesh contains {n_nonmanifold} non-manifold edges&#34;)

    # Do not check for volume if we have nonmanifold geometry or boundary edges
    try:
        volume = tm.Volume()
    except:
        volume = 1  # no available in every pyo3d yet

    if volume &lt; 0:
        messages.append(
            f&#34;Total mesh volume is negative ({volume:.2f} m3 of enclosed volume).&#34;
        )
        messages.append(&#34;Hint: Use invert-normals&#34;)

    return messages</code></pre>
</details>
</dd>
<dt id="DAVE.scene.TriMeshSource.get_extends"><code class="name flex">
<span>def <span class="ident">get_extends</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the extends of the mesh in global coordinates</p>
<p>Returns: (minimum_x, maximum_x, minimum_y, maximum_y, minimum_z, maximum_z)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_extends(self):
    &#34;&#34;&#34;Returns the extends of the mesh in global coordinates

    Returns: (minimum_x, maximum_x, minimum_y, maximum_y, minimum_z, maximum_z)

    &#34;&#34;&#34;

    t = self._TriMesh

    if t.nFaces == 0:
        return (0, 0, 0, 0, 0, 0)

    v = t.GetVertex(0)
    xn = v[0]
    xp = v[0]
    yn = v[1]
    yp = v[1]
    zn = v[2]
    zp = v[2]

    for i in range(t.nVertices):
        v = t.GetVertex(i)
        x = v[0]
        y = v[1]
        z = v[2]

        if x &lt; xn:
            xn = x
        if x &gt; xp:
            xp = x
        if y &lt; yn:
            yn = y
        if y &gt; yp:
            yp = y
        if z &lt; zn:
            zn = z
        if z &gt; zp:
            zp = z

    return (xn, xp, yn, yp, zn, zp)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.TriMeshSource.load_file"><code class="name flex">
<span>def <span class="ident">load_file</span></span>(<span>self, url, offset=None, rotation=None, scale=None, invert_normals=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads an .obj or .stl file and and triangulates it.</p>
<p>Order of modifications:</p>
<ol>
<li>rotate</li>
<li>scale</li>
<li>offset</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong></dt>
<dd>(str or path or resource): file to load</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>: offset</dd>
<dt><strong><code>rotation</code></strong></dt>
<dd>: rotation</dd>
<dt><strong><code>scale</code></strong></dt>
<dd>scale</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_file(
    self, url, offset=None, rotation=None, scale=None, invert_normals=False
):
    &#34;&#34;&#34;Loads an .obj or .stl file and and triangulates it.

    Order of modifications:

    1. rotate
    2. scale
    3. offset

    Args:
        url: (str or path or resource): file to load
        offset: : offset
        rotation:  : rotation
        scale:  scale

    &#34;&#34;&#34;

    self._path = str(url)

    filename = str(self._scene.get_resource_path(url))

    import vtk

    ext = filename.lower()[-3:]
    if ext == &#34;obj&#34;:
        obj = vtk.vtkOBJReader()
        obj.SetFileName(filename)
    elif ext == &#34;stl&#34;:
        obj = vtk.vtkSTLReader()
        obj.SetFileName(filename)
    else:
        raise ValueError(
            f&#34;File should be an .obj or .stl file but has extension {ext}&#34;
        )

    # Add cleaning
    cln = vtk.vtkCleanPolyData()
    cln.SetInputConnection(obj.GetOutputPort())

    self._fromVTKpolydata(
        cln.GetOutputPort(),
        offset=offset,
        rotation=rotation,
        scale=scale,
        invert_normals=invert_normals,
    )

    self._scale = scale
    self._offset = offset
    self._rotation = rotation

    if self._scale is None:
        self._scale = (1.0, 1.0, 1.0)
    if self._offset is None:
        self._offset = (0.0, 0.0, 0.0)
    if self._rotation is None:
        self._rotation = (0.0, 0.0, 0.0)
    self._invert_normals = invert_normals</code></pre>
</details>
</dd>
<dt id="DAVE.scene.TriMeshSource.load_obj"><code class="name flex">
<span>def <span class="ident">load_obj</span></span>(<span>self, filename, offset=None, rotation=None, scale=None, invert_normals=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_obj(
    self, filename, offset=None, rotation=None, scale=None, invert_normals=False
):
    self.load_file(filename, offset, rotation, scale, invert_normals)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.TriMeshSource.load_vtk_polydataSource"><code class="name flex">
<span>def <span class="ident">load_vtk_polydataSource</span></span>(<span>self, polydata)</span>
</code></dt>
<dd>
<div class="desc"><p>Fills the triangle data from a vtk polydata such as a cubeSource.</p>
<p>The vtk TriangleFilter is used to triangulate the source</p>
<h2 id="examples">Examples</h2>
<p>cube = vtk.vtkCubeSource()
cube.SetXLength(122)
cube.SetYLength(38)
cube.SetZLength(10)
trimesh.load_vtk_polydataSource(cube)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_vtk_polydataSource(self, polydata):
    &#34;&#34;&#34;Fills the triangle data from a vtk polydata such as a cubeSource.

    The vtk TriangleFilter is used to triangulate the source

    Examples:
        cube = vtk.vtkCubeSource()
        cube.SetXLength(122)
        cube.SetYLength(38)
        cube.SetZLength(10)
        trimesh.load_vtk_polydataSource(cube)
    &#34;&#34;&#34;

    self._fromVTKpolydata(polydata.GetOutputPort())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.Node.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.Node.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.Node.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.Node.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.Node.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.Visual"><code class="flex name class">
<span>class <span class="ident">Visual</span></span>
<span>(</span><span>scene)</span>
</code></dt>
<dd>
<div class="desc"><p>Visual</p>
<p><img alt="" src="./images/visual.png"></p>
<p>A Visual node contains a 3d visual, typically obtained from a .obj file.
A visual node can be placed on an axis-type node.</p>
<p>It is used for visualization. It does not affect the forces, dynamics or statics.</p>
<p>The visual can be given an offset, rotation and scale. These are applied in the following order</p>
<ol>
<li>rotate</li>
<li>scale</li>
<li>offset</li>
</ol>
<p>Hint: To scale before rotation place the visual on a dedicated axis and rotate that axis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Visual(Node):
    &#34;&#34;&#34;
    Visual

    .. image:: ./images/visual.png

    A Visual node contains a 3d visual, typically obtained from a .obj file.
    A visual node can be placed on an axis-type node.

    It is used for visualization. It does not affect the forces, dynamics or statics.

    The visual can be given an offset, rotation and scale. These are applied in the following order

    1. rotate
    2. scale
    3. offset

    Hint: To scale before rotation place the visual on a dedicated axis and rotate that axis.

    &#34;&#34;&#34;

    def __init__(self, scene):

        super().__init__(scene)

        self.offset = [0, 0, 0]
        &#34;&#34;&#34;Offset (x,y,z) of the visual. Offset is applied after scaling&#34;&#34;&#34;
        self.rotation = [0, 0, 0]
        &#34;&#34;&#34;Rotation (rx,ry,rz) of the visual&#34;&#34;&#34;

        self.scale = [1, 1, 1]
        &#34;&#34;&#34;Scaling of the visual. Scaling is applied before offset.&#34;&#34;&#34;

        self.path = &#34;&#34;
        &#34;&#34;&#34;Filename of the visual&#34;&#34;&#34;

        self.parent = None
        &#34;&#34;&#34;Parent : Axis-type&#34;&#34;&#34;

    @property
    def file_path(self):
        return self._scene.get_resource_path(self.path)

    def depends_on(self):
        return [self.parent]

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        code += &#34;\ns.new_visual(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            parent=&#39;{}&#39;,&#34;.format(self.parent.name)
        code += &#34;\n            path=r&#39;{}&#39;,&#34;.format(self.path)
        code += &#34;\n            offset=({}, {}, {}), &#34;.format(*self.offset)
        code += &#34;\n            rotation=({}, {}, {}), &#34;.format(*self.rotation)
        code += &#34;\n            scale=({}, {}, {}) )&#34;.format(*self.scale)

        return code

    def change_parent_to(self, new_parent):

        if not (isinstance(new_parent, Axis) or new_parent is None):
            raise ValueError(
                &#34;Visuals can only be attached to an axis (or derived) or None&#34;
            )

        # get current position and orientation
        if self.parent is not None:
            cur_position = self.parent.to_glob_position(self.offset)
            cur_rotation = self.parent.to_glob_direction(self.rotation)
        else:
            cur_position = self.offset
            cur_rotation = self.rotation

        self.parent = new_parent

        if new_parent is None:
            self.offset = cur_position
            self.rotation = cur_rotation
        else:
            self.offset = new_parent.to_loc_position(cur_position)
            self.rotation = new_parent.to_loc_direction(cur_rotation)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.Visual.file_path"><code class="name">var <span class="ident">file_path</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def file_path(self):
    return self._scene.get_resource_path(self.path)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.Visual.offset"><code class="name">var <span class="ident">offset</span></code></dt>
<dd>
<div class="desc"><p>Offset (x,y,z) of the visual. Offset is applied after scaling</p></div>
</dd>
<dt id="DAVE.scene.Visual.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"><p>Parent : Axis-type</p></div>
</dd>
<dt id="DAVE.scene.Visual.path"><code class="name">var <span class="ident">path</span></code></dt>
<dd>
<div class="desc"><p>Filename of the visual</p></div>
</dd>
<dt id="DAVE.scene.Visual.rotation"><code class="name">var <span class="ident">rotation</span></code></dt>
<dd>
<div class="desc"><p>Rotation (rx,ry,rz) of the visual</p></div>
</dd>
<dt id="DAVE.scene.Visual.scale"><code class="name">var <span class="ident">scale</span></code></dt>
<dd>
<div class="desc"><p>Scaling of the visual. Scaling is applied before offset.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.Visual.change_parent_to"><code class="name flex">
<span>def <span class="ident">change_parent_to</span></span>(<span>self, new_parent)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_parent_to(self, new_parent):

    if not (isinstance(new_parent, Axis) or new_parent is None):
        raise ValueError(
            &#34;Visuals can only be attached to an axis (or derived) or None&#34;
        )

    # get current position and orientation
    if self.parent is not None:
        cur_position = self.parent.to_glob_position(self.offset)
        cur_rotation = self.parent.to_glob_direction(self.rotation)
    else:
        cur_position = self.offset
        cur_rotation = self.rotation

    self.parent = new_parent

    if new_parent is None:
        self.offset = cur_position
        self.rotation = cur_rotation
    else:
        self.offset = new_parent.to_loc_position(cur_position)
        self.rotation = new_parent.to_loc_direction(cur_rotation)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.Node.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.Node.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.Node.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.Node.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.Node.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="DAVE.scene.WaveInteraction1"><code class="flex name class">
<span>class <span class="ident">WaveInteraction1</span></span>
<span>(</span><span>scene)</span>
</code></dt>
<dd>
<div class="desc"><p>WaveInteraction</p>
<p>Wave-interaction-1 couples a first-order hydrodynamic database to an axis.</p>
<p>This adds:
- wave-forces
- damping
- added mass</p>
<p>The data is provided by a Hyddb1 object which is defined in the MaFreDo package. The contents are not embedded
but are to be provided separately in a file. This node contains only the file-name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WaveInteraction1(Node):
    &#34;&#34;&#34;
    WaveInteraction

    Wave-interaction-1 couples a first-order hydrodynamic database to an axis.

    This adds:
    - wave-forces
    - damping
    - added mass

    The data is provided by a Hyddb1 object which is defined in the MaFreDo package. The contents are not embedded
    but are to be provided separately in a file. This node contains only the file-name.

    &#34;&#34;&#34;

    def __init__(self, scene):

        super().__init__(scene)

        self.offset = [0, 0, 0]
        &#34;&#34;&#34;Position (x,y,z) of the hydrodynamic origin in its parents axis system&#34;&#34;&#34;

        self.parent = None
        &#34;&#34;&#34;Parent : Axis-type&#34;&#34;&#34;

        self.path = None
        &#34;&#34;&#34;Filename of a file that can be read by a Hyddb1 object&#34;&#34;&#34;

    @property
    def file_path(self):
        return self._scene.get_resource_path(self.path)

    def depends_on(self):
        return [self.parent]

    def give_python_code(self):
        code = &#34;# code for {}&#34;.format(self.name)

        code += &#34;\ns.new_waveinteraction(name=&#39;{}&#39;,&#34;.format(self.name)
        code += &#34;\n            parent=&#39;{}&#39;,&#34;.format(self.parent.name)
        code += &#34;\n            path=r&#39;{}&#39;,&#34;.format(self.path)
        code += &#34;\n            offset=({}, {}, {}) )&#34;.format(*self.offset)

        return code

    def change_parent_to(self, new_parent):

        if not (isinstance(new_parent, Axis)):
            raise ValueError(
                &#34;Hydrodynamic databases can only be attached to an axis (or derived)&#34;
            )

        # get current position and orientation
        if self.parent is not None:
            cur_position = self.parent.to_glob_position(self.offset)
        else:
            cur_position = self.offset

        self.parent = new_parent
        self.offset = new_parent.to_loc_position(cur_position)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="DAVE.scene.WaveInteraction1.file_path"><code class="name">var <span class="ident">file_path</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def file_path(self):
    return self._scene.get_resource_path(self.path)</code></pre>
</details>
</dd>
<dt id="DAVE.scene.WaveInteraction1.offset"><code class="name">var <span class="ident">offset</span></code></dt>
<dd>
<div class="desc"><p>Position (x,y,z) of the hydrodynamic origin in its parents axis system</p></div>
</dd>
<dt id="DAVE.scene.WaveInteraction1.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"><p>Parent : Axis-type</p></div>
</dd>
<dt id="DAVE.scene.WaveInteraction1.path"><code class="name">var <span class="ident">path</span></code></dt>
<dd>
<div class="desc"><p>Filename of a file that can be read by a Hyddb1 object</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="DAVE.scene.WaveInteraction1.change_parent_to"><code class="name flex">
<span>def <span class="ident">change_parent_to</span></span>(<span>self, new_parent)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_parent_to(self, new_parent):

    if not (isinstance(new_parent, Axis)):
        raise ValueError(
            &#34;Hydrodynamic databases can only be attached to an axis (or derived)&#34;
        )

    # get current position and orientation
    if self.parent is not None:
        cur_position = self.parent.to_glob_position(self.offset)
    else:
        cur_position = self.offset

    self.parent = new_parent
    self.offset = new_parent.to_loc_position(cur_position)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="DAVE.scene.Node.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.Node.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.Node.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.Node.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.Node.update" href="#DAVE.scene.Node.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="DAVE.scene.node_setter_manageable" href="#DAVE.scene.node_setter_manageable">node_setter_manageable</a></code></li>
<li><code><a title="DAVE.scene.node_setter_observable" href="#DAVE.scene.node_setter_observable">node_setter_observable</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="DAVE.scene.Axis" href="#DAVE.scene.Axis">Axis</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.Axis.applied_force" href="#DAVE.scene.Axis.applied_force">applied_force</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_force" href="#DAVE.scene.Axis.connection_force">connection_force</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_force_x" href="#DAVE.scene.Axis.connection_force_x">connection_force_x</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_force_y" href="#DAVE.scene.Axis.connection_force_y">connection_force_y</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_force_z" href="#DAVE.scene.Axis.connection_force_z">connection_force_z</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_moment_x" href="#DAVE.scene.Axis.connection_moment_x">connection_moment_x</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_moment_y" href="#DAVE.scene.Axis.connection_moment_y">connection_moment_y</a></code></li>
<li><code><a title="DAVE.scene.Axis.connection_moment_z" href="#DAVE.scene.Axis.connection_moment_z">connection_moment_z</a></code></li>
<li><code><a title="DAVE.scene.Axis.equilibrium_error" href="#DAVE.scene.Axis.equilibrium_error">equilibrium_error</a></code></li>
<li><code><a title="DAVE.scene.Axis.fixed" href="#DAVE.scene.Axis.fixed">fixed</a></code></li>
<li><code><a title="DAVE.scene.Axis.give_load_shear_moment_diagram" href="#DAVE.scene.Axis.give_load_shear_moment_diagram">give_load_shear_moment_diagram</a></code></li>
<li><code><a title="DAVE.scene.Axis.global_position" href="#DAVE.scene.Axis.global_position">global_position</a></code></li>
<li><code><a title="DAVE.scene.Axis.global_rotation" href="#DAVE.scene.Axis.global_rotation">global_rotation</a></code></li>
<li><code><a title="DAVE.scene.Axis.global_transform" href="#DAVE.scene.Axis.global_transform">global_transform</a></code></li>
<li><code><a title="DAVE.scene.Axis.grx" href="#DAVE.scene.Axis.grx">grx</a></code></li>
<li><code><a title="DAVE.scene.Axis.gry" href="#DAVE.scene.Axis.gry">gry</a></code></li>
<li><code><a title="DAVE.scene.Axis.grz" href="#DAVE.scene.Axis.grz">grz</a></code></li>
<li><code><a title="DAVE.scene.Axis.gx" href="#DAVE.scene.Axis.gx">gx</a></code></li>
<li><code><a title="DAVE.scene.Axis.gy" href="#DAVE.scene.Axis.gy">gy</a></code></li>
<li><code><a title="DAVE.scene.Axis.gz" href="#DAVE.scene.Axis.gz">gz</a></code></li>
<li><code><a title="DAVE.scene.Axis.heading" href="#DAVE.scene.Axis.heading">heading</a></code></li>
<li><code><a title="DAVE.scene.Axis.heading_compass" href="#DAVE.scene.Axis.heading_compass">heading_compass</a></code></li>
<li><code><a title="DAVE.scene.Axis.heel" href="#DAVE.scene.Axis.heel">heel</a></code></li>
<li><code><a title="DAVE.scene.Axis.inertia" href="#DAVE.scene.Axis.inertia">inertia</a></code></li>
<li><code><a title="DAVE.scene.Axis.inertia_position" href="#DAVE.scene.Axis.inertia_position">inertia_position</a></code></li>
<li><code><a title="DAVE.scene.Axis.inertia_radii" href="#DAVE.scene.Axis.inertia_radii">inertia_radii</a></code></li>
<li><code><a title="DAVE.scene.Axis.parent" href="#DAVE.scene.Axis.parent">parent</a></code></li>
<li><code><a title="DAVE.scene.Axis.position" href="#DAVE.scene.Axis.position">position</a></code></li>
<li><code><a title="DAVE.scene.Axis.rotation" href="#DAVE.scene.Axis.rotation">rotation</a></code></li>
<li><code><a title="DAVE.scene.Axis.rx" href="#DAVE.scene.Axis.rx">rx</a></code></li>
<li><code><a title="DAVE.scene.Axis.ry" href="#DAVE.scene.Axis.ry">ry</a></code></li>
<li><code><a title="DAVE.scene.Axis.rz" href="#DAVE.scene.Axis.rz">rz</a></code></li>
<li><code><a title="DAVE.scene.Axis.set_fixed" href="#DAVE.scene.Axis.set_fixed">set_fixed</a></code></li>
<li><code><a title="DAVE.scene.Axis.set_free" href="#DAVE.scene.Axis.set_free">set_free</a></code></li>
<li><code><a title="DAVE.scene.Axis.tilt_x" href="#DAVE.scene.Axis.tilt_x">tilt_x</a></code></li>
<li><code><a title="DAVE.scene.Axis.tilt_y" href="#DAVE.scene.Axis.tilt_y">tilt_y</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_glob_direction" href="#DAVE.scene.Axis.to_glob_direction">to_glob_direction</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_glob_position" href="#DAVE.scene.Axis.to_glob_position">to_glob_position</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_glob_rotation" href="#DAVE.scene.Axis.to_glob_rotation">to_glob_rotation</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_loc_direction" href="#DAVE.scene.Axis.to_loc_direction">to_loc_direction</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_loc_position" href="#DAVE.scene.Axis.to_loc_position">to_loc_position</a></code></li>
<li><code><a title="DAVE.scene.Axis.to_loc_rotation" href="#DAVE.scene.Axis.to_loc_rotation">to_loc_rotation</a></code></li>
<li><code><a title="DAVE.scene.Axis.trim" href="#DAVE.scene.Axis.trim">trim</a></code></li>
<li><code><a title="DAVE.scene.Axis.ux" href="#DAVE.scene.Axis.ux">ux</a></code></li>
<li><code><a title="DAVE.scene.Axis.uy" href="#DAVE.scene.Axis.uy">uy</a></code></li>
<li><code><a title="DAVE.scene.Axis.uz" href="#DAVE.scene.Axis.uz">uz</a></code></li>
<li><code><a title="DAVE.scene.Axis.x" href="#DAVE.scene.Axis.x">x</a></code></li>
<li><code><a title="DAVE.scene.Axis.y" href="#DAVE.scene.Axis.y">y</a></code></li>
<li><code><a title="DAVE.scene.Axis.z" href="#DAVE.scene.Axis.z">z</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.BallastSystem" href="#DAVE.scene.BallastSystem">BallastSystem</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.BallastSystem.change_parent_to" href="#DAVE.scene.BallastSystem.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.BallastSystem.cog" href="#DAVE.scene.BallastSystem.cog">cog</a></code></li>
<li><code><a title="DAVE.scene.BallastSystem.cogx" href="#DAVE.scene.BallastSystem.cogx">cogx</a></code></li>
<li><code><a title="DAVE.scene.BallastSystem.cogy" href="#DAVE.scene.BallastSystem.cogy">cogy</a></code></li>
<li><code><a title="DAVE.scene.BallastSystem.cogz" href="#DAVE.scene.BallastSystem.cogz">cogz</a></code></li>
<li><code><a title="DAVE.scene.BallastSystem.empty_all_usable_tanks" href="#DAVE.scene.BallastSystem.empty_all_usable_tanks">empty_all_usable_tanks</a></code></li>
<li><code><a title="DAVE.scene.BallastSystem.fill_tank" href="#DAVE.scene.BallastSystem.fill_tank">fill_tank</a></code></li>
<li><code><a title="DAVE.scene.BallastSystem.frozen" href="#DAVE.scene.BallastSystem.frozen">frozen</a></code></li>
<li><code><a title="DAVE.scene.BallastSystem.is_frozen" href="#DAVE.scene.BallastSystem.is_frozen">is_frozen</a></code></li>
<li><code><a title="DAVE.scene.BallastSystem.new_tank" href="#DAVE.scene.BallastSystem.new_tank">new_tank</a></code></li>
<li><code><a title="DAVE.scene.BallastSystem.order_tanks_by_distance_from_point" href="#DAVE.scene.BallastSystem.order_tanks_by_distance_from_point">order_tanks_by_distance_from_point</a></code></li>
<li><code><a title="DAVE.scene.BallastSystem.order_tanks_by_elevation" href="#DAVE.scene.BallastSystem.order_tanks_by_elevation">order_tanks_by_elevation</a></code></li>
<li><code><a title="DAVE.scene.BallastSystem.order_tanks_to_maximize_inertia_moment" href="#DAVE.scene.BallastSystem.order_tanks_to_maximize_inertia_moment">order_tanks_to_maximize_inertia_moment</a></code></li>
<li><code><a title="DAVE.scene.BallastSystem.order_tanks_to_minimize_inertia_moment" href="#DAVE.scene.BallastSystem.order_tanks_to_minimize_inertia_moment">order_tanks_to_minimize_inertia_moment</a></code></li>
<li><code><a title="DAVE.scene.BallastSystem.reorder_tanks" href="#DAVE.scene.BallastSystem.reorder_tanks">reorder_tanks</a></code></li>
<li><code><a title="DAVE.scene.BallastSystem.restore_tank_fillings" href="#DAVE.scene.BallastSystem.restore_tank_fillings">restore_tank_fillings</a></code></li>
<li><code><a title="DAVE.scene.BallastSystem.tank" href="#DAVE.scene.BallastSystem.tank">tank</a></code></li>
<li><code><a title="DAVE.scene.BallastSystem.tank_names" href="#DAVE.scene.BallastSystem.tank_names">tank_names</a></code></li>
<li><code><a title="DAVE.scene.BallastSystem.tanks" href="#DAVE.scene.BallastSystem.tanks">tanks</a></code></li>
<li><code><a title="DAVE.scene.BallastSystem.weight" href="#DAVE.scene.BallastSystem.weight">weight</a></code></li>
<li><code><a title="DAVE.scene.BallastSystem.xyzw" href="#DAVE.scene.BallastSystem.xyzw">xyzw</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.Beam" href="#DAVE.scene.Beam">Beam</a></code></h4>
<ul class="two-column">
<li><code><a title="DAVE.scene.Beam.EA" href="#DAVE.scene.Beam.EA">EA</a></code></li>
<li><code><a title="DAVE.scene.Beam.EIy" href="#DAVE.scene.Beam.EIy">EIy</a></code></li>
<li><code><a title="DAVE.scene.Beam.EIz" href="#DAVE.scene.Beam.EIz">EIz</a></code></li>
<li><code><a title="DAVE.scene.Beam.GIp" href="#DAVE.scene.Beam.GIp">GIp</a></code></li>
<li><code><a title="DAVE.scene.Beam.L" href="#DAVE.scene.Beam.L">L</a></code></li>
<li><code><a title="DAVE.scene.Beam.X_midpoints" href="#DAVE.scene.Beam.X_midpoints">X_midpoints</a></code></li>
<li><code><a title="DAVE.scene.Beam.X_nodes" href="#DAVE.scene.Beam.X_nodes">X_nodes</a></code></li>
<li><code><a title="DAVE.scene.Beam.bending" href="#DAVE.scene.Beam.bending">bending</a></code></li>
<li><code><a title="DAVE.scene.Beam.global_orientations" href="#DAVE.scene.Beam.global_orientations">global_orientations</a></code></li>
<li><code><a title="DAVE.scene.Beam.global_positions" href="#DAVE.scene.Beam.global_positions">global_positions</a></code></li>
<li><code><a title="DAVE.scene.Beam.mass" href="#DAVE.scene.Beam.mass">mass</a></code></li>
<li><code><a title="DAVE.scene.Beam.moment_A" href="#DAVE.scene.Beam.moment_A">moment_A</a></code></li>
<li><code><a title="DAVE.scene.Beam.moment_B" href="#DAVE.scene.Beam.moment_B">moment_B</a></code></li>
<li><code><a title="DAVE.scene.Beam.n_segments" href="#DAVE.scene.Beam.n_segments">n_segments</a></code></li>
<li><code><a title="DAVE.scene.Beam.nodeA" href="#DAVE.scene.Beam.nodeA">nodeA</a></code></li>
<li><code><a title="DAVE.scene.Beam.nodeB" href="#DAVE.scene.Beam.nodeB">nodeB</a></code></li>
<li><code><a title="DAVE.scene.Beam.tension" href="#DAVE.scene.Beam.tension">tension</a></code></li>
<li><code><a title="DAVE.scene.Beam.tension_only" href="#DAVE.scene.Beam.tension_only">tension_only</a></code></li>
<li><code><a title="DAVE.scene.Beam.torsion" href="#DAVE.scene.Beam.torsion">torsion</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.Buoyancy" href="#DAVE.scene.Buoyancy">Buoyancy</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.Buoyancy.cob" href="#DAVE.scene.Buoyancy.cob">cob</a></code></li>
<li><code><a title="DAVE.scene.Buoyancy.cob_local" href="#DAVE.scene.Buoyancy.cob_local">cob_local</a></code></li>
<li><code><a title="DAVE.scene.Buoyancy.density" href="#DAVE.scene.Buoyancy.density">density</a></code></li>
<li><code><a title="DAVE.scene.Buoyancy.displacement" href="#DAVE.scene.Buoyancy.displacement">displacement</a></code></li>
<li><code><a title="DAVE.scene.Buoyancy.trimesh" href="#DAVE.scene.Buoyancy.trimesh">trimesh</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.Cable" href="#DAVE.scene.Cable">Cable</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.Cable.EA" href="#DAVE.scene.Cable.EA">EA</a></code></li>
<li><code><a title="DAVE.scene.Cable.connections" href="#DAVE.scene.Cable.connections">connections</a></code></li>
<li><code><a title="DAVE.scene.Cable.diameter" href="#DAVE.scene.Cable.diameter">diameter</a></code></li>
<li><code><a title="DAVE.scene.Cable.get_points_for_visual" href="#DAVE.scene.Cable.get_points_for_visual">get_points_for_visual</a></code></li>
<li><code><a title="DAVE.scene.Cable.length" href="#DAVE.scene.Cable.length">length</a></code></li>
<li><code><a title="DAVE.scene.Cable.stretch" href="#DAVE.scene.Cable.stretch">stretch</a></code></li>
<li><code><a title="DAVE.scene.Cable.tension" href="#DAVE.scene.Cable.tension">tension</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.Circle" href="#DAVE.scene.Circle">Circle</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.Circle.axis" href="#DAVE.scene.Circle.axis">axis</a></code></li>
<li><code><a title="DAVE.scene.Circle.global_position" href="#DAVE.scene.Circle.global_position">global_position</a></code></li>
<li><code><a title="DAVE.scene.Circle.radius" href="#DAVE.scene.Circle.radius">radius</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.ClaimManagement" href="#DAVE.scene.ClaimManagement">ClaimManagement</a></code></h4>
</li>
<li>
<h4><code><a title="DAVE.scene.Connector2d" href="#DAVE.scene.Connector2d">Connector2d</a></code></h4>
<ul class="two-column">
<li><code><a title="DAVE.scene.Connector2d.angle" href="#DAVE.scene.Connector2d.angle">angle</a></code></li>
<li><code><a title="DAVE.scene.Connector2d.ax" href="#DAVE.scene.Connector2d.ax">ax</a></code></li>
<li><code><a title="DAVE.scene.Connector2d.axis" href="#DAVE.scene.Connector2d.axis">axis</a></code></li>
<li><code><a title="DAVE.scene.Connector2d.ay" href="#DAVE.scene.Connector2d.ay">ay</a></code></li>
<li><code><a title="DAVE.scene.Connector2d.az" href="#DAVE.scene.Connector2d.az">az</a></code></li>
<li><code><a title="DAVE.scene.Connector2d.force" href="#DAVE.scene.Connector2d.force">force</a></code></li>
<li><code><a title="DAVE.scene.Connector2d.k_angular" href="#DAVE.scene.Connector2d.k_angular">k_angular</a></code></li>
<li><code><a title="DAVE.scene.Connector2d.k_linear" href="#DAVE.scene.Connector2d.k_linear">k_linear</a></code></li>
<li><code><a title="DAVE.scene.Connector2d.moment" href="#DAVE.scene.Connector2d.moment">moment</a></code></li>
<li><code><a title="DAVE.scene.Connector2d.nodeA" href="#DAVE.scene.Connector2d.nodeA">nodeA</a></code></li>
<li><code><a title="DAVE.scene.Connector2d.nodeB" href="#DAVE.scene.Connector2d.nodeB">nodeB</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.ContactBall" href="#DAVE.scene.ContactBall">ContactBall</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.ContactBall.can_contact" href="#DAVE.scene.ContactBall.can_contact">can_contact</a></code></li>
<li><code><a title="DAVE.scene.ContactBall.compression" href="#DAVE.scene.ContactBall.compression">compression</a></code></li>
<li><code><a title="DAVE.scene.ContactBall.contact_force" href="#DAVE.scene.ContactBall.contact_force">contact_force</a></code></li>
<li><code><a title="DAVE.scene.ContactBall.contact_force_magnitude" href="#DAVE.scene.ContactBall.contact_force_magnitude">contact_force_magnitude</a></code></li>
<li><code><a title="DAVE.scene.ContactBall.contactpoint" href="#DAVE.scene.ContactBall.contactpoint">contactpoint</a></code></li>
<li><code><a title="DAVE.scene.ContactBall.k" href="#DAVE.scene.ContactBall.k">k</a></code></li>
<li><code><a title="DAVE.scene.ContactBall.meshes" href="#DAVE.scene.ContactBall.meshes">meshes</a></code></li>
<li><code><a title="DAVE.scene.ContactBall.meshes_names" href="#DAVE.scene.ContactBall.meshes_names">meshes_names</a></code></li>
<li><code><a title="DAVE.scene.ContactBall.radius" href="#DAVE.scene.ContactBall.radius">radius</a></code></li>
<li><code><a title="DAVE.scene.ContactBall.update" href="#DAVE.scene.ContactBall.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.ContactMesh" href="#DAVE.scene.ContactMesh">ContactMesh</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.ContactMesh.trimesh" href="#DAVE.scene.ContactMesh.trimesh">trimesh</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.CoreConnectedNode" href="#DAVE.scene.CoreConnectedNode">CoreConnectedNode</a></code></h4>
</li>
<li>
<h4><code><a title="DAVE.scene.Force" href="#DAVE.scene.Force">Force</a></code></h4>
<ul class="two-column">
<li><code><a title="DAVE.scene.Force.force" href="#DAVE.scene.Force.force">force</a></code></li>
<li><code><a title="DAVE.scene.Force.fx" href="#DAVE.scene.Force.fx">fx</a></code></li>
<li><code><a title="DAVE.scene.Force.fy" href="#DAVE.scene.Force.fy">fy</a></code></li>
<li><code><a title="DAVE.scene.Force.fz" href="#DAVE.scene.Force.fz">fz</a></code></li>
<li><code><a title="DAVE.scene.Force.moment" href="#DAVE.scene.Force.moment">moment</a></code></li>
<li><code><a title="DAVE.scene.Force.mx" href="#DAVE.scene.Force.mx">mx</a></code></li>
<li><code><a title="DAVE.scene.Force.my" href="#DAVE.scene.Force.my">my</a></code></li>
<li><code><a title="DAVE.scene.Force.mz" href="#DAVE.scene.Force.mz">mz</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.GeometricContact" href="#DAVE.scene.GeometricContact">GeometricContact</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.GeometricContact.change_parent_to" href="#DAVE.scene.GeometricContact.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.GeometricContact.change_side" href="#DAVE.scene.GeometricContact.change_side">change_side</a></code></li>
<li><code><a title="DAVE.scene.GeometricContact.child" href="#DAVE.scene.GeometricContact.child">child</a></code></li>
<li><code><a title="DAVE.scene.GeometricContact.child_fixed" href="#DAVE.scene.GeometricContact.child_fixed">child_fixed</a></code></li>
<li><code><a title="DAVE.scene.GeometricContact.child_rotation" href="#DAVE.scene.GeometricContact.child_rotation">child_rotation</a></code></li>
<li><code><a title="DAVE.scene.GeometricContact.fixed_to_parent" href="#DAVE.scene.GeometricContact.fixed_to_parent">fixed_to_parent</a></code></li>
<li><code><a title="DAVE.scene.GeometricContact.flip" href="#DAVE.scene.GeometricContact.flip">flip</a></code></li>
<li><code><a title="DAVE.scene.GeometricContact.inside" href="#DAVE.scene.GeometricContact.inside">inside</a></code></li>
<li><code><a title="DAVE.scene.GeometricContact.managed_nodes" href="#DAVE.scene.GeometricContact.managed_nodes">managed_nodes</a></code></li>
<li><code><a title="DAVE.scene.GeometricContact.on_observed_node_changed" href="#DAVE.scene.GeometricContact.on_observed_node_changed">on_observed_node_changed</a></code></li>
<li><code><a title="DAVE.scene.GeometricContact.parent" href="#DAVE.scene.GeometricContact.parent">parent</a></code></li>
<li><code><a title="DAVE.scene.GeometricContact.rotation_on_parent" href="#DAVE.scene.GeometricContact.rotation_on_parent">rotation_on_parent</a></code></li>
<li><code><a title="DAVE.scene.GeometricContact.set_pin_in_hole_connection" href="#DAVE.scene.GeometricContact.set_pin_in_hole_connection">set_pin_in_hole_connection</a></code></li>
<li><code><a title="DAVE.scene.GeometricContact.set_pin_pin_connection" href="#DAVE.scene.GeometricContact.set_pin_pin_connection">set_pin_pin_connection</a></code></li>
<li><code><a title="DAVE.scene.GeometricContact.swivel" href="#DAVE.scene.GeometricContact.swivel">swivel</a></code></li>
<li><code><a title="DAVE.scene.GeometricContact.swivel_fixed" href="#DAVE.scene.GeometricContact.swivel_fixed">swivel_fixed</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.HydSpring" href="#DAVE.scene.HydSpring">HydSpring</a></code></h4>
<ul class="two-column">
<li><code><a title="DAVE.scene.HydSpring.BML" href="#DAVE.scene.HydSpring.BML">BML</a></code></li>
<li><code><a title="DAVE.scene.HydSpring.BMT" href="#DAVE.scene.HydSpring.BMT">BMT</a></code></li>
<li><code><a title="DAVE.scene.HydSpring.COFX" href="#DAVE.scene.HydSpring.COFX">COFX</a></code></li>
<li><code><a title="DAVE.scene.HydSpring.COFY" href="#DAVE.scene.HydSpring.COFY">COFY</a></code></li>
<li><code><a title="DAVE.scene.HydSpring.cob" href="#DAVE.scene.HydSpring.cob">cob</a></code></li>
<li><code><a title="DAVE.scene.HydSpring.displacement_kN" href="#DAVE.scene.HydSpring.displacement_kN">displacement_kN</a></code></li>
<li><code><a title="DAVE.scene.HydSpring.kHeave" href="#DAVE.scene.HydSpring.kHeave">kHeave</a></code></li>
<li><code><a title="DAVE.scene.HydSpring.waterline" href="#DAVE.scene.HydSpring.waterline">waterline</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.LC6d" href="#DAVE.scene.LC6d">LC6d</a></code></h4>
<ul class="two-column">
<li><code><a title="DAVE.scene.LC6d.fgx" href="#DAVE.scene.LC6d.fgx">fgx</a></code></li>
<li><code><a title="DAVE.scene.LC6d.fgy" href="#DAVE.scene.LC6d.fgy">fgy</a></code></li>
<li><code><a title="DAVE.scene.LC6d.fgz" href="#DAVE.scene.LC6d.fgz">fgz</a></code></li>
<li><code><a title="DAVE.scene.LC6d.force_global" href="#DAVE.scene.LC6d.force_global">force_global</a></code></li>
<li><code><a title="DAVE.scene.LC6d.main" href="#DAVE.scene.LC6d.main">main</a></code></li>
<li><code><a title="DAVE.scene.LC6d.mgx" href="#DAVE.scene.LC6d.mgx">mgx</a></code></li>
<li><code><a title="DAVE.scene.LC6d.mgy" href="#DAVE.scene.LC6d.mgy">mgy</a></code></li>
<li><code><a title="DAVE.scene.LC6d.mgz" href="#DAVE.scene.LC6d.mgz">mgz</a></code></li>
<li><code><a title="DAVE.scene.LC6d.moment_global" href="#DAVE.scene.LC6d.moment_global">moment_global</a></code></li>
<li><code><a title="DAVE.scene.LC6d.secondary" href="#DAVE.scene.LC6d.secondary">secondary</a></code></li>
<li><code><a title="DAVE.scene.LC6d.stiffness" href="#DAVE.scene.LC6d.stiffness">stiffness</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.LoadShearMomentDiagram" href="#DAVE.scene.LoadShearMomentDiagram">LoadShearMomentDiagram</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.LoadShearMomentDiagram.give_shear_and_moment" href="#DAVE.scene.LoadShearMomentDiagram.give_shear_and_moment">give_shear_and_moment</a></code></li>
<li><code><a title="DAVE.scene.LoadShearMomentDiagram.plot" href="#DAVE.scene.LoadShearMomentDiagram.plot">plot</a></code></li>
<li><code><a title="DAVE.scene.LoadShearMomentDiagram.plot_simple" href="#DAVE.scene.LoadShearMomentDiagram.plot_simple">plot_simple</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.Manager" href="#DAVE.scene.Manager">Manager</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.Manager.creates" href="#DAVE.scene.Manager.creates">creates</a></code></li>
<li><code><a title="DAVE.scene.Manager.delete" href="#DAVE.scene.Manager.delete">delete</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.Node" href="#DAVE.scene.Node">Node</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.Node.class_name" href="#DAVE.scene.Node.class_name">class_name</a></code></li>
<li><code><a title="DAVE.scene.Node.depends_on" href="#DAVE.scene.Node.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.Node.give_python_code" href="#DAVE.scene.Node.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.Node.manager" href="#DAVE.scene.Node.manager">manager</a></code></li>
<li><code><a title="DAVE.scene.Node.name" href="#DAVE.scene.Node.name">name</a></code></li>
<li><code><a title="DAVE.scene.Node.observers" href="#DAVE.scene.Node.observers">observers</a></code></li>
<li><code><a title="DAVE.scene.Node.on_observed_node_changed" href="#DAVE.scene.Node.on_observed_node_changed">on_observed_node_changed</a></code></li>
<li><code><a title="DAVE.scene.Node.update" href="#DAVE.scene.Node.update">update</a></code></li>
<li><code><a title="DAVE.scene.Node.visible" href="#DAVE.scene.Node.visible">visible</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.NodeWithParent" href="#DAVE.scene.NodeWithParent">NodeWithParent</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.NodeWithParent.change_parent_to" href="#DAVE.scene.NodeWithParent.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.parent" href="#DAVE.scene.NodeWithParent.parent">parent</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParent.parent_for_export" href="#DAVE.scene.NodeWithParent.parent_for_export">parent_for_export</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.NodeWithParentAndFootprint" href="#DAVE.scene.NodeWithParentAndFootprint">NodeWithParentAndFootprint</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.NodeWithParentAndFootprint.add_footprint_python_code" href="#DAVE.scene.NodeWithParentAndFootprint.add_footprint_python_code">add_footprint_python_code</a></code></li>
<li><code><a title="DAVE.scene.NodeWithParentAndFootprint.footprint" href="#DAVE.scene.NodeWithParentAndFootprint.footprint">footprint</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.Point" href="#DAVE.scene.Point">Point</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.Point.applied_force_and_moment_global" href="#DAVE.scene.Point.applied_force_and_moment_global">applied_force_and_moment_global</a></code></li>
<li><code><a title="DAVE.scene.Point.global_position" href="#DAVE.scene.Point.global_position">global_position</a></code></li>
<li><code><a title="DAVE.scene.Point.gx" href="#DAVE.scene.Point.gx">gx</a></code></li>
<li><code><a title="DAVE.scene.Point.gy" href="#DAVE.scene.Point.gy">gy</a></code></li>
<li><code><a title="DAVE.scene.Point.gz" href="#DAVE.scene.Point.gz">gz</a></code></li>
<li><code><a title="DAVE.scene.Point.on_observed_node_changed" href="#DAVE.scene.Point.on_observed_node_changed">on_observed_node_changed</a></code></li>
<li><code><a title="DAVE.scene.Point.position" href="#DAVE.scene.Point.position">position</a></code></li>
<li><code><a title="DAVE.scene.Point.x" href="#DAVE.scene.Point.x">x</a></code></li>
<li><code><a title="DAVE.scene.Point.y" href="#DAVE.scene.Point.y">y</a></code></li>
<li><code><a title="DAVE.scene.Point.z" href="#DAVE.scene.Point.z">z</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.RigidBody" href="#DAVE.scene.RigidBody">RigidBody</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.RigidBody.cog" href="#DAVE.scene.RigidBody.cog">cog</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.cogx" href="#DAVE.scene.RigidBody.cogx">cogx</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.cogy" href="#DAVE.scene.RigidBody.cogy">cogy</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.cogz" href="#DAVE.scene.RigidBody.cogz">cogz</a></code></li>
<li><code><a title="DAVE.scene.RigidBody.mass" href="#DAVE.scene.RigidBody.mass">mass</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.SPMT" href="#DAVE.scene.SPMT">SPMT</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.SPMT.axle_force" href="#DAVE.scene.SPMT.axle_force">axle_force</a></code></li>
<li><code><a title="DAVE.scene.SPMT.axles" href="#DAVE.scene.SPMT.axles">axles</a></code></li>
<li><code><a title="DAVE.scene.SPMT.compression" href="#DAVE.scene.SPMT.compression">compression</a></code></li>
<li><code><a title="DAVE.scene.SPMT.get_actual_global_points" href="#DAVE.scene.SPMT.get_actual_global_points">get_actual_global_points</a></code></li>
<li><code><a title="DAVE.scene.SPMT.k" href="#DAVE.scene.SPMT.k">k</a></code></li>
<li><code><a title="DAVE.scene.SPMT.make_grid" href="#DAVE.scene.SPMT.make_grid">make_grid</a></code></li>
<li><code><a title="DAVE.scene.SPMT.max_length" href="#DAVE.scene.SPMT.max_length">max_length</a></code></li>
<li><code><a title="DAVE.scene.SPMT.meshes" href="#DAVE.scene.SPMT.meshes">meshes</a></code></li>
<li><code><a title="DAVE.scene.SPMT.meshes_names" href="#DAVE.scene.SPMT.meshes_names">meshes_names</a></code></li>
<li><code><a title="DAVE.scene.SPMT.nominal_length" href="#DAVE.scene.SPMT.nominal_length">nominal_length</a></code></li>
<li><code><a title="DAVE.scene.SPMT.update" href="#DAVE.scene.SPMT.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.Scene" href="#DAVE.scene.Scene">Scene</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.Scene.assert_unique_names" href="#DAVE.scene.Scene.assert_unique_names">assert_unique_names</a></code></li>
<li><code><a title="DAVE.scene.Scene.available_name_like" href="#DAVE.scene.Scene.available_name_like">available_name_like</a></code></li>
<li><code><a title="DAVE.scene.Scene.clear" href="#DAVE.scene.Scene.clear">clear</a></code></li>
<li><code><a title="DAVE.scene.Scene.copy" href="#DAVE.scene.Scene.copy">copy</a></code></li>
<li><code><a title="DAVE.scene.Scene.current_manager" href="#DAVE.scene.Scene.current_manager">current_manager</a></code></li>
<li><code><a title="DAVE.scene.Scene.delete" href="#DAVE.scene.Scene.delete">delete</a></code></li>
<li><code><a title="DAVE.scene.Scene.dissolve" href="#DAVE.scene.Scene.dissolve">dissolve</a></code></li>
<li><code><a title="DAVE.scene.Scene.dynamics_K" href="#DAVE.scene.Scene.dynamics_K">dynamics_K</a></code></li>
<li><code><a title="DAVE.scene.Scene.dynamics_M" href="#DAVE.scene.Scene.dynamics_M">dynamics_M</a></code></li>
<li><code><a title="DAVE.scene.Scene.dynamics_modes" href="#DAVE.scene.Scene.dynamics_modes">dynamics_modes</a></code></li>
<li><code><a title="DAVE.scene.Scene.dynamics_nodes" href="#DAVE.scene.Scene.dynamics_nodes">dynamics_nodes</a></code></li>
<li><code><a title="DAVE.scene.Scene.get_resource_list" href="#DAVE.scene.Scene.get_resource_list">get_resource_list</a></code></li>
<li><code><a title="DAVE.scene.Scene.get_resource_path" href="#DAVE.scene.Scene.get_resource_path">get_resource_path</a></code></li>
<li><code><a title="DAVE.scene.Scene.give_python_code" href="#DAVE.scene.Scene.give_python_code">give_python_code</a></code></li>
<li><code><a title="DAVE.scene.Scene.goal_seek" href="#DAVE.scene.Scene.goal_seek">goal_seek</a></code></li>
<li><code><a title="DAVE.scene.Scene.import_scene" href="#DAVE.scene.Scene.import_scene">import_scene</a></code></li>
<li><code><a title="DAVE.scene.Scene.load_scene" href="#DAVE.scene.Scene.load_scene">load_scene</a></code></li>
<li><code><a title="DAVE.scene.Scene.name_available" href="#DAVE.scene.Scene.name_available">name_available</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_axis" href="#DAVE.scene.Scene.new_axis">new_axis</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_ballastsystem" href="#DAVE.scene.Scene.new_ballastsystem">new_ballastsystem</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_beam" href="#DAVE.scene.Scene.new_beam">new_beam</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_buoyancy" href="#DAVE.scene.Scene.new_buoyancy">new_buoyancy</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_cable" href="#DAVE.scene.Scene.new_cable">new_cable</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_circle" href="#DAVE.scene.Scene.new_circle">new_circle</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_connector2d" href="#DAVE.scene.Scene.new_connector2d">new_connector2d</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_contactball" href="#DAVE.scene.Scene.new_contactball">new_contactball</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_contactmesh" href="#DAVE.scene.Scene.new_contactmesh">new_contactmesh</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_force" href="#DAVE.scene.Scene.new_force">new_force</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_geometriccontact" href="#DAVE.scene.Scene.new_geometriccontact">new_geometriccontact</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_hydspring" href="#DAVE.scene.Scene.new_hydspring">new_hydspring</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_linear_connector_6d" href="#DAVE.scene.Scene.new_linear_connector_6d">new_linear_connector_6d</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_point" href="#DAVE.scene.Scene.new_point">new_point</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_rigidbody" href="#DAVE.scene.Scene.new_rigidbody">new_rigidbody</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_shackle" href="#DAVE.scene.Scene.new_shackle">new_shackle</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_sling" href="#DAVE.scene.Scene.new_sling">new_sling</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_spmt" href="#DAVE.scene.Scene.new_spmt">new_spmt</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_tank" href="#DAVE.scene.Scene.new_tank">new_tank</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_visual" href="#DAVE.scene.Scene.new_visual">new_visual</a></code></li>
<li><code><a title="DAVE.scene.Scene.new_waveinteraction" href="#DAVE.scene.Scene.new_waveinteraction">new_waveinteraction</a></code></li>
<li><code><a title="DAVE.scene.Scene.node_A_core_depends_on_B_core" href="#DAVE.scene.Scene.node_A_core_depends_on_B_core">node_A_core_depends_on_B_core</a></code></li>
<li><code><a title="DAVE.scene.Scene.node_by_name" href="#DAVE.scene.Scene.node_by_name">node_by_name</a></code></li>
<li><code><a title="DAVE.scene.Scene.nodes_depending_on" href="#DAVE.scene.Scene.nodes_depending_on">nodes_depending_on</a></code></li>
<li><code><a title="DAVE.scene.Scene.nodes_managed_by" href="#DAVE.scene.Scene.nodes_managed_by">nodes_managed_by</a></code></li>
<li><code><a title="DAVE.scene.Scene.nodes_of_type" href="#DAVE.scene.Scene.nodes_of_type">nodes_of_type</a></code></li>
<li><code><a title="DAVE.scene.Scene.nodes_with_parent" href="#DAVE.scene.Scene.nodes_with_parent">nodes_with_parent</a></code></li>
<li><code><a title="DAVE.scene.Scene.plot_effect" href="#DAVE.scene.Scene.plot_effect">plot_effect</a></code></li>
<li><code><a title="DAVE.scene.Scene.print_node_tree" href="#DAVE.scene.Scene.print_node_tree">print_node_tree</a></code></li>
<li><code><a title="DAVE.scene.Scene.print_python_code" href="#DAVE.scene.Scene.print_python_code">print_python_code</a></code></li>
<li><code><a title="DAVE.scene.Scene.resources_paths" href="#DAVE.scene.Scene.resources_paths">resources_paths</a></code></li>
<li><code><a title="DAVE.scene.Scene.run_code" href="#DAVE.scene.Scene.run_code">run_code</a></code></li>
<li><code><a title="DAVE.scene.Scene.save_scene" href="#DAVE.scene.Scene.save_scene">save_scene</a></code></li>
<li><code><a title="DAVE.scene.Scene.savepoint_make" href="#DAVE.scene.Scene.savepoint_make">savepoint_make</a></code></li>
<li><code><a title="DAVE.scene.Scene.savepoint_restore" href="#DAVE.scene.Scene.savepoint_restore">savepoint_restore</a></code></li>
<li><code><a title="DAVE.scene.Scene.solve_statics" href="#DAVE.scene.Scene.solve_statics">solve_statics</a></code></li>
<li><code><a title="DAVE.scene.Scene.sort_nodes_by_dependency" href="#DAVE.scene.Scene.sort_nodes_by_dependency">sort_nodes_by_dependency</a></code></li>
<li><code><a title="DAVE.scene.Scene.sort_nodes_by_parent" href="#DAVE.scene.Scene.sort_nodes_by_parent">sort_nodes_by_parent</a></code></li>
<li><code><a title="DAVE.scene.Scene.static_tolerance" href="#DAVE.scene.Scene.static_tolerance">static_tolerance</a></code></li>
<li><code><a title="DAVE.scene.Scene.update" href="#DAVE.scene.Scene.update">update</a></code></li>
<li><code><a title="DAVE.scene.Scene.verbose" href="#DAVE.scene.Scene.verbose">verbose</a></code></li>
<li><code><a title="DAVE.scene.Scene.verify_equilibrium" href="#DAVE.scene.Scene.verify_equilibrium">verify_equilibrium</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.Shackle" href="#DAVE.scene.Shackle">Shackle</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.Shackle.data" href="#DAVE.scene.Shackle.data">data</a></code></li>
<li><code><a title="DAVE.scene.Shackle.defined_kinds" href="#DAVE.scene.Shackle.defined_kinds">defined_kinds</a></code></li>
<li><code><a title="DAVE.scene.Shackle.kind" href="#DAVE.scene.Shackle.kind">kind</a></code></li>
<li><code><a title="DAVE.scene.Shackle.managed_nodes" href="#DAVE.scene.Shackle.managed_nodes">managed_nodes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.Sling" href="#DAVE.scene.Sling">Sling</a></code></h4>
<ul class="two-column">
<li><code><a title="DAVE.scene.Sling.EA" href="#DAVE.scene.Sling.EA">EA</a></code></li>
<li><code><a title="DAVE.scene.Sling.LeyeA" href="#DAVE.scene.Sling.LeyeA">LeyeA</a></code></li>
<li><code><a title="DAVE.scene.Sling.LeyeB" href="#DAVE.scene.Sling.LeyeB">LeyeB</a></code></li>
<li><code><a title="DAVE.scene.Sling.LspliceA" href="#DAVE.scene.Sling.LspliceA">LspliceA</a></code></li>
<li><code><a title="DAVE.scene.Sling.LspliceB" href="#DAVE.scene.Sling.LspliceB">LspliceB</a></code></li>
<li><code><a title="DAVE.scene.Sling.depends_on" href="#DAVE.scene.Sling.depends_on">depends_on</a></code></li>
<li><code><a title="DAVE.scene.Sling.diameter" href="#DAVE.scene.Sling.diameter">diameter</a></code></li>
<li><code><a title="DAVE.scene.Sling.endA" href="#DAVE.scene.Sling.endA">endA</a></code></li>
<li><code><a title="DAVE.scene.Sling.endB" href="#DAVE.scene.Sling.endB">endB</a></code></li>
<li><code><a title="DAVE.scene.Sling.length" href="#DAVE.scene.Sling.length">length</a></code></li>
<li><code><a title="DAVE.scene.Sling.managed_nodes" href="#DAVE.scene.Sling.managed_nodes">managed_nodes</a></code></li>
<li><code><a title="DAVE.scene.Sling.mass" href="#DAVE.scene.Sling.mass">mass</a></code></li>
<li><code><a title="DAVE.scene.Sling.sheaves" href="#DAVE.scene.Sling.sheaves">sheaves</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.Tank" href="#DAVE.scene.Tank">Tank</a></code></h4>
<ul class="two-column">
<li><code><a title="DAVE.scene.Tank.capacity" href="#DAVE.scene.Tank.capacity">capacity</a></code></li>
<li><code><a title="DAVE.scene.Tank.cog" href="#DAVE.scene.Tank.cog">cog</a></code></li>
<li><code><a title="DAVE.scene.Tank.cog_local" href="#DAVE.scene.Tank.cog_local">cog_local</a></code></li>
<li><code><a title="DAVE.scene.Tank.cog_when_full" href="#DAVE.scene.Tank.cog_when_full">cog_when_full</a></code></li>
<li><code><a title="DAVE.scene.Tank.density" href="#DAVE.scene.Tank.density">density</a></code></li>
<li><code><a title="DAVE.scene.Tank.fill_pct" href="#DAVE.scene.Tank.fill_pct">fill_pct</a></code></li>
<li><code><a title="DAVE.scene.Tank.free_flooding" href="#DAVE.scene.Tank.free_flooding">free_flooding</a></code></li>
<li><code><a title="DAVE.scene.Tank.level_global" href="#DAVE.scene.Tank.level_global">level_global</a></code></li>
<li><code><a title="DAVE.scene.Tank.permeability" href="#DAVE.scene.Tank.permeability">permeability</a></code></li>
<li><code><a title="DAVE.scene.Tank.trimesh" href="#DAVE.scene.Tank.trimesh">trimesh</a></code></li>
<li><code><a title="DAVE.scene.Tank.volume" href="#DAVE.scene.Tank.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.TriMeshSource" href="#DAVE.scene.TriMeshSource">TriMeshSource</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.TriMeshSource.AddFace" href="#DAVE.scene.TriMeshSource.AddFace">AddFace</a></code></li>
<li><code><a title="DAVE.scene.TriMeshSource.AddVertex" href="#DAVE.scene.TriMeshSource.AddVertex">AddVertex</a></code></li>
<li><code><a title="DAVE.scene.TriMeshSource.check_shape" href="#DAVE.scene.TriMeshSource.check_shape">check_shape</a></code></li>
<li><code><a title="DAVE.scene.TriMeshSource.get_extends" href="#DAVE.scene.TriMeshSource.get_extends">get_extends</a></code></li>
<li><code><a title="DAVE.scene.TriMeshSource.load_file" href="#DAVE.scene.TriMeshSource.load_file">load_file</a></code></li>
<li><code><a title="DAVE.scene.TriMeshSource.load_obj" href="#DAVE.scene.TriMeshSource.load_obj">load_obj</a></code></li>
<li><code><a title="DAVE.scene.TriMeshSource.load_vtk_polydataSource" href="#DAVE.scene.TriMeshSource.load_vtk_polydataSource">load_vtk_polydataSource</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.Visual" href="#DAVE.scene.Visual">Visual</a></code></h4>
<ul class="two-column">
<li><code><a title="DAVE.scene.Visual.change_parent_to" href="#DAVE.scene.Visual.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.Visual.file_path" href="#DAVE.scene.Visual.file_path">file_path</a></code></li>
<li><code><a title="DAVE.scene.Visual.offset" href="#DAVE.scene.Visual.offset">offset</a></code></li>
<li><code><a title="DAVE.scene.Visual.parent" href="#DAVE.scene.Visual.parent">parent</a></code></li>
<li><code><a title="DAVE.scene.Visual.path" href="#DAVE.scene.Visual.path">path</a></code></li>
<li><code><a title="DAVE.scene.Visual.rotation" href="#DAVE.scene.Visual.rotation">rotation</a></code></li>
<li><code><a title="DAVE.scene.Visual.scale" href="#DAVE.scene.Visual.scale">scale</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="DAVE.scene.WaveInteraction1" href="#DAVE.scene.WaveInteraction1">WaveInteraction1</a></code></h4>
<ul class="">
<li><code><a title="DAVE.scene.WaveInteraction1.change_parent_to" href="#DAVE.scene.WaveInteraction1.change_parent_to">change_parent_to</a></code></li>
<li><code><a title="DAVE.scene.WaveInteraction1.file_path" href="#DAVE.scene.WaveInteraction1.file_path">file_path</a></code></li>
<li><code><a title="DAVE.scene.WaveInteraction1.offset" href="#DAVE.scene.WaveInteraction1.offset">offset</a></code></li>
<li><code><a title="DAVE.scene.WaveInteraction1.parent" href="#DAVE.scene.WaveInteraction1.parent">parent</a></code></li>
<li><code><a title="DAVE.scene.WaveInteraction1.path" href="#DAVE.scene.WaveInteraction1.path">path</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>